{
  "version": 3,
  "sources": ["../../dataloader/index.js", "../../@mysten/walrus/src/constants.ts", "../../@mysten/walrus/src/contracts/utils/index.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/object.ts", "../../@mysten/walrus/src/contracts/walrus/storage_resource.ts", "../../@mysten/walrus/src/contracts/walrus/blob.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/vec_map.ts", "../../@mysten/walrus/src/contracts/walrus/metadata.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/object_table.ts", "../../@mysten/walrus/src/contracts/walrus/extended_field.ts", "../../@mysten/walrus/src/contracts/walrus/committee.ts", "../../@mysten/walrus/src/contracts/walrus/epoch_parameters.ts", "../../@mysten/walrus/src/contracts/walrus/staking_inner.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/group_ops.ts", "../../@mysten/walrus/src/contracts/walrus/event_blob.ts", "../../@mysten/walrus/src/contracts/walrus/storage_node.ts", "../../@mysten/walrus/src/contracts/walrus/pending_values.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/table.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/balance.ts", "../../@mysten/walrus/src/contracts/walrus/auth.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/bag.ts", "../../@mysten/walrus/src/contracts/walrus/staking_pool.ts", "../../@mysten/walrus/src/contracts/walrus/staking.ts", "../../@mysten/walrus/src/contracts/walrus/bls_aggregate.ts", "../../@mysten/walrus/src/contracts/walrus/storage_accounting.ts", "../../@mysten/walrus/src/contracts/walrus/system_state_inner.ts", "../../@mysten/walrus/src/contracts/walrus/system.ts", "../../@mysten/walrus/src/error.ts", "../../@mysten/walrus/src/utils/bcs.ts", "../../@mysten/walrus/src/storage-node/error.ts", "../../@mysten/walrus/src/storage-node/utils.ts", "../../@mysten/walrus/src/storage-node/client.ts", "../../@mysten/walrus/src/utils/index.ts", "../../@mysten/walrus/src/utils/object-loader.ts", "../../@mysten/walrus/src/utils/randomness.ts", "../../@mysten/walrus-wasm/web/walrus_wasm.js", "../../@mysten/walrus/src/wasm.ts", "../../@mysten/walrus/src/upload-relay/client.ts", "../../@mysten/walrus/src/utils/quilts.ts", "../../@mysten/walrus/src/files/readers/quilt-file.ts", "../../@mysten/walrus/src/files/readers/quilt.ts", "../../@mysten/walrus/src/files/readers/blob.ts", "../../@mysten/walrus/src/files/readers/local.ts", "../../@mysten/walrus/src/files/file.ts", "../../@mysten/walrus/src/files/blob.ts", "../../@mysten/walrus/src/utils/retry.ts", "../../@mysten/walrus/src/client.ts"],
  "sourcesContent": ["\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey; // If caching and there is a cache-hit, return cached Promise.\n\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The name given to this `DataLoader` instance. Useful for APM tools.\n   *\n   * Is `null` if not set in the constructor.\n   */\n  ;\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise;\n\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + (\"errored synchronously: \" + String(e) + \".\")));\n  } // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var _value = values[i];\n\n      if (_value instanceof Error) {\n        batch.callbacks[i].reject(_value);\n      } else {\n        batch.callbacks[i].resolve(_value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n}\n\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n\n  return null;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BlobStatus } from './storage-node/types.js';\nimport type { WalrusPackageConfig } from './types.js';\n\nexport const TESTNET_WALRUS_PACKAGE_CONFIG = {\n\tsystemObjectId: '0x6c2547cbbc38025cf3adac45f63cb0a8d12ecf777cdc75a4971612bf97fdf6af',\n\tstakingPoolId: '0xbe46180321c30aab2f8b3501e24048377287fa708018a5b7c2792b35fe339ee3',\n\texchangeIds: [\n\t\t'0xf4d164ea2def5fe07dc573992a029e010dba09b1a8dcbc44c5c2e79567f39073',\n\t\t'0x19825121c52080bb1073662231cfea5c0e4d905fd13e95f21e9a018f2ef41862',\n\t\t'0x83b454e524c71f30803f4d6c302a86fb6a39e96cdfb873c2d1e93bc1c26a3bc5',\n\t\t'0x8d63209cf8589ce7aef8f262437163c67577ed09f3e636a9d8e0813843fb8bf1',\n\t],\n} satisfies WalrusPackageConfig;\n\nexport const MAINNET_WALRUS_PACKAGE_CONFIG = {\n\tsystemObjectId: '0x2134d52768ea07e8c43570ef975eb3e4c27a39fa6396bef985b5abc58d03ddd2',\n\tstakingPoolId: '0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904',\n} satisfies WalrusPackageConfig;\n\n// Ranking of blob status types from earliest -> latest in the lifecycle of a blob.\nexport const statusLifecycleRank: Record<BlobStatus['type'], number> = {\n\tnonexistent: 0,\n\tdeletable: 1,\n\tpermanent: 2,\n\tinvalid: 3,\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BcsType, TypeTag } from '@mysten/sui/bcs';\nimport { bcs, TypeTagSerializer, BcsStruct, BcsEnum, BcsTuple } from '@mysten/sui/bcs';\nimport { normalizeSuiAddress } from '@mysten/sui/utils';\nimport type { TransactionArgument } from '@mysten/sui/transactions';\nimport { isArgument } from '@mysten/sui/transactions';\n\nconst MOVE_STDLIB_ADDRESS = normalizeSuiAddress('0x1');\nconst SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress('0x2');\nconst SUI_SYSTEM_ADDRESS = normalizeSuiAddress('0x3');\n\nexport type RawTransactionArgument<T> = T | TransactionArgument;\n\nexport function getPureBcsSchema(typeTag: string | TypeTag): BcsType<any> | null {\n\tconst parsedTag = typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;\n\n\tif ('u8' in parsedTag) {\n\t\treturn bcs.U8;\n\t} else if ('u16' in parsedTag) {\n\t\treturn bcs.U16;\n\t} else if ('u32' in parsedTag) {\n\t\treturn bcs.U32;\n\t} else if ('u64' in parsedTag) {\n\t\treturn bcs.U64;\n\t} else if ('u128' in parsedTag) {\n\t\treturn bcs.U128;\n\t} else if ('u256' in parsedTag) {\n\t\treturn bcs.U256;\n\t} else if ('address' in parsedTag) {\n\t\treturn bcs.Address;\n\t} else if ('bool' in parsedTag) {\n\t\treturn bcs.Bool;\n\t} else if ('vector' in parsedTag) {\n\t\tconst type = getPureBcsSchema(parsedTag.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t} else if ('struct' in parsedTag) {\n\t\tconst structTag = parsedTag.struct;\n\t\tconst pkg = normalizeSuiAddress(parsedTag.struct.address);\n\n\t\tif (pkg === MOVE_STDLIB_ADDRESS) {\n\t\t\tif (\n\t\t\t\t(structTag.module === 'ascii' || structTag.module === 'string') &&\n\t\t\t\tstructTag.name === 'String'\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (structTag.module === 'option' && structTag.name === 'Option') {\n\t\t\t\tconst type = getPureBcsSchema(structTag.typeParams[0]!);\n\t\t\t\treturn type ? bcs.option(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (pkg === SUI_FRAMEWORK_ADDRESS && structTag.module === 'Object' && structTag.name === 'ID') {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizeMoveArguments(\n\targs: unknown[] | object,\n\targTypes: string[],\n\tparameterNames?: string[],\n) {\n\tconst argLen = Array.isArray(args) ? args.length : Object.keys(args).length;\n\tif (parameterNames && argLen !== parameterNames.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of arguments, expected ${parameterNames.length}, got ${argLen}`,\n\t\t);\n\t}\n\n\tconst normalizedArgs: TransactionArgument[] = [];\n\n\tlet index = 0;\n\tfor (const [i, argType] of argTypes.entries()) {\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::deny_list::DenyList`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.denyList());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::random::Random`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.random());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::clock::Clock`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.clock());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_SYSTEM_ADDRESS}::sui_system::SuiSystemState`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.system());\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet arg;\n\t\tif (Array.isArray(args)) {\n\t\t\tif (index >= args.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid number of arguments, expected at least ${index + 1}, got ${args.length}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\targ = args[index];\n\t\t} else {\n\t\t\tif (!parameterNames) {\n\t\t\t\tthrow new Error(`Expected arguments to be passed as an array`);\n\t\t\t}\n\t\t\tconst name = parameterNames[index];\n\t\t\targ = args[name as keyof typeof args];\n\n\t\t\tif (arg == null) {\n\t\t\t\tthrow new Error(`Parameter ${name} is required`);\n\t\t\t}\n\t\t}\n\n\t\tindex += 1;\n\n\t\tif (typeof arg === 'function' || isArgument(arg)) {\n\t\t\tnormalizedArgs.push(arg as TransactionArgument);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst type = argTypes[i]!;\n\t\tconst bcsType = getPureBcsSchema(type);\n\n\t\tif (bcsType) {\n\t\t\tconst bytes = bcsType.serialize(arg as never);\n\t\t\tnormalizedArgs.push((tx) => tx.pure(bytes));\n\t\t\tcontinue;\n\t\t} else if (typeof arg === 'string') {\n\t\t\tnormalizedArgs.push((tx) => tx.object(arg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tthrow new Error(`Invalid argument ${stringify(arg)} for type ${type}`);\n\t}\n\n\treturn normalizedArgs;\n}\n\nexport class MoveStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsStruct<T, Name> {}\n\nexport class MoveEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string,\n> extends BcsEnum<T, Name> {}\n\nexport class MoveTuple<\n\tT extends readonly BcsType<any>[],\n\tconst Name extends string,\n> extends BcsTuple<T, Name> {}\n\nfunction stringify(val: unknown) {\n\tif (typeof val === 'object') {\n\t\treturn JSON.stringify(val, (val: unknown) => val);\n\t}\n\tif (typeof val === 'bigint') {\n\t\treturn val.toString();\n\t}\n\n\treturn val;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Sui object identifiers */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::object';\nexport const UID = new MoveStruct({\n\tname: `${$moduleName}::UID`,\n\tfields: {\n\t\tid: bcs.Address,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::storage_resource';\nexport const Storage = new MoveStruct({\n\tname: `${$moduleName}::Storage`,\n\tfields: {\n\t\tid: object.UID,\n\t\tstart_epoch: bcs.u32(),\n\t\tend_epoch: bcs.u32(),\n\t\tstorage_size: bcs.u64(),\n\t},\n});\nexport interface StartEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StartEpochOptions {\n\tpackage?: string;\n\targuments: StartEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function startEpoch(options: StartEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'start_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitByEpochArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitEpoch: RawTransactionArgument<number>;\n}\nexport interface SplitByEpochOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitByEpochArguments\n\t\t| [storage: RawTransactionArgument<string>, splitEpoch: RawTransactionArgument<number>];\n}\n/**\n * Splits the storage object into two based on `split_epoch`.\n *\n * `storage` is modified to cover the period from `start_epoch` to `split_epoch`\n * and a new storage object covering `split_epoch` to `end_epoch` is returned.\n */\nexport function splitByEpoch(options: SplitByEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`, 'u32'] satisfies string[];\n\tconst parameterNames = ['storage', 'splitEpoch'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitBySizeArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitSize: RawTransactionArgument<number | bigint>;\n}\nexport interface SplitBySizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitBySizeArguments\n\t\t| [storage: RawTransactionArgument<string>, splitSize: RawTransactionArgument<number | bigint>];\n}\n/**\n * Splits the storage object into two based on `split_size`.\n *\n * `storage` is modified to cover `split_size` and a new object covering\n * `storage.storage_size - split_size` is created.\n */\nexport function splitBySize(options: SplitBySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`, 'u64'] satisfies string[];\n\tconst parameterNames = ['storage', 'splitSize'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FusePeriodsArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FusePeriodsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FusePeriodsArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover adjacent periods with the same storage size. */\nexport function fusePeriods(options: FusePeriodsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_periods',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseAmountArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseAmountOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseAmountArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover the same period. */\nexport function fuseAmount(options: FuseAmountOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_amount',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/**\n * Fuse two storage objects that either cover the same period or adjacent periods\n * with the same storage size.\n */\nexport function fuse(options: FuseOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DestroyArguments {\n\tstorage: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [storage: RawTransactionArgument<string>];\n}\n/** Destructor for [Storage] objects. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['storage'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nimport * as storage_resource from './storage_resource.js';\nconst $moduleName = '@local-pkg/walrus::blob';\nexport const Blob = new MoveStruct({\n\tname: `${$moduleName}::Blob`,\n\tfields: {\n\t\tid: object.UID,\n\t\tregistered_epoch: bcs.u32(),\n\t\tblob_id: bcs.u256(),\n\t\tsize: bcs.u64(),\n\t\tencoding_type: bcs.u8(),\n\t\tcertified_epoch: bcs.option(bcs.u32()),\n\t\tstorage: storage_resource.Storage,\n\t\tdeletable: bcs.bool(),\n\t},\n});\nexport const BlobIdDerivation = new MoveStruct({\n\tname: `${$moduleName}::BlobIdDerivation`,\n\tfields: {\n\t\tencoding_type: bcs.u8(),\n\t\tsize: bcs.u64(),\n\t\troot_hash: bcs.u256(),\n\t},\n});\nexport interface ObjectIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ObjectIdOptions {\n\tpackage?: string;\n\targuments: ObjectIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function objectId(options: ObjectIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'object_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisteredEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface RegisteredEpochOptions {\n\tpackage?: string;\n\targuments: RegisteredEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function registeredEpoch(options: RegisteredEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'registered_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BlobIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BlobIdOptions {\n\tpackage?: string;\n\targuments: BlobIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function blobId(options: BlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EncodingTypeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EncodingTypeOptions {\n\tpackage?: string;\n\targuments: EncodingTypeArguments | [self: RawTransactionArgument<string>];\n}\nexport function encodingType(options: EncodingTypeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'encoding_type',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifiedEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface CertifiedEpochOptions {\n\tpackage?: string;\n\targuments: CertifiedEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function certifiedEpoch(options: CertifiedEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'certified_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface StorageArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StorageOptions {\n\tpackage?: string;\n\targuments: StorageArguments | [self: RawTransactionArgument<string>];\n}\nexport function storage(options: StorageOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'storage',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface IsDeletableArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface IsDeletableOptions {\n\tpackage?: string;\n\targuments: IsDeletableArguments | [self: RawTransactionArgument<string>];\n}\nexport function isDeletable(options: IsDeletableOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'is_deletable',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EncodedSizeArguments {\n\tself: RawTransactionArgument<string>;\n\tnShards: RawTransactionArgument<number>;\n}\nexport interface EncodedSizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| EncodedSizeArguments\n\t\t| [self: RawTransactionArgument<string>, nShards: RawTransactionArgument<number>];\n}\nexport function encodedSize(options: EncodedSizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`, 'u16'] satisfies string[];\n\tconst parameterNames = ['self', 'nShards'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'encoded_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeriveBlobIdArguments {\n\trootHash: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tsize: RawTransactionArgument<number | bigint>;\n}\nexport interface DeriveBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeriveBlobIdArguments\n\t\t| [\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Derives the blob_id for a blob given the root_hash, encoding_type and size. */\nexport function deriveBlobId(options: DeriveBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = ['u256', 'u8', 'u64'] satisfies string[];\n\tconst parameterNames = ['rootHash', 'encodingType', 'size'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'derive_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BurnArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BurnOptions {\n\tpackage?: string;\n\targuments: BurnArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Allow the owner of a blob object to destroy it.\n *\n * This function also burns any [`Metadata`] associated with the blob, if present.\n */\nexport function burn(options: BurnOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'burn',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface AddMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, metadata: RawTransactionArgument<string>];\n}\n/**\n * Adds the metadata dynamic field to the Blob.\n *\n * Aborts if the metadata is already present.\n */\nexport function addMetadata(options: AddMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::metadata::Metadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'add_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddOrReplaceMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface AddOrReplaceMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddOrReplaceMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, metadata: RawTransactionArgument<string>];\n}\n/**\n * Adds the metadata dynamic field to the Blob, replacing the existing metadata if\n * present.\n *\n * Returns the replaced metadata if present.\n */\nexport function addOrReplaceMetadata(options: AddOrReplaceMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::metadata::Metadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'add_or_replace_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TakeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TakeMetadataOptions {\n\tpackage?: string;\n\targuments: TakeMetadataArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata dynamic field from the Blob, returning the contained\n * `Metadata`.\n *\n * Aborts if the metadata does not exist.\n */\nexport function takeMetadata(options: TakeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'take_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InsertOrUpdateMetadataPairArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<string>;\n}\nexport interface InsertOrUpdateMetadataPairOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InsertOrUpdateMetadataPairArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tkey: RawTransactionArgument<string>,\n\t\t\t\tvalue: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Inserts a key-value pair into the metadata.\n *\n * If the key is already present, the value is updated. Creates new metadata on the\n * Blob object if it does not exist already.\n */\nexport function insertOrUpdateMetadataPair(options: InsertOrUpdateMetadataPairOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'insert_or_update_metadata_pair',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMetadataPairArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveMetadataPairOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMetadataPairArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata associated with the given key.\n *\n * Aborts if the metadata does not exist.\n */\nexport function removeMetadataPair(options: RemoveMetadataPairOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'remove_metadata_pair',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMetadataPairIfExistsArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveMetadataPairIfExistsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMetadataPairIfExistsArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/** Removes and returns the metadata associated with the given key, if it exists. */\nexport function removeMetadataPairIfExists(options: RemoveMetadataPairIfExistsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'remove_metadata_pair_if_exists',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { MoveStruct } from '../../../utils/index.js';\nconst $moduleName = '0x2::vec_map';\n/** An entry in the map */\nexport function Entry<K extends BcsType<any>, V extends BcsType<any>>(...typeParameters: [K, V]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::Entry<${typeParameters[0].name as K['name']}, ${typeParameters[1].name as V['name']}>`,\n\t\tfields: {\n\t\t\tkey: typeParameters[0],\n\t\t\tvalue: typeParameters[1],\n\t\t},\n\t});\n}\n/**\n * A map data structure backed by a vector. The map is guaranteed not to contain\n * duplicate keys, but entries are _not_ sorted by key--entries are included in\n * insertion order. All operations are O(N) in the size of the map--the intention\n * of this data structure is only to provide the convenience of programming against\n * a map API. Large maps should use handwritten parent/child relationships instead.\n * Maps that need sorted iteration rather than insertion order iteration should\n * also be handwritten.\n */\nexport function VecMap<K extends BcsType<any>, V extends BcsType<any>>(...typeParameters: [K, V]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::VecMap<${typeParameters[0].name as K['name']}, ${typeParameters[1].name as V['name']}>`,\n\t\tfields: {\n\t\t\tcontents: bcs.vector(Entry(typeParameters[0], typeParameters[1])),\n\t\t},\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Contains the metadata for Blobs on Walrus. */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::metadata';\nexport const Metadata = new MoveStruct({\n\tname: `${$moduleName}::Metadata`,\n\tfields: {\n\t\tmetadata: vec_map.VecMap(bcs.string(), bcs.string()),\n\t},\n});\nexport interface NewOptions {\n\tpackage?: string;\n\targuments?: [];\n}\n/** Creates a new instance of Metadata. */\nexport function _new(options: NewOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'new',\n\t\t});\n}\nexport interface InsertOrUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<string>;\n}\nexport interface InsertOrUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InsertOrUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tkey: RawTransactionArgument<string>,\n\t\t\t\tvalue: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Inserts a key-value pair into the metadata.\n *\n * If the key is already present, the value is updated.\n */\nexport function insertOrUpdate(options: InsertOrUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'insert_or_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/** Removes the metadata associated with the given key. */\nexport function remove(options: RemoveOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'remove',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveIfExistsArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveIfExistsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveIfExistsArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata associated with the given key, if it exists.\n *\n * Optionally returns the previous value associated with the key.\n */\nexport function removeIfExists(options: RemoveIfExistsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'remove_if_exists',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Similar to `sui::table`, an `ObjectTable<K, V>` is a map-like collection. But\n * unlike `sui::table`, the values bound to these dynamic fields _must_ be objects\n * themselves. This allows for the objects to still exist within in storage, which\n * may be important for external tools. The difference is otherwise not observable\n * from within Move.\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::object_table';\nexport const ObjectTable = new MoveStruct({\n\tname: `${$moduleName}::ObjectTable`,\n\tfields: {\n\t\t/** the ID of this table */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the table */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: extended_field */\n\nimport { MoveStruct, MoveTuple, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::extended_field';\nexport const ExtendedField = new MoveStruct({\n\tname: `${$moduleName}::ExtendedField`,\n\tfields: {\n\t\tid: object.UID,\n\t},\n});\nexport const Key = new MoveTuple({ name: `${$moduleName}::Key`, fields: [bcs.bool()] });\nexport interface NewArguments<T extends BcsType<any>> {\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface NewOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments: NewArguments<T> | [value: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Creates a new extended field with the given value. */\nexport function _new<T extends BcsType<any>>(options: NewOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${options.typeArguments[0]}`] satisfies string[];\n\tconst parameterNames = ['value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface BorrowArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface BorrowOptions {\n\tpackage?: string;\n\targuments: BorrowArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Borrows the value stored in the extended field. */\nexport function borrow(options: BorrowOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'borrow',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface BorrowMutArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface BorrowMutOptions {\n\tpackage?: string;\n\targuments: BorrowMutArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Borrows the value stored in the extended field mutably. */\nexport function borrowMut(options: BorrowMutOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'borrow_mut',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface SwapArguments<T extends BcsType<any>> {\n\tfield: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface SwapOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments:\n\t\t| SwapArguments<T>\n\t\t| [field: RawTransactionArgument<string>, value: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Swaps the value stored in the extended field with the given value. */\nexport function swap<T extends BcsType<any>>(options: SwapOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t\t`${options.typeArguments[0]}`,\n\t] satisfies string[];\n\tconst parameterNames = ['field', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'swap',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface DestroyArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Destroys the extended field and returns the value stored in it. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This module defines the `Committee` struct which stores the current committee\n * with shard assignments. Additionally, it manages transitions / transfers of\n * shards between committees with the least amount of changes.\n */\n\nimport { MoveTuple, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::committee';\nexport const Committee = new MoveTuple({\n\tname: `${$moduleName}::Committee`,\n\tfields: [vec_map.VecMap(bcs.Address, bcs.vector(bcs.u16()))],\n});\nexport interface ShardsArguments {\n\tcmt: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface ShardsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ShardsArguments\n\t\t| [cmt: RawTransactionArgument<string>, nodeId: RawTransactionArgument<string>];\n}\n/** Get the shards assigned to the given `node_id`. */\nexport function shards(options: ShardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::committee::Committee`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['cmt', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'shards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tcmt: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [cmt: RawTransactionArgument<string>];\n}\n/** Get the number of nodes in the committee. */\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::committee::Committee`] satisfies string[];\n\tconst parameterNames = ['cmt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InnerArguments {\n\tcmt: RawTransactionArgument<string>;\n}\nexport interface InnerOptions {\n\tpackage?: string;\n\targuments: InnerArguments | [cmt: RawTransactionArgument<string>];\n}\n/** Get the inner representation of the committee. */\nexport function inner(options: InnerOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::committee::Committee`] satisfies string[];\n\tconst parameterNames = ['cmt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'inner',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ToInnerArguments {\n\tcmt: RawTransactionArgument<string>;\n}\nexport interface ToInnerOptions {\n\tpackage?: string;\n\targuments: ToInnerArguments | [cmt: RawTransactionArgument<string>];\n}\n/** Copy the inner representation of the committee. */\nexport function toInner(options: ToInnerOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::committee::Committee`] satisfies string[];\n\tconst parameterNames = ['cmt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'to_inner',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '@local-pkg/walrus::epoch_parameters';\nexport const EpochParams = new MoveStruct({\n\tname: `${$moduleName}::EpochParams`,\n\tfields: {\n\t\t/** The storage capacity of the system. */\n\t\ttotal_capacity_size: bcs.u64(),\n\t\t/** The price per unit size of storage. */\n\t\tstorage_price_per_unit_size: bcs.u64(),\n\t\t/** The write price per unit size. */\n\t\twrite_price_per_unit_size: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveEnum, MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object_table from './deps/sui/object_table.js';\nimport * as extended_field from './extended_field.js';\nimport * as committee from './committee.js';\nimport * as epoch_parameters from './epoch_parameters.js';\nconst $moduleName = '@local-pkg/walrus::staking_inner';\n/** The epoch state. */\nexport const EpochState = new MoveEnum({\n\tname: `${$moduleName}::EpochState`,\n\tfields: {\n\t\tEpochChangeSync: bcs.u16(),\n\t\tEpochChangeDone: bcs.u64(),\n\t\tNextParamsSelected: bcs.u64(),\n\t},\n});\nexport const StakingInnerV1 = new MoveStruct({\n\tname: `${$moduleName}::StakingInnerV1`,\n\tfields: {\n\t\t/** The number of shards in the system. */\n\t\tn_shards: bcs.u16(),\n\t\t/** The duration of an epoch in ms. Does not affect the first (zero) epoch. */\n\t\tepoch_duration: bcs.u64(),\n\t\t/**\n\t\t * Special parameter, used only for the first epoch. The timestamp when the first\n\t\t * epoch can be started.\n\t\t */\n\t\tfirst_epoch_start: bcs.u64(),\n\t\t/**\n\t\t * Stored staking pools, each identified by a unique `ID` and contains the\n\t\t * `StakingPool` object. Uses `ObjectTable` to make the pool discovery easier by\n\t\t * avoiding wrapping.\n\t\t *\n\t\t * The key is the ID of the staking pool.\n\t\t */\n\t\tpools: object_table.ObjectTable,\n\t\t/**\n\t\t * The current epoch of the Walrus system. The epochs are not the same as the Sui\n\t\t * epochs, not to be mistaken with `ctx.epoch()`.\n\t\t */\n\t\tepoch: bcs.u32(),\n\t\t/** Stores the active set of storage nodes. Tracks the total amount of staked WAL. */\n\t\tactive_set: extended_field.ExtendedField,\n\t\t/** The next committee in the system. */\n\t\tnext_committee: bcs.option(committee.Committee),\n\t\t/** The current committee in the system. */\n\t\tcommittee: committee.Committee,\n\t\t/** The previous committee in the system. */\n\t\tprevious_committee: committee.Committee,\n\t\t/** The next epoch parameters. */\n\t\tnext_epoch_params: bcs.option(epoch_parameters.EpochParams),\n\t\t/** The state of the current epoch. */\n\t\tepoch_state: EpochState,\n\t\t/**\n\t\t * The public keys for the next epoch. The keys are stored in a sorted `VecMap`,\n\t\t * and mirror the order of the nodes in the `next_committee`. The value is set in\n\t\t * the `select_committee` function and consumed in the `next_bls_committee`\n\t\t * function.\n\t\t */\n\t\tnext_epoch_public_keys: extended_field.ExtendedField,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Generic Move and native functions for group operations. */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::group_ops';\nexport const Element = new MoveStruct({\n\tname: `${$moduleName}::Element`,\n\tfields: {\n\t\tbytes: bcs.vector(bcs.u8()),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module to certify event blobs. */\n\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::event_blob';\nexport const EventBlobAttestation = new MoveStruct({\n\tname: `${$moduleName}::EventBlobAttestation`,\n\tfields: {\n\t\tcheckpoint_sequence_num: bcs.u64(),\n\t\tepoch: bcs.u32(),\n\t},\n});\nexport const EventBlob = new MoveStruct({\n\tname: `${$moduleName}::EventBlob`,\n\tfields: {\n\t\t/** Blob id of the certified event blob. */\n\t\tblob_id: bcs.u256(),\n\t\t/** Ending sui checkpoint of the certified event blob. */\n\t\tending_checkpoint_sequence_number: bcs.u64(),\n\t},\n});\nexport const EventBlobCertificationState = new MoveStruct({\n\tname: `${$moduleName}::EventBlobCertificationState`,\n\tfields: {\n\t\t/** Latest certified event blob. */\n\t\tlatest_certified_blob: bcs.option(EventBlob),\n\t\t/** Current event blob being attested. */\n\t\taggregate_weight_per_blob: vec_map.VecMap(EventBlob, bcs.u16()),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as group_ops from './deps/sui/group_ops.js';\nimport * as extended_field from './extended_field.js';\nimport * as object from './deps/sui/object.js';\nimport * as event_blob from './event_blob.js';\nconst $moduleName = '@local-pkg/walrus::storage_node';\nexport const StorageNodeInfo = new MoveStruct({\n\tname: `${$moduleName}::StorageNodeInfo`,\n\tfields: {\n\t\tname: bcs.string(),\n\t\tnode_id: bcs.Address,\n\t\tnetwork_address: bcs.string(),\n\t\tpublic_key: group_ops.Element,\n\t\tnext_epoch_public_key: bcs.option(group_ops.Element),\n\t\tnetwork_public_key: bcs.vector(bcs.u8()),\n\t\tmetadata: extended_field.ExtendedField,\n\t},\n});\nexport const StorageNodeCap = new MoveStruct({\n\tname: `${$moduleName}::StorageNodeCap`,\n\tfields: {\n\t\tid: object.UID,\n\t\tnode_id: bcs.Address,\n\t\tlast_epoch_sync_done: bcs.u32(),\n\t\tlast_event_blob_attestation: bcs.option(event_blob.EventBlobAttestation),\n\t\t/** Stores the Merkle root of the deny list for the storage node. */\n\t\tdeny_list_root: bcs.u256(),\n\t\t/** Stores the sequence number of the deny list for the storage node. */\n\t\tdeny_list_sequence: bcs.u64(),\n\t\t/** Stores the size of the deny list for the storage node. */\n\t\tdeny_list_size: bcs.u64(),\n\t},\n});\nexport interface IdArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface IdOptions {\n\tpackage?: string;\n\targuments: IdArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the node ID of the storage node. */\nexport function id(options: IdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeInfo`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NodeIdArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface NodeIdOptions {\n\tpackage?: string;\n\targuments: NodeIdArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the pool ID of the storage node. */\nexport function nodeId(options: NodeIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'node_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface LastEpochSyncDoneArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface LastEpochSyncDoneOptions {\n\tpackage?: string;\n\targuments: LastEpochSyncDoneArguments | [cap: RawTransactionArgument<string>];\n}\n/**\n * Return the last epoch in which the storage node attested that it has finished\n * syncing.\n */\nexport function lastEpochSyncDone(options: LastEpochSyncDoneOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'last_epoch_sync_done',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface LastEventBlobAttestationArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface LastEventBlobAttestationOptions {\n\tpackage?: string;\n\targuments: LastEventBlobAttestationArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the latest event blob attestation. */\nexport function lastEventBlobAttestation(options: LastEventBlobAttestationOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'last_event_blob_attestation',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DenyListRootArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface DenyListRootOptions {\n\tpackage?: string;\n\targuments: DenyListRootArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the deny list root of the storage node. */\nexport function denyListRoot(options: DenyListRootOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'deny_list_root',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DenyListSequenceArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface DenyListSequenceOptions {\n\tpackage?: string;\n\targuments: DenyListSequenceArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the deny list sequence number of the storage node. */\nexport function denyListSequence(options: DenyListSequenceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'deny_list_sequence',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveTuple } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::pending_values';\nexport const PendingValues = new MoveTuple({\n\tname: `${$moduleName}::PendingValues`,\n\tfields: [vec_map.VecMap(bcs.u32(), bcs.u64())],\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A table is a map-like collection. But unlike a traditional collection, it's keys\n * and values are not stored within the `Table` value, but instead are stored using\n * Sui's object system. The `Table` struct acts only as a handle into the object\n * system to retrieve those keys and values. Note that this means that `Table`\n * values with exactly the same key-value mapping will not be equal, with `==`, at\n * runtime. For example\n *\n * ```\n * let table1 = table::new<u64, bool>();\n * let table2 = table::new<u64, bool>();\n * table::add(&mut table1, 0, false);\n * table::add(&mut table1, 1, true);\n * table::add(&mut table2, 0, false);\n * table::add(&mut table2, 1, true);\n * // table1 does not equal table2, despite having the same entries\n * assert!(&table1 != &table2);\n * ```\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::table';\nexport const Table = new MoveStruct({\n\tname: `${$moduleName}::Table`,\n\tfields: {\n\t\t/** the ID of this table */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the table */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A storable handler for Balances in general. Is used in the `Coin` module to\n * allow balance operations and can be used to implement custom coins with `Supply`\n * and `Balance`s.\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::balance';\nexport const Balance = new MoveStruct({\n\tname: `${$moduleName}::Balance`,\n\tfields: {\n\t\tvalue: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveEnum, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/walrus::auth';\n/**\n * Authentication for either a sender or an object. Unlike the `Authorized` type,\n * it cannot be stored and must be used or ignored in the same transaction.\n */\nexport const Authenticated = new MoveEnum({\n\tname: `${$moduleName}::Authenticated`,\n\tfields: {\n\t\tSender: bcs.Address,\n\t\tObject: bcs.Address,\n\t},\n});\n/**\n * Defines the ways to authorize an action. It can be either an address - checked\n * with `ctx.sender()`, - or an object - checked with `object::id(..)`.\n */\nexport const Authorized = new MoveEnum({\n\tname: `${$moduleName}::Authorized`,\n\tfields: {\n\t\tAddress: bcs.Address,\n\t\tObjectID: bcs.Address,\n\t},\n});\nexport interface AuthenticateSenderOptions {\n\tpackage?: string;\n\targuments?: [];\n}\n/** Authenticates the sender as the authorizer. */\nexport function authenticateSender(options: AuthenticateSenderOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authenticate_sender',\n\t\t});\n}\nexport interface AuthenticateWithObjectArguments<T extends BcsType<any>> {\n\tobj: RawTransactionArgument<T>;\n}\nexport interface AuthenticateWithObjectOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments: AuthenticateWithObjectArguments<T> | [obj: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Authenticates an object as the authorizer. */\nexport function authenticateWithObject<T extends BcsType<any>>(\n\toptions: AuthenticateWithObjectOptions<T>,\n) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${options.typeArguments[0]}`] satisfies string[];\n\tconst parameterNames = ['obj'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authenticate_with_object',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface AuthorizedAddressArguments {\n\taddr: RawTransactionArgument<string>;\n}\nexport interface AuthorizedAddressOptions {\n\tpackage?: string;\n\targuments: AuthorizedAddressArguments | [addr: RawTransactionArgument<string>];\n}\n/** Returns the `Authorized` as an address. */\nexport function authorizedAddress(options: AuthorizedAddressOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = ['address'] satisfies string[];\n\tconst parameterNames = ['addr'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authorized_address',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AuthorizedObjectArguments {\n\tid: RawTransactionArgument<string>;\n}\nexport interface AuthorizedObjectOptions {\n\tpackage?: string;\n\targuments: AuthorizedObjectArguments | [id: RawTransactionArgument<string>];\n}\n/** Returns the `Authorized` as an object. */\nexport function authorizedObject(options: AuthorizedObjectOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['id'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authorized_object',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A bag is a heterogeneous map-like collection. The collection is similar to\n * `sui::table` in that its keys and values are not stored within the `Bag` value,\n * but instead are stored using Sui's object system. The `Bag` struct acts only as\n * a handle into the object system to retrieve those keys and values. Note that\n * this means that `Bag` values with exactly the same key-value mapping will not be\n * equal, with `==`, at runtime. For example\n *\n * ```\n * let bag1 = bag::new();\n * let bag2 = bag::new();\n * bag::add(&mut bag1, 0, false);\n * bag::add(&mut bag1, 1, true);\n * bag::add(&mut bag2, 0, false);\n * bag::add(&mut bag2, 1, true);\n * // bag1 does not equal bag2, despite having the same entries\n * assert!(&bag1 != &bag2);\n * ```\n *\n * At it's core, `sui::bag` is a wrapper around `UID` that allows for access to\n * `sui::dynamic_field` while preventing accidentally stranding field values. A\n * `UID` can be deleted, even if it has dynamic fields associated with it, but a\n * bag, on the other hand, must be empty to be destroyed.\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::bag';\nexport const Bag = new MoveStruct({\n\tname: `${$moduleName}::Bag`,\n\tfields: {\n\t\t/** the ID of this bag */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the bag */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: staking_pool */\n\nimport { MoveStruct, MoveEnum } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './deps/sui/object.js';\nimport * as storage_node from './storage_node.js';\nimport * as pending_values from './pending_values.js';\nimport * as table from './deps/sui/table.js';\nimport * as balance from './deps/sui/balance.js';\nimport * as auth from './auth.js';\nimport * as bag from './deps/sui/bag.js';\nconst $moduleName = '@local-pkg/walrus::staking_pool';\nexport const VotingParams = new MoveStruct({\n\tname: `${$moduleName}::VotingParams`,\n\tfields: {\n\t\t/** Voting: storage price for the next epoch. */\n\t\tstorage_price: bcs.u64(),\n\t\t/** Voting: write price for the next epoch. */\n\t\twrite_price: bcs.u64(),\n\t\t/** Voting: node capacity for the next epoch. */\n\t\tnode_capacity: bcs.u64(),\n\t},\n});\n/** Represents the state of the staking pool. */\nexport const PoolState = new MoveEnum({\n\tname: `${$moduleName}::PoolState`,\n\tfields: {\n\t\tActive: null,\n\t\tWithdrawing: bcs.u32(),\n\t\tWithdrawn: null,\n\t},\n});\nexport const StakingPool = new MoveStruct({\n\tname: `${$moduleName}::StakingPool`,\n\tfields: {\n\t\tid: object.UID,\n\t\t/** The current state of the pool. */\n\t\tstate: PoolState,\n\t\t/** Current epoch's pool parameters. */\n\t\tvoting_params: VotingParams,\n\t\t/** The storage node info for the pool. */\n\t\tnode_info: storage_node.StorageNodeInfo,\n\t\t/**\n\t\t * The epoch when the pool is / will be activated. Serves information purposes\n\t\t * only, the checks are performed in the `state` property.\n\t\t */\n\t\tactivation_epoch: bcs.u32(),\n\t\t/** Epoch when the pool was last updated. */\n\t\tlatest_epoch: bcs.u32(),\n\t\t/** Currently staked WAL in the pool + rewards pool. */\n\t\twal_balance: bcs.u64(),\n\t\t/** The total number of shares in the current epoch. */\n\t\tnum_shares: bcs.u64(),\n\t\t/**\n\t\t * The amount of the shares that will be withdrawn in E+1 or E+2. We use this\n\t\t * amount to calculate the WAL withdrawal in the `process_pending_stake`.\n\t\t */\n\t\tpending_shares_withdraw: pending_values.PendingValues,\n\t\t/**\n\t\t * The amount of the stake requested for withdrawal for a node that may part of the\n\t\t * next committee. Stores principals of not yet active stakes. In practice, those\n\t\t * tokens are staked for exactly one epoch.\n\t\t */\n\t\tpre_active_withdrawals: pending_values.PendingValues,\n\t\t/**\n\t\t * The pending commission rate for the pool. Commission rate is applied in E+2, so\n\t\t * we store the value for the matching epoch and apply it in the `advance_epoch`\n\t\t * function.\n\t\t */\n\t\tpending_commission_rate: pending_values.PendingValues,\n\t\t/** The commission rate for the pool, in basis points. */\n\t\tcommission_rate: bcs.u16(),\n\t\t/**\n\t\t * Historical exchange rates for the pool. The key is the epoch when the exchange\n\t\t * rate was set, and the value is the exchange rate (the ratio of the amount of WAL\n\t\t * tokens for the pool shares).\n\t\t */\n\t\texchange_rates: table.Table,\n\t\t/**\n\t\t * The amount of stake that will be added to the `wal_balance`. Can hold up to two\n\t\t * keys: E+1 and E+2, due to the differences in the activation epoch.\n\t\t *\n\t\t * ```\n\t\t * E+1 -> Balance\n\t\t * E+2 -> Balance\n\t\t * ```\n\t\t *\n\t\t * Single key is cleared in the `advance_epoch` function, leaving only the next\n\t\t * epoch's stake.\n\t\t */\n\t\tpending_stake: pending_values.PendingValues,\n\t\t/** The rewards that the pool has received from being in the committee. */\n\t\trewards_pool: balance.Balance,\n\t\t/** The commission that the pool has received from the rewards. */\n\t\tcommission: balance.Balance,\n\t\t/** An Object or an address which can claim the commission. */\n\t\tcommission_receiver: auth.Authorized,\n\t\t/** An Object or address that can authorize governance actions, such as upgrades. */\n\t\tgovernance_authorized: auth.Authorized,\n\t\t/** Reserved for future use and migrations. */\n\t\textra_fields: bag.Bag,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: staking */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::staking';\nexport const Staking = new MoveStruct({\n\tname: `${$moduleName}::Staking`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface RegisterCandidateArguments {\n\tstaking: RawTransactionArgument<string>;\n\tname: RawTransactionArgument<string>;\n\tnetworkAddress: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n\tpublicKey: RawTransactionArgument<number[]>;\n\tnetworkPublicKey: RawTransactionArgument<number[]>;\n\tproofOfPossession: RawTransactionArgument<number[]>;\n\tcommissionRate: RawTransactionArgument<number>;\n\tstoragePrice: RawTransactionArgument<number | bigint>;\n\twritePrice: RawTransactionArgument<number | bigint>;\n\tnodeCapacity: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterCandidateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterCandidateArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tname: RawTransactionArgument<string>,\n\t\t\t\tnetworkAddress: RawTransactionArgument<string>,\n\t\t\t\tmetadata: RawTransactionArgument<string>,\n\t\t\t\tpublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tnetworkPublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tproofOfPossession: RawTransactionArgument<number[]>,\n\t\t\t\tcommissionRate: RawTransactionArgument<number>,\n\t\t\t\tstoragePrice: RawTransactionArgument<number | bigint>,\n\t\t\t\twritePrice: RawTransactionArgument<number | bigint>,\n\t\t\t\tnodeCapacity: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/**\n * Creates a staking pool for the candidate, registers the candidate as a storage\n * node.\n */\nexport function registerCandidate(options: RegisterCandidateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t`${packageAddress}::node_metadata::NodeMetadata`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'u16',\n\t\t'u64',\n\t\t'u64',\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'staking',\n\t\t'name',\n\t\t'networkAddress',\n\t\t'metadata',\n\t\t'publicKey',\n\t\t'networkPublicKey',\n\t\t'proofOfPossession',\n\t\t'commissionRate',\n\t\t'storagePrice',\n\t\t'writePrice',\n\t\t'nodeCapacity',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'register_candidate',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNextCommissionArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tcommissionRate: RawTransactionArgument<number>;\n}\nexport interface SetNextCommissionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNextCommissionArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tcommissionRate: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Sets next_commission in the staking pool, which will then take effect as\n * commission rate one epoch after setting the value (to allow stakers to react to\n * setting this).\n */\nexport function setNextCommission(options: SetNextCommissionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u16',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap', 'commissionRate'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_next_commission',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CollectCommissionArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n}\nexport interface CollectCommissionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CollectCommissionArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Collects the commission for the node. Transaction sender must be the\n * `CommissionReceiver` for the `StakingPool`.\n */\nexport function collectCommission(options: CollectCommissionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'collect_commission',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetCommissionReceiverArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\treceiver: RawTransactionArgument<string>;\n}\nexport interface SetCommissionReceiverOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetCommissionReceiverArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\treceiver: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the commission receiver for the node. */\nexport function setCommissionReceiver(options: SetCommissionReceiverOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t`${packageAddress}::auth::Authorized`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth', 'receiver'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_commission_receiver',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetGovernanceAuthorizedArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\tauthorized: RawTransactionArgument<string>;\n}\nexport interface SetGovernanceAuthorizedOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetGovernanceAuthorizedArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\tauthorized: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the governance authorized object for the pool. */\nexport function setGovernanceAuthorized(options: SetGovernanceAuthorizedOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t`${packageAddress}::auth::Authorized`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth', 'authorized'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_governance_authorized',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CommitteeArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface CommitteeOptions {\n\tpackage?: string;\n\targuments: CommitteeArguments | [staking: RawTransactionArgument<string>];\n}\n/** Get the current committee. */\nexport function committee(options: CommitteeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'committee',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ComputeNextCommitteeArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface ComputeNextCommitteeOptions {\n\tpackage?: string;\n\targuments: ComputeNextCommitteeArguments | [staking: RawTransactionArgument<string>];\n}\n/** Computes the committee for the next epoch. */\nexport function computeNextCommittee(options: ComputeNextCommitteeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'compute_next_committee',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetStoragePriceVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tstoragePrice: RawTransactionArgument<number | bigint>;\n}\nexport interface SetStoragePriceVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetStoragePriceVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tstoragePrice: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the storage price vote for the pool. */\nexport function setStoragePriceVote(options: SetStoragePriceVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'storagePrice'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_storage_price_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetWritePriceVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\twritePrice: RawTransactionArgument<number | bigint>;\n}\nexport interface SetWritePriceVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetWritePriceVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\twritePrice: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the write price vote for the pool. */\nexport function setWritePriceVote(options: SetWritePriceVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'writePrice'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_write_price_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNodeCapacityVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnodeCapacity: RawTransactionArgument<number | bigint>;\n}\nexport interface SetNodeCapacityVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNodeCapacityVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnodeCapacity: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the node capacity vote for the pool. */\nexport function setNodeCapacityVote(options: SetNodeCapacityVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'nodeCapacity'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_node_capacity_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NodeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface NodeMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| NodeMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, nodeId: RawTransactionArgument<string>];\n}\n/** Get `NodeMetadata` for the given node. */\nexport function nodeMetadata(options: NodeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'node_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNextPublicKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tpublicKey: RawTransactionArgument<number[]>;\n\tproofOfPossession: RawTransactionArgument<number[]>;\n}\nexport interface SetNextPublicKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNextPublicKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tpublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tproofOfPossession: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Sets the public key of a node to be used starting from the next epoch for which\n * the node is selected.\n */\nexport function setNextPublicKey(options: SetNextPublicKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'publicKey', 'proofOfPossession'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_next_public_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNameArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tname: RawTransactionArgument<string>;\n}\nexport interface SetNameOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNameArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tname: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the name of a storage node. */\nexport function setName(options: SetNameOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'name'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_name',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNetworkAddressArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnetworkAddress: RawTransactionArgument<string>;\n}\nexport interface SetNetworkAddressOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNetworkAddressArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnetworkAddress: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the network address or host of a storage node. */\nexport function setNetworkAddress(options: SetNetworkAddressOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'networkAddress'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_network_address',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNetworkPublicKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnetworkPublicKey: RawTransactionArgument<number[]>;\n}\nexport interface SetNetworkPublicKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNetworkPublicKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnetworkPublicKey: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Sets the public key used for TLS communication for a node. */\nexport function setNetworkPublicKey(options: SetNetworkPublicKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'networkPublicKey'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_network_public_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNodeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface SetNodeMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNodeMetadataArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tmetadata: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the metadata of a storage node. */\nexport function setNodeMetadata(options: SetNodeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t`${packageAddress}::node_metadata::NodeMetadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_node_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VotingEndArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface VotingEndOptions {\n\tpackage?: string;\n\targuments: VotingEndArguments | [staking: RawTransactionArgument<string>];\n}\n/**\n * Ends the voting period and runs the apportionment if the current time allows.\n *\n * This function is permissionless and can be called by anyone. Emits the\n * `EpochParametersSelected` event.\n */\nexport function votingEnd(options: VotingEndOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'voting_end',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InitiateEpochChangeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface InitiateEpochChangeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InitiateEpochChangeArguments\n\t\t| [staking: RawTransactionArgument<string>, system: RawTransactionArgument<string>];\n}\n/**\n * Initiates the epoch change if the current time allows.\n *\n * Emits the `EpochChangeStart` event.\n */\nexport function initiateEpochChange(options: InitiateEpochChangeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::system::System`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'system'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'initiate_epoch_change',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochSyncDoneArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface EpochSyncDoneOptions {\n\tpackage?: string;\n\targuments:\n\t\t| EpochSyncDoneArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Signals to the contract that the node has received all its shards for the new\n * epoch.\n */\nexport function epochSyncDone(options: EpochSyncDoneOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u32',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap', 'epoch'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'epoch_sync_done',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface StakeWithPoolArguments {\n\tstaking: RawTransactionArgument<string>;\n\ttoStake: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface StakeWithPoolOptions {\n\tpackage?: string;\n\targuments:\n\t\t| StakeWithPoolArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\ttoStake: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Stake `Coin` with the staking pool. */\nexport function stakeWithPool(options: StakeWithPoolOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'toStake', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'stake_with_pool',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RequestWithdrawStakeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface RequestWithdrawStakeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RequestWithdrawStakeArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/**\n * Marks the amount as a withdrawal to be processed and removes it from the stake\n * weight of the node.\n *\n * Allows the user to call `withdraw_stake` after the epoch change to the next\n * epoch and shard transfer is done.\n */\nexport function requestWithdrawStake(options: RequestWithdrawStakeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'request_withdraw_stake',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface WithdrawStakeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface WithdrawStakeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| WithdrawStakeArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/** Withdraws the staked amount from the staking pool. */\nexport function withdrawStake(options: WithdrawStakeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'withdraw_stake',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TryJoinActiveSetArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n}\nexport interface TryJoinActiveSetOptions {\n\tpackage?: string;\n\targuments:\n\t\t| TryJoinActiveSetArguments\n\t\t| [staking: RawTransactionArgument<string>, cap: RawTransactionArgument<string>];\n}\n/**\n * Allows a node to join the active set if it has sufficient stake.\n *\n * This can be useful if another node in the active set had its stake reduced below\n * that of the current node. In that case, the current node will be added to the\n * active set either the next time stake is added or by calling this function.\n */\nexport function tryJoinActiveSet(options: TryJoinActiveSetOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'try_join_active_set',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddCommissionToPoolsArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeIds: RawTransactionArgument<string[]>;\n\tcommissions: RawTransactionArgument<string[]>;\n}\nexport interface AddCommissionToPoolsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddCommissionToPoolsArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeIds: RawTransactionArgument<string[]>,\n\t\t\t\tcommissions: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/** Adds `commissions[i]` to the commission of pool `node_ids[i]`. */\nexport function addCommissionToPools(options: AddCommissionToPoolsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'vector<0x0000000000000000000000000000000000000000000000000000000000000002::object::ID>',\n\t\t`vector<0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>>`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeIds', 'commissions'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'add_commission_to_pools',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [staking: RawTransactionArgument<string>];\n}\n/** Returns the current epoch of the staking object. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CalculateRewardsArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tstakedPrincipal: RawTransactionArgument<number | bigint>;\n\tactivationEpoch: RawTransactionArgument<number>;\n\twithdrawEpoch: RawTransactionArgument<number>;\n}\nexport interface CalculateRewardsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CalculateRewardsArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tstakedPrincipal: RawTransactionArgument<number | bigint>,\n\t\t\t\tactivationEpoch: RawTransactionArgument<number>,\n\t\t\t\twithdrawEpoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Calculates the rewards for an amount with value `staked_principal`, staked in\n * the pool with the given `node_id` between `activation_epoch` and\n * `withdraw_epoch`.\n *\n * This function can be used with `dev_inspect` to calculate the expected rewards\n * for a `StakedWal` object or, more generally, the returns provided by a given\n * node over a given period.\n */\nexport function calculateRewards(options: CalculateRewardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t'u64',\n\t\t'u32',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'staking',\n\t\t'nodeId',\n\t\t'stakedPrincipal',\n\t\t'activationEpoch',\n\t\t'withdrawEpoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'calculate_rewards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CanWithdrawStakedWalEarlyArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface CanWithdrawStakedWalEarlyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CanWithdrawStakedWalEarlyArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/**\n * Call `staked_wal::can_withdraw_early` to allow calling this method in\n * applications.\n */\nexport function canWithdrawStakedWalEarly(options: CanWithdrawStakedWalEarlyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'can_withdraw_staked_wal_early',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetMigrationEpochArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface SetMigrationEpochOptions {\n\tpackage?: string;\n\targuments: SetMigrationEpochArguments | [staking: RawTransactionArgument<string>];\n}\n/**\n * Sets the epoch in which the staking and system objects can be migrated after an\n * upgrade.\n */\nexport function setMigrationEpoch(options: SetMigrationEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_migration_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, MoveEnum } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as group_ops from './deps/sui/group_ops.js';\nconst $moduleName = '@local-pkg/walrus::bls_aggregate';\nexport const BlsCommitteeMember = new MoveStruct({\n\tname: `${$moduleName}::BlsCommitteeMember`,\n\tfields: {\n\t\tpublic_key: group_ops.Element,\n\t\tweight: bcs.u16(),\n\t\tnode_id: bcs.Address,\n\t},\n});\nexport const BlsCommittee = new MoveStruct({\n\tname: `${$moduleName}::BlsCommittee`,\n\tfields: {\n\t\t/** A vector of committee members */\n\t\tmembers: bcs.vector(BlsCommitteeMember),\n\t\t/** The total number of shards held by the committee */\n\t\tn_shards: bcs.u16(),\n\t\t/** The epoch in which the committee is active. */\n\t\tepoch: bcs.u32(),\n\t\t/** The aggregation of public keys for all members of the committee */\n\t\ttotal_aggregated_key: group_ops.Element,\n\t},\n});\n/** The type of weight verification to perform. */\nexport const RequiredWeight = new MoveEnum({\n\tname: `${$moduleName}::RequiredWeight`,\n\tfields: {\n\t\t/** Verify that the signers form a quorum. */\n\t\tQuorum: null,\n\t\t/** Verify that the signers include at least one correct node. */\n\t\tOneCorrectNode: null,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as balance from './deps/sui/balance.js';\nconst $moduleName = '@local-pkg/walrus::storage_accounting';\nexport const FutureAccounting = new MoveStruct({\n\tname: `${$moduleName}::FutureAccounting`,\n\tfields: {\n\t\tepoch: bcs.u32(),\n\t\t/**\n\t\t * This field stores `used_capacity` for the epoch. Currently, impossible to rename\n\t\t * due to package upgrade limitations.\n\t\t */\n\t\tused_capacity: bcs.u64(),\n\t\trewards_to_distribute: balance.Balance,\n\t},\n});\nexport const FutureAccountingRingBuffer = new MoveStruct({\n\tname: `${$moduleName}::FutureAccountingRingBuffer`,\n\tfields: {\n\t\tcurrent_index: bcs.u32(),\n\t\tlength: bcs.u32(),\n\t\tring_buffer: bcs.vector(FutureAccounting),\n\t},\n});\nexport interface MaxEpochsAheadArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface MaxEpochsAheadOptions {\n\tpackage?: string;\n\targuments: MaxEpochsAheadArguments | [self: RawTransactionArgument<string>];\n}\n/** The maximum number of epochs for which we can use `self`. */\nexport function maxEpochsAhead(options: MaxEpochsAheadOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccountingRingBuffer`,\n\t] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'max_epochs_ahead',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RingLookupArguments {\n\tself: RawTransactionArgument<string>;\n\tepochsInFuture: RawTransactionArgument<number>;\n}\nexport interface RingLookupOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RingLookupArguments\n\t\t| [self: RawTransactionArgument<string>, epochsInFuture: RawTransactionArgument<number>];\n}\n/** Read-only lookup for an element in the `FutureAccountingRingBuffer` */\nexport function ringLookup(options: RingLookupOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccountingRingBuffer`,\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'epochsInFuture'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'ring_lookup',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\taccounting: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [accounting: RawTransactionArgument<string>];\n}\n/** Accessor for epoch, read-only. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccounting`,\n\t] satisfies string[];\n\tconst parameterNames = ['accounting'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UsedCapacityArguments {\n\taccounting: RawTransactionArgument<string>;\n}\nexport interface UsedCapacityOptions {\n\tpackage?: string;\n\targuments: UsedCapacityArguments | [accounting: RawTransactionArgument<string>];\n}\n/** Accessor for used_capacity, read-only. */\nexport function usedCapacity(options: UsedCapacityOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccounting`,\n\t] satisfies string[];\n\tconst parameterNames = ['accounting'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'used_capacity',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RewardsArguments {\n\taccounting: RawTransactionArgument<string>;\n}\nexport interface RewardsOptions {\n\tpackage?: string;\n\targuments: RewardsArguments | [accounting: RawTransactionArgument<string>];\n}\n/** Accessor for rewards, read-only. */\nexport function rewards(options: RewardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccounting`,\n\t] satisfies string[];\n\tconst parameterNames = ['accounting'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'rewards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as bls_aggregate from './bls_aggregate.js';\nimport * as storage_accounting from './storage_accounting.js';\nimport * as event_blob from './event_blob.js';\nimport * as extended_field from './extended_field.js';\nconst $moduleName = '@local-pkg/walrus::system_state_inner';\nexport const SystemStateInnerV1 = new MoveStruct({\n\tname: `${$moduleName}::SystemStateInnerV1`,\n\tfields: {\n\t\t/** The current committee, with the current epoch. */\n\t\tcommittee: bls_aggregate.BlsCommittee,\n\t\t/**\n\t\t * Maximum capacity size for the current and future epochs. Changed by voting on\n\t\t * the epoch parameters.\n\t\t */\n\t\ttotal_capacity_size: bcs.u64(),\n\t\t/** Contains the used capacity size for the current epoch. */\n\t\tused_capacity_size: bcs.u64(),\n\t\t/** The price per unit size of storage. */\n\t\tstorage_price_per_unit_size: bcs.u64(),\n\t\t/** The write price per unit size. */\n\t\twrite_price_per_unit_size: bcs.u64(),\n\t\t/** Accounting ring buffer for future epochs. */\n\t\tfuture_accounting: storage_accounting.FutureAccountingRingBuffer,\n\t\t/** Event blob certification state */\n\t\tevent_blob_certification_state: event_blob.EventBlobCertificationState,\n\t\t/**\n\t\t * Sizes of deny lists for storage nodes. Only current committee members can\n\t\t * register their updates in this map. Hence, we don't expect it to bloat.\n\t\t *\n\t\t * Max number of stored entries is ~6500. If there's any concern about the\n\t\t * performance of the map, it can be cleaned up as a side effect of the updates /\n\t\t * registrations.\n\t\t */\n\t\tdeny_list_sizes: extended_field.ExtendedField,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: system */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::system';\nexport const System = new MoveStruct({\n\tname: `${$moduleName}::System`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface InvalidateBlobIdArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface InvalidateBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InvalidateBlobIdArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * === Public Functions === Marks blob as invalid given an invalid blob\n * certificate.\n */\nexport function invalidateBlobId(options: InvalidateBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'invalidate_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyEventBlobArguments {\n\tsystem: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface CertifyEventBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyEventBlobArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/** Certifies a blob containing Walrus events. */\nexport function certifyEventBlob(options: CertifyEventBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u256',\n\t\t'u256',\n\t\t'u64',\n\t\t'u8',\n\t\t'u64',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'system',\n\t\t'cap',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'endingCheckpointSequenceNum',\n\t\t'epoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_event_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tepochsAhead: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Allows buying a storage reservation for a given period of epochs. */\nexport function reserveSpace(options: ReserveSpaceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'u64',\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'storageAmount', 'epochsAhead', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceForEpochsArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tstartEpoch: RawTransactionArgument<number>;\n\tendEpoch: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceForEpochsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceForEpochsArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tstartEpoch: RawTransactionArgument<number>,\n\t\t\t\tendEpoch: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Allows buying a storage reservation for a given period of epochs.\n *\n * Returns a storage resource for the period between `start_epoch` (inclusive) and\n * `end_epoch` (exclusive). If `start_epoch` has already passed, reserves space\n * starting from the current epoch.\n */\nexport function reserveSpaceForEpochs(options: ReserveSpaceForEpochsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'u64',\n\t\t'u32',\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'storageAmount', 'startEpoch', 'endEpoch', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space_for_epochs',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tstorage: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tdeletable: RawTransactionArgument<boolean>;\n\twritePayment: RawTransactionArgument<string>;\n}\nexport interface RegisterBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorage: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tdeletable: RawTransactionArgument<boolean>,\n\t\t\t\twritePayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Registers a new blob in the system. `size` is the size of the unencoded blob.\n * The reserved space in `storage` must be at least the size of the encoded blob.\n */\nexport function registerBlob(options: RegisterBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t'u256',\n\t\t'u256',\n\t\t'u64',\n\t\t'u8',\n\t\t'bool',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'self',\n\t\t'storage',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'deletable',\n\t\t'writePayment',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tsignersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface CertifyBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tsignersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Certify that a blob will be available in the storage system until the end epoch\n * of the storage associated with it.\n */\nexport function certifyBlob(options: CertifyBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'signature', 'signersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n}\nexport interface DeleteBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteBlobArguments\n\t\t| [self: RawTransactionArgument<string>, blob: RawTransactionArgument<string>];\n}\n/** Deletes a deletable blob and returns the contained storage resource. */\nexport function deleteBlob(options: DeleteBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobWithResourceArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textension: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobWithResourceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobWithResourceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textension: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob with a new storage resource. The new\n * storage resource must be the same size as the storage resource used in the blob,\n * and have a longer period of validity.\n */\nexport function extendBlobWithResource(options: ExtendBlobWithResourceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'extension'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob_with_resource',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textendedEpochs: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textendedEpochs: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob by extending its contained storage\n * resource by `extended_epochs` epochs.\n */\nexport function extendBlob(options: ExtendBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'extendedEpochs', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddSubsidyArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidy: RawTransactionArgument<string>;\n\tepochsAhead: RawTransactionArgument<number>;\n}\nexport interface AddSubsidyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddSubsidyArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsubsidy: RawTransactionArgument<string>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Adds rewards to the system for the specified number of epochs ahead. The rewards\n * are split equally across the future accounting ring buffer up to the specified\n * epoch.\n */\nexport function addSubsidy(options: AddSubsidyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'subsidy', 'epochsAhead'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_subsidy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddPerEpochSubsidiesArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidies: RawTransactionArgument<string[]>;\n}\nexport interface AddPerEpochSubsidiesOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddPerEpochSubsidiesArguments\n\t\t| [system: RawTransactionArgument<string>, subsidies: RawTransactionArgument<string[]>];\n}\n/**\n * Adds rewards to the system for future epochs, where `subsidies[i]` is added to\n * the rewards of epoch `system.epoch() + i`.\n */\nexport function addPerEpochSubsidies(options: AddPerEpochSubsidiesOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`vector<0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>>`,\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'subsidies'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_per_epoch_subsidies',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateProtocolVersionArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateProtocolVersionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateProtocolVersionArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Node collects signatures on the protocol version event and emits it. */\nexport function updateProtocolVersion(options: UpdateProtocolVersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_protocol_version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterDenyListUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tdenyListRoot: RawTransactionArgument<number | bigint>;\n\tdenyListSequence: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterDenyListUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterDenyListUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tdenyListRoot: RawTransactionArgument<number | bigint>,\n\t\t\t\tdenyListSequence: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Register a deny list update. */\nexport function registerDenyListUpdate(options: RegisterDenyListUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u256',\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'denyListRoot', 'denyListSequence'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_deny_list_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateDenyListArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateDenyListOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateDenyListArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Perform the update of the deny list. */\nexport function updateDenyList(options: UpdateDenyListOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_deny_list',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteDenyListedBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface DeleteDenyListedBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteDenyListedBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Delete a blob that is deny listed by f+1 members. */\nexport function deleteDenyListedBlob(options: DeleteDenyListedBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_deny_listed_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [self: RawTransactionArgument<string>];\n}\n/** Get epoch. Uses the committee to get the epoch. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TotalCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TotalCapacitySizeOptions {\n\tpackage?: string;\n\targuments: TotalCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for total capacity size. */\nexport function totalCapacitySize(options: TotalCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'total_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UsedCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface UsedCapacitySizeOptions {\n\tpackage?: string;\n\targuments: UsedCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for used capacity size. */\nexport function usedCapacitySize(options: UsedCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'used_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NShardsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface NShardsOptions {\n\tpackage?: string;\n\targuments: NShardsArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for the number of shards. */\nexport function nShards(options: NShardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'n_shards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FutureAccountingArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface FutureAccountingOptions {\n\tpackage?: string;\n\targuments: FutureAccountingArguments | [self: RawTransactionArgument<string>];\n}\n/** Read-only access to the accounting ring buffer. */\nexport function futureAccounting(options: FutureAccountingOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'future_accounting',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VersionArguments {\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface VersionOptions {\n\tpackage?: string;\n\targuments: VersionArguments | [system: RawTransactionArgument<string>];\n}\nexport function version(options: VersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['system'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class WalrusClientError extends Error {}\n\nexport class RetryableWalrusClientError extends WalrusClientError {}\n\n/** Thrown when the client could not retrieve the status of a blob from any storage node. */\nexport class NoBlobStatusReceivedError extends WalrusClientError {}\n\n/** Thrown when the client could not retrieve a verified blob status for the blob. */\nexport class NoVerifiedBlobStatusReceivedError extends WalrusClientError {}\n\n/** Thrown when the client could not retrieve blob metadata from any storage node. */\nexport class NoBlobMetadataReceivedError extends RetryableWalrusClientError {}\n\n/** Thrown when the client could not retrieve enough slivers to reconstruct the blob. */\nexport class NotEnoughSliversReceivedError extends RetryableWalrusClientError {}\n\n/** Thrown when the client could not write enough slivers to upload the blob. */\nexport class NotEnoughBlobConfirmationsError extends RetryableWalrusClientError {}\n\n/** Thrown when the client is currently behind the current epoch. */\nexport class BehindCurrentEpochError extends RetryableWalrusClientError {}\n\n/** Thrown when a blob is not certified or determined to not exist. */\nexport class BlobNotCertifiedError extends RetryableWalrusClientError {}\n\n/** Thrown when a blob was determined to be incorrectly encoded. */\nexport class InconsistentBlobError extends WalrusClientError {}\n\n/** Thrown when blob is blocked by a quorum of storage nodes. */\nexport class BlobBlockedError extends Error {}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { bcs } from '@mysten/sui/bcs';\n\nconst MerkleNode = bcs.enum('MerkleNode', {\n\tEmpty: null,\n\tDigest: bcs.bytes(32),\n});\n\nconst SliverPairMetadata = bcs.struct('SliverPairMetadata', {\n\tprimary_hash: MerkleNode,\n\tsecondary_hash: MerkleNode,\n});\n\nexport const EncodingType = bcs\n\t.enum('EncodingType', {\n\t\tRedStuff: null,\n\t\tRS2: null,\n\t})\n\t.transform({\n\t\tinput: (\n\t\t\tencodingType:\n\t\t\t\t| { RedStuff: boolean | object | null }\n\t\t\t\t| { RS2: boolean | object | null }\n\t\t\t\t| 'RedStuff'\n\t\t\t\t| 'RS2',\n\t\t) =>\n\t\t\ttypeof encodingType === 'string'\n\t\t\t\t? ({ [encodingType]: null } as Exclude<typeof encodingType, string>)\n\t\t\t\t: encodingType,\n\t\toutput: (encodingType) => encodingType,\n\t});\n\nexport const BlobMetadataV1 = bcs.struct('BlobMetadataV1', {\n\tencoding_type: EncodingType,\n\tunencoded_length: bcs.u64(),\n\thashes: bcs.vector(SliverPairMetadata),\n});\n\nexport const BlobMetadata = bcs.enum('BlobMetadata', {\n\tV1: BlobMetadataV1,\n});\n\nexport const BlobId = bcs.u256().transform({\n\tinput: (blobId: string | bigint) => (typeof blobId === 'string' ? blobIdToInt(blobId) : blobId),\n\toutput: (id: string) => blobIdFromInt(id),\n});\n\nexport function blobIdFromInt(blobId: bigint | string): string {\n\treturn bcs\n\t\t.u256()\n\t\t.serialize(blobId)\n\t\t.toBase64()\n\t\t.replace(/=*$/, '')\n\t\t.replaceAll('+', '-')\n\t\t.replaceAll('/', '_');\n}\n\nexport function blobIdFromBytes(blobId: Uint8Array): string {\n\treturn blobIdFromInt(bcs.u256().parse(blobId));\n}\n\nexport function blobIdToInt(blobId: string): bigint {\n\treturn BigInt(bcs.u256().fromBase64(blobId.replaceAll('-', '+').replaceAll('_', '/')));\n}\n\nexport const BlobMetadataWithId = bcs.struct('BlobMetadataWithId', {\n\tblobId: BlobId,\n\tmetadata: BlobMetadata,\n});\n\nconst Symbols = bcs.struct('Symbols', {\n\tdata: bcs.byteVector(),\n\tsymbol_size: bcs.u16(),\n});\n\nexport const SliverData = bcs.struct('SliverData', {\n\tsymbols: Symbols,\n\tindex: bcs.u16(),\n});\n\nexport const Sliver = bcs.enum('Sliver', {\n\tPrimary: SliverData,\n\tSecondary: SliverData,\n});\n\nexport const SliverPair = bcs.struct('SliverPair', {\n\tprimary: SliverData,\n\tsecondary: SliverData,\n});\n\nexport enum IntentType {\n\tPROOF_OF_POSSESSION_MSG = 0,\n\tBLOB_CERT_MSG = 1,\n\tINVALID_BLOB_ID_MSG = 2,\n\tSYNC_SHARD_MSG = 3,\n}\n\nexport const Intent = bcs\n\t.struct('Intent', {\n\t\ttype: bcs.u8().transform({\n\t\t\tinput: (type: IntentType) => type,\n\t\t\toutput: (type: number) => type as IntentType,\n\t\t}),\n\t\tversion: bcs.u8(),\n\t\tappId: bcs.u8(),\n\t})\n\t.transform({\n\t\tinput: (intent: IntentType) => ({\n\t\t\ttype: intent,\n\t\t\tversion: 0,\n\t\t\tappId: 3,\n\t\t}),\n\t\toutput: (intent) => intent.type,\n\t});\n\nexport function ProtocolMessage<T extends BcsType<any>>(messageContents: T) {\n\treturn bcs.struct(`ProtocolMessage<${messageContents.name}>`, {\n\t\tintent: Intent,\n\t\tepoch: bcs.u32(),\n\t\tmessageContents,\n\t});\n}\n\nexport const BlobPersistenceType = bcs.enum('BlobPersistenceType', {\n\tPermanent: null,\n\tDeletable: bcs.struct('Deletable', {\n\t\tobjectId: bcs.Address,\n\t}),\n});\nexport const StorageConfirmationBody = bcs.struct('StorageConfirmationBody', {\n\tblobId: BlobId,\n\tblobType: BlobPersistenceType,\n});\n\nexport const StorageConfirmation = ProtocolMessage(StorageConfirmationBody);\n\nexport function Field<T0 extends BcsType<any>, T1 extends BcsType<any>>(\n\t...typeParameters: [T0, T1]\n) {\n\treturn bcs.struct('Field', {\n\t\tid: bcs.Address,\n\t\tname: typeParameters[0],\n\t\tvalue: typeParameters[1],\n\t});\n}\n\nexport const QuiltPatchTags = bcs.map(bcs.string(), bcs.string()).transform({\n\t// tags is a BTreeMap, so we need to sort entries before serializing\n\tinput: (tags: Record<string, string> | Map<string, string>) =>\n\t\tnew Map(\n\t\t\t[...(tags instanceof Map ? tags : Object.entries(tags))].sort(([a], [b]) =>\n\t\t\t\t// TODO: sorting for map keys should be moved into @mysten/bcs\n\t\t\t\tcompareBcsBytes(bcs.string().serialize(a).toBytes(), bcs.string().serialize(b).toBytes()),\n\t\t\t),\n\t\t),\n\toutput: (tags: Map<string, string>) => Object.fromEntries(tags),\n});\n\nexport const QuiltPatchV1 = bcs.struct('QuiltPatchV1', {\n\tendIndex: bcs.u16(),\n\tidentifier: bcs.string(),\n\ttags: QuiltPatchTags,\n});\n\nfunction compareBcsBytes(a: Uint8Array, b: Uint8Array) {\n\t// sort by length first, because bcs bytes prefix length\n\tif (a.length !== b.length) {\n\t\treturn a.length - b.length;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn a[i] - b[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nexport const QuiltIndexV1 = bcs.struct('QuiltIndexV1', {\n\tpatches: bcs.vector(QuiltPatchV1),\n});\n\nexport const QuiltPatchId = bcs.struct('QuiltPatchId', {\n\tquiltId: BlobId,\n\tpatchId: bcs.struct('InternalQuiltPatchId', {\n\t\tversion: bcs.u8(),\n\t\tstartIndex: bcs.u16(),\n\t\tendIndex: bcs.u16(),\n\t}),\n});\n\nexport const QuiltPatchBlobHeader = bcs.struct('QuiltPatchBlobHeader', {\n\tversion: bcs.u8(),\n\tlength: bcs.u32(),\n\tmask: bcs.u8(),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class StorageNodeError extends Error {}\n\nexport class StorageNodeAPIError<\n\tTStatus extends number | undefined = number | undefined,\n\tTError extends object | undefined = object | undefined,\n> extends StorageNodeError {\n\t/** HTTP status for the response that caused the error. */\n\treadonly status: TStatus;\n\n\t/** JSON body of the response that caused the error. */\n\treadonly error: TError;\n\n\tconstructor(status: TStatus, error: TError, message: string | undefined) {\n\t\tsuper(StorageNodeAPIError.#makeMessage(status, error, message));\n\t\tthis.status = status;\n\t\tthis.error = error;\n\t}\n\n\tstatic #makeMessage(status: number | undefined, error: unknown, message: string | undefined) {\n\t\tfunction hasErrorMessage(error: any): error is { error: { message: string } } {\n\t\t\treturn typeof error?.error?.message === 'string';\n\t\t}\n\n\t\tconst inferredMessage = hasErrorMessage(error) ? error.error.message : message;\n\t\tconst finalMessage = inferredMessage ? inferredMessage : JSON.stringify(error);\n\n\t\tif (status && finalMessage) {\n\t\t\treturn `${status} ${finalMessage}`;\n\t\t} else if (finalMessage) {\n\t\t\treturn finalMessage;\n\t\t} else if (status) {\n\t\t\treturn `${status} status code (no body)`;\n\t\t}\n\t\treturn '(no status code or body)';\n\t}\n\n\tstatic generate(\n\t\tstatus: number | undefined,\n\t\terrorResponse: object | undefined,\n\t\tmessage: string | undefined,\n\t): StorageNodeAPIError {\n\t\tif (!status) {\n\t\t\treturn new ConnectionError({ message });\n\t\t}\n\n\t\tif (status === 400) {\n\t\t\treturn BadRequestError.generate(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 401) {\n\t\t\treturn new AuthenticationError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 403) {\n\t\t\treturn new PermissionDeniedError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 404) {\n\t\t\treturn new NotFoundError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 409) {\n\t\t\treturn new ConflictError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 422) {\n\t\t\treturn new UnprocessableEntityError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 429) {\n\t\t\treturn new RateLimitError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 451) {\n\t\t\treturn new LegallyUnavailableError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status >= 500) {\n\t\t\treturn new InternalServerError(status, errorResponse, message);\n\t\t}\n\n\t\treturn new StorageNodeAPIError(status, errorResponse, message);\n\t}\n}\n\nexport class UserAbortError extends StorageNodeAPIError<undefined, undefined> {\n\tconstructor({ message }: { message?: string } = {}) {\n\t\tsuper(undefined, undefined, message || 'Request was aborted.');\n\t}\n}\n\nexport class ConnectionError extends StorageNodeAPIError<undefined, undefined> {\n\tconstructor({ message }: { message?: string | undefined }) {\n\t\tsuper(undefined, undefined, message || 'Connection error.');\n\t}\n}\n\nexport class ConnectionTimeoutError extends StorageNodeAPIError<undefined, undefined> {\n\tconstructor({ message }: { message?: string } = {}) {\n\t\tsuper(undefined, undefined, message ?? 'Request timed out.');\n\t}\n}\n\nexport class BadRequestError extends StorageNodeAPIError<400> {\n\tstatic generate(\n\t\tstatus: 400,\n\t\terrorResponse: object | undefined,\n\t\tmessage: string | undefined,\n\t): StorageNodeAPIError {\n\t\tif (errorResponse && typeof errorResponse === 'object' && 'error' in errorResponse) {\n\t\t\tconst error = errorResponse.error as {\n\t\t\t\tdetails?: [\n\t\t\t\t\t{\n\t\t\t\t\t\treason?: string;\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t};\n\t\t\tif (error.details?.[0]?.reason === 'NOT_REGISTERED') {\n\t\t\t\treturn new BlobNotRegisteredError(errorResponse, message);\n\t\t\t}\n\t\t}\n\n\t\treturn new BadRequestError(status, errorResponse, message);\n\t}\n}\n\nexport class BlobNotRegisteredError extends StorageNodeAPIError<400> {\n\tconstructor(error: object | undefined, message: string | undefined) {\n\t\tsuper(400, error, message);\n\t}\n}\n\nexport class AuthenticationError extends StorageNodeAPIError<401> {}\n\nexport class PermissionDeniedError extends StorageNodeAPIError<403> {}\n\nexport class NotFoundError extends StorageNodeAPIError<404> {}\n\nexport class ConflictError extends StorageNodeAPIError<409> {}\n\nexport class UnprocessableEntityError extends StorageNodeAPIError<422> {}\n\nexport class RateLimitError extends StorageNodeAPIError<429> {}\n\nexport class LegallyUnavailableError extends StorageNodeAPIError<451> {}\n\nexport class InternalServerError extends StorageNodeAPIError<number> {}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport type HeadersLike = Record<string, string | string[] | undefined> | RequestInit['headers'];\n\nexport function mergeHeaders(...headers: (HeadersLike | undefined)[]): Headers {\n\tconst mergedHeaders = new Headers();\n\n\tfor (const header of headers) {\n\t\tif (!header || typeof header !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const [key, value] of Object.entries(header)) {\n\t\t\tif (value === null) {\n\t\t\t\tmergedHeaders.delete(key);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tfor (const v of value) {\n\t\t\t\t\tmergedHeaders.append(key, v as string);\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n\t\t\t\tmergedHeaders.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mergedHeaders;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BlobMetadata, BlobMetadataWithId, SliverData } from '../utils/bcs.js';\nimport {\n\tConnectionTimeoutError,\n\tStorageNodeAPIError,\n\tStorageNodeError,\n\tUserAbortError,\n} from './error.js';\nimport type {\n\tGetBlobMetadataRequestInput,\n\tGetBlobMetadataResponse,\n\tGetBlobStatusRequestInput,\n\tGetBlobStatusResponse,\n\tGetDeletableBlobConfirmationRequestInput,\n\tGetDeletableBlobConfirmationResponse,\n\tGetPermanentBlobConfirmationRequestInput,\n\tGetPermanentBlobConfirmationResponse,\n\tGetSliverRequestInput,\n\tGetSliverResponse,\n\tRawGetBlobStatusResponse,\n\tStoreBlobMetadataRequestInput,\n\tStoreBlobMetadataResponse,\n\tStoreSliverRequestInput,\n\tStoreSliverResponse,\n} from './types.js';\nimport { mergeHeaders } from './utils.js';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\nexport type StorageNodeClientOptions = {\n\t/**\n\t * An optional custom fetch function.\n\t *\n\t * If not provided, defaults to the global `fetch` function (`globalThis.fetch`).\n\t *\n\t * @default globalThis.fetch\n\t */\n\tfetch?: Fetch;\n\n\t/**\n\t * An optional timeout for requests.\n\t * @default 30_000ms (30 seconds)\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Callback for individual network errors.\n\t */\n\tonError?: (error: Error) => void;\n};\n\nexport type RequestOptions = {\n\tnodeUrl: string;\n\ttimeout?: number;\n\theaders?: ReturnType<typeof mergeHeaders>;\n} & Omit<RequestInit, 'headers'>;\n\nexport class StorageNodeClient {\n\t#fetch: Fetch;\n\t#timeout: number;\n\t#onError?: (error: Error) => void;\n\tconstructor({ fetch: overriddenFetch, timeout, onError }: StorageNodeClientOptions = {}) {\n\t\tthis.#fetch = overriddenFetch ?? globalThis.fetch;\n\t\tthis.#timeout = timeout ?? 30_000;\n\t\tthis.#onError = onError;\n\t}\n\n\t/**\n\t * Gets the metadata associated with a Walrus blob.\n\t */\n\tasync getBlobMetadata(\n\t\t{ blobId }: GetBlobMetadataRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetBlobMetadataResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/metadata`, {\n\t\t\t...options,\n\t\t\theaders: mergeHeaders({ Accept: 'application/octet-stream' }, options.headers),\n\t\t});\n\n\t\tconst bcsBytes = await response.arrayBuffer();\n\t\treturn BlobMetadataWithId.parse(new Uint8Array(bcsBytes));\n\t}\n\n\t/**\n\t * Gets the status associated with a Walrus blob.\n\t */\n\tasync getBlobStatus(\n\t\t{ blobId }: GetBlobStatusRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetBlobStatusResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/status`, options);\n\n\t\tconst json: RawGetBlobStatusResponse = await response.json();\n\t\tconst blobStatus = json.success.data;\n\n\t\tif (blobStatus === 'nonexistent') {\n\t\t\treturn { type: 'nonexistent' };\n\t\t}\n\n\t\tif ('invalid' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'invalid',\n\t\t\t\t...blobStatus.invalid,\n\t\t\t};\n\t\t}\n\n\t\tif ('permanent' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'permanent',\n\t\t\t\t...blobStatus.permanent,\n\t\t\t};\n\t\t}\n\n\t\tif ('deletable' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'deletable',\n\t\t\t\t...blobStatus.deletable,\n\t\t\t};\n\t\t}\n\n\t\tthrow new StorageNodeError(`Unknown blob status received: ${blobStatus}`);\n\t}\n\n\t/**\n\t * Stores the metadata associated with a registered Walrus blob at this storage\n\t * node. This is a pre-requisite for storing the encoded slivers of the blob. The\n\t * ID of the blob must first be registered on Sui, after which storing the metadata\n\t * becomes possible.\n\t *\n\t * This endpoint may return an error if the node has not yet received the\n\t * registration event from the chain.\n\t */\n\tasync storeBlobMetadata(\n\t\t{ blobId, metadata }: StoreBlobMetadataRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<StoreBlobMetadataResponse> {\n\t\tconst isBcsInput = typeof metadata === 'object' && 'V1' in metadata;\n\t\tconst body = isBcsInput ? BlobMetadata.serialize(metadata).toBytes() : metadata;\n\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/metadata`, {\n\t\t\t...options,\n\t\t\tmethod: 'PUT',\n\t\t\tbody: body as Uint8Array<ArrayBuffer>,\n\t\t\theaders: mergeHeaders({ 'Content-Type': 'application/octet-stream' }, options.headers),\n\t\t});\n\n\t\tconst json: StoreBlobMetadataResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets the primary or secondary sliver identified by the specified blob ID and\n\t * index. The index should represent a sliver that is assigned to be stored at one\n\t * of the shards managed by this storage node during this epoch.\n\t */\n\tasync getSliver(\n\t\t{ blobId, sliverPairIndex, sliverType }: GetSliverRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetSliverResponse> {\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\theaders: mergeHeaders({ Accept: 'application/octet-stream' }, options.headers),\n\t\t\t},\n\t\t);\n\n\t\tconst bcsBytes = await response.arrayBuffer();\n\t\treturn SliverData.parse(new Uint8Array(bcsBytes));\n\t}\n\n\t/**\n\t * Stores a primary or secondary blob sliver at the storage node.\n\t */\n\tasync storeSliver(\n\t\t{ blobId, sliverPairIndex, sliverType, sliver }: StoreSliverRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<StoreSliverResponse> {\n\t\tconst isBcsInput = typeof sliver === 'object' && 'symbols' in sliver;\n\t\tconst body = isBcsInput ? SliverData.serialize(sliver).toBytes() : sliver;\n\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tbody: body as Uint8Array<ArrayBuffer>,\n\t\t\t\theaders: mergeHeaders({ 'Content-Type': 'application/octet-stream' }, options.headers),\n\t\t\t},\n\t\t);\n\n\t\tconst json: StoreSliverResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets a signed storage confirmation from this storage node, indicating that all shards\n\t * assigned to this storage node for the current epoch have stored their respective slivers.\n\t */\n\tasync getDeletableBlobConfirmation(\n\t\t{ blobId, objectId }: GetDeletableBlobConfirmationRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetDeletableBlobConfirmationResponse> {\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/confirmation/deletable/${objectId}`,\n\t\t\toptions,\n\t\t);\n\n\t\tconst json: GetDeletableBlobConfirmationResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets a signed storage confirmation from this storage node, indicating that all shards\n\t * assigned to this storage node for the current epoch have stored their respective slivers.\n\t */\n\tasync getPermanentBlobConfirmation(\n\t\t{ blobId }: GetPermanentBlobConfirmationRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetPermanentBlobConfirmationResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/confirmation/permanent`, options);\n\n\t\tconst json: GetPermanentBlobConfirmationResponse = await response.json();\n\t\treturn json;\n\t}\n\n\tasync #request(path: string, options: RequestOptions) {\n\t\tconst { nodeUrl, signal, timeout, ...init } = options;\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new UserAbortError();\n\t\t}\n\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout ?? this.#timeout);\n\n\t\tlet response: Response | undefined;\n\n\t\ttry {\n\t\t\tconst fetch = this.#fetch;\n\t\t\tresponse = await fetch(`${nodeUrl}${path}`, {\n\t\t\t\t...init,\n\t\t\t\tsignal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (signal?.aborted) {\n\t\t\t\tthrow new UserAbortError();\n\t\t\t}\n\n\t\t\tif (error instanceof Error && error.name === 'AbortError') {\n\t\t\t\tconst error = new ConnectionTimeoutError();\n\t\t\t\tthis.#onError?.(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthis.#onError?.(error as Error);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text().catch((reason) => reason);\n\t\t\tconst errorJSON = safeParseJSON(errorText);\n\t\t\tconst errorMessage = errorJSON ? undefined : errorText;\n\t\t\tconst error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);\n\t\t\tthis.#onError?.(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn response;\n\t}\n}\n\nfunction safeParseJSON(value: string) {\n\ttry {\n\t\treturn JSON.parse(value);\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { InferBcsType } from '@mysten/bcs';\nimport type { SuiMoveNormalizedType } from '@mysten/sui/client';\n\nimport type { Committee } from '../contracts/walrus/committee.js';\nimport type { EncodingType } from '../types.js';\nimport { BlobId } from './bcs.js';\n\nconst DIGEST_LEN = 32;\nconst BLOB_ID_LEN = 32;\n\nexport const REQUIRED_ALIGNMENT_BY_ENCODING_TYPE = {\n\tRS2: 2,\n\tRedStuff: 2,\n};\n\nexport const MAX_SYMBOL_SIZE_BY_ENCODING_TYPE = {\n\tRS2: 2 ** 16 - 1,\n\tRedStuff: 2 ** 16 - 1,\n};\n\n// TODO: this name is kinda bad\nexport function encodedBlobLength(\n\tunencodedLength: number,\n\tnShards: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tconst sliverSize = encodedSliverSize(unencodedLength, nShards, encodingType);\n\tconst metadata = nShards * DIGEST_LEN * 2 + BLOB_ID_LEN;\n\treturn nShards * metadata + sliverSize;\n}\n\nexport function encodedSliverSize(\n\tunencodedLength: number,\n\tnShards: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tconst { primarySymbols, secondarySymbols } = getSourceSymbols(nShards, encodingType);\n\n\tlet symbolSize =\n\t\tMath.floor((Math.max(unencodedLength, 1) - 1) / (primarySymbols * secondarySymbols)) + 1;\n\n\tif (encodingType === 'RS2' && symbolSize % 2 === 1) {\n\t\tsymbolSize = symbolSize + 1;\n\t}\n\n\tconst singleShardSize = (primarySymbols + secondarySymbols) * symbolSize;\n\n\treturn singleShardSize * nShards;\n}\n\nexport function getSourceSymbols(nShards: number, encodingType: EncodingType = 'RS2') {\n\tconst safetyLimit = decodingSafetyLimit(nShards, encodingType);\n\tconst maxFaulty = getMaxFaultyNodes(nShards);\n\tconst minCorrect = nShards - maxFaulty;\n\n\treturn {\n\t\tprimarySymbols: minCorrect - maxFaulty - safetyLimit,\n\t\tsecondarySymbols: minCorrect - safetyLimit,\n\t};\n}\n\nexport function isQuorum(size: number, nShards: number): boolean {\n\tconst maxFaulty = getMaxFaultyNodes(nShards);\n\treturn size > 2 * maxFaulty;\n}\n\nexport function isAboveValidity(size: number, nShards: number): boolean {\n\tconst maxFaulty = getMaxFaultyNodes(nShards);\n\treturn size > maxFaulty;\n}\n\nexport function getMaxFaultyNodes(nShards: number): number {\n\treturn Math.floor((nShards - 1) / 3);\n}\n\nfunction decodingSafetyLimit(nShards: number, encodingType: EncodingType): number {\n\tswitch (encodingType) {\n\t\tcase 'RedStuff':\n\t\t\treturn Math.min(5, Math.floor(getMaxFaultyNodes(nShards) / 5));\n\t\tcase 'RS2':\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tthrow new Error(`Encountered unknown encoding type of ${encodingType}`);\n\t}\n}\n\nconst BYTES_PER_UNIT_SIZE = 1024 * 1024;\n\nexport function storageUnitsFromSize(size: number): number {\n\treturn Math.ceil(size / BYTES_PER_UNIT_SIZE);\n}\n\nfunction rotationOffset(bytes: Uint8Array, modulus: number): number {\n\treturn bytes.reduce((acc, byte) => (acc * 256 + byte) % modulus, 0);\n}\n\nexport function toShardIndex(sliverPairIndex: number, blobId: string, numShards: number): number {\n\tconst offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);\n\treturn (sliverPairIndex + offset) % numShards;\n}\n\nexport function sliverPairIndexFromSecondarySliverIndex(\n\tsliverIndex: number,\n\tnumShards: number,\n): number {\n\treturn numShards - sliverIndex - 1;\n}\n\nexport function shardIndexFromSecondarySliverIndex(\n\tsliverIndex: number,\n\tblobId: string,\n\tnumShards: number,\n): number {\n\tconst sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards);\n\treturn toShardIndex(sliverPairIndex, blobId, numShards);\n}\n\nexport function toPairIndex(shardIndex: number, blobId: string, numShards: number): number {\n\tconst offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);\n\treturn (numShards + shardIndex - offset) % numShards;\n}\n\nexport function signersToBitmap(signers: number[], committeeSize: number): Uint8Array {\n\tconst bitmapSize = Math.ceil(committeeSize / 8);\n\tconst bitmap = new Uint8Array(bitmapSize);\n\n\tfor (const signer of signers) {\n\t\tconst byteIndex = Math.floor(signer / 8);\n\t\tconst bitIndex = signer % 8;\n\t\tbitmap[byteIndex] |= 1 << bitIndex;\n\t}\n\n\treturn bitmap;\n}\n\nexport function getShardIndicesByNodeId(committee: InferBcsType<typeof Committee>) {\n\tconst shardIndicesByNodeId = new Map<string, number[]>();\n\n\tfor (const node of committee[0].contents) {\n\t\tif (!shardIndicesByNodeId.has(node.key)) {\n\t\t\tshardIndicesByNodeId.set(node.key, []);\n\t\t}\n\t\tshardIndicesByNodeId.get(node.key)!.push(...node.value);\n\t}\n\n\treturn shardIndicesByNodeId;\n}\n\nexport function nodesByShardIndex(committee: InferBcsType<typeof Committee>) {\n\tconst nodesByShardIndex = new Map<number, string>();\n\n\tfor (const node of committee[0].contents) {\n\t\tfor (const shardIndex of node.value) {\n\t\t\tnodesByShardIndex.set(shardIndex, node.key);\n\t\t}\n\t}\n\n\treturn nodesByShardIndex;\n}\n\nexport function toTypeString(type: SuiMoveNormalizedType): string {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn `vector<${toTypeString(type.Vector)}>`;\n\t}\n\n\tif ('Struct' in type) {\n\t\tif (type.Struct.typeArguments.length > 0) {\n\t\t\treturn `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}<${type.Struct.typeArguments.map(toTypeString).join(',')}>`;\n\t\t} else {\n\t\t\treturn `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}`;\n\t\t}\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\tthrow new Error(`Type parameters can't be converted to type strings`);\n\t}\n\n\tif ('Reference' in type) {\n\t\treturn toTypeString(type.Reference);\n\t}\n\n\tif ('MutableReference' in type) {\n\t\treturn toTypeString(type.MutableReference);\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function urlSafeBase64(bytes: Uint8Array): string {\n\treturn toBase64(bytes).replace(/=*$/, '').replaceAll('+', '-').replaceAll('/', '_');\n}\n\nexport function fromUrlSafeBase64(base64: string): Uint8Array {\n\treturn fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'));\n}\n\nexport function getSizes(blobSize: number, numShards: number) {\n\tconst encodedBlobSize = encodedSliverSize(blobSize, numShards);\n\tconst { primarySymbols, secondarySymbols } = getSourceSymbols(numShards);\n\tconst totalSymbols = (primarySymbols + secondarySymbols) * numShards;\n\n\tif (encodedBlobSize % totalSymbols !== 0) {\n\t\tthrow new Error('encoded blob size should be divisible by total symbols');\n\t}\n\n\tconst symbolSize = encodedBlobSize / totalSymbols;\n\n\tif (encodedBlobSize % totalSymbols !== 0) {\n\t\tthrow new Error('blob length should be divisible by total symbols');\n\t}\n\n\tconst rowSize = symbolSize * secondarySymbols;\n\tconst columnSize = symbolSize * primarySymbols;\n\n\treturn {\n\t\tsymbolSize,\n\t\trowSize,\n\t\tcolumnSize,\n\t\tblobSize,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\nimport { pureBcsSchemaFromTypeName } from '@mysten/sui/bcs';\nimport type { PureTypeName, ShapeFromPureTypeName } from '@mysten/sui/bcs';\nimport type { SuiObjectData } from '@mysten/sui/client';\nimport type {\n\tExperimental_BaseClient,\n\tExperimental_SuiClientTypes,\n} from '@mysten/sui/experimental';\nimport { deriveDynamicFieldID } from '@mysten/sui/utils';\nimport DataLoader from 'dataloader';\nimport { Field } from './bcs.js';\n\nexport class SuiObjectDataLoader extends DataLoader<\n\tstring,\n\tExperimental_SuiClientTypes.ObjectResponse\n> {\n\t#dynamicFieldCache = new Map<string, Map<string, Experimental_SuiClientTypes.ObjectResponse>>();\n\tconstructor(suiClient: Experimental_BaseClient) {\n\t\tsuper(async (ids: readonly string[]) => {\n\t\t\tconst { objects } = await suiClient.core.getObjects({\n\t\t\t\tobjectIds: ids as string[],\n\t\t\t});\n\n\t\t\treturn objects;\n\t\t});\n\t}\n\n\toverride async load<T = SuiObjectData>(id: string, schema?: BcsType<T, any>): Promise<T> {\n\t\tconst data = await super.load(id);\n\n\t\tif (schema) {\n\t\t\treturn schema.parse(await data.content);\n\t\t}\n\n\t\treturn data as T;\n\t}\n\n\toverride async loadMany<T = SuiObjectData>(\n\t\tids: string[],\n\t\tschema?: BcsType<T, any>,\n\t): Promise<(T | Error)[]> {\n\t\tconst data = await super.loadMany(ids);\n\n\t\tif (!schema) {\n\t\t\treturn data as (T | Error)[];\n\t\t}\n\n\t\treturn Promise.all(\n\t\t\tdata.map(async (d) => {\n\t\t\t\tif (d instanceof Error) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\n\t\t\t\treturn schema.parse(await d.content);\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync loadManyOrThrow<T>(ids: string[], schema: BcsType<T, any>): Promise<T[]> {\n\t\tconst data = await this.loadMany(ids, schema);\n\n\t\tfor (const d of data) {\n\t\t\tif (d instanceof Error) {\n\t\t\t\tthrow d;\n\t\t\t}\n\t\t}\n\n\t\treturn data as T[];\n\t}\n\n\toverride clearAll() {\n\t\tthis.#dynamicFieldCache.clear();\n\t\treturn super.clearAll();\n\t}\n\n\toverride clear(key: string) {\n\t\tthis.#dynamicFieldCache.delete(key);\n\t\treturn super.clear(key);\n\t}\n\n\tasync loadFieldObject<K extends PureTypeName, T>(\n\t\tparent: string,\n\t\tname: {\n\t\t\ttype: K;\n\t\t\tvalue: ShapeFromPureTypeName<K>;\n\t\t},\n\t\ttype: BcsType<T, any>,\n\t): Promise<T> {\n\t\tconst schema = pureBcsSchemaFromTypeName<K>(name.type as never);\n\t\tconst id = deriveDynamicFieldID(parent, 'u64', schema.serialize(name.value).toBytes());\n\n\t\treturn (await this.load(id, Field(schema, type))).value;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\ntype WeightedItem<T> = {\n\tvalue: T;\n\tweight: number;\n};\n\nexport function weightedShuffle<T>(arr: WeightedItem<T>[]): T[] {\n\treturn arr\n\t\t.map(({ value, weight }) => ({\n\t\t\tvalue,\n\t\t\tweight: Math.pow(Math.random(), 1 / weight),\n\t\t}))\n\t\t.sort((a, b) => b.weight - a.weight)\n\t\t.map((item) => item.value);\n}\n\nexport function shuffle<T>(arr: T[]): T[] {\n\tconst result = [...arr];\n\n\tfor (let i = result.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t[result[i], result[j]] = [result[j], result[i]];\n\t}\n\n\treturn result;\n}\n", "let wasm;\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_4.set(idx, obj);\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_4.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n/**\n * @param {Uint8Array} signature\n * @param {Uint8Array} public_key\n * @param {Uint8Array} msg\n * @returns {boolean}\n */\nexport function bls12381_min_pk_verify(signature, public_key, msg) {\n    const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArray8ToWasm0(msg, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ret = wasm.bls12381_min_pk_verify(ptr0, len0, ptr1, len1, ptr2, len2);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return ret[0] !== 0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * Aggregate a list of signatures.\n * The signatures must be of the type Vec<Vec<u8>> with each signature being a 96 bytes long serialized signature.\n * @param {any} signatures\n * @returns {Uint8Array}\n */\nexport function bls12381_min_pk_aggregate(signatures) {\n    const ret = wasm.bls12381_min_pk_aggregate(signatures);\n    if (ret[3]) {\n        throw takeFromExternrefTable0(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n}\n\n/**\n * Verify an aggregate signature.\n * @param {any} public_keys\n * @param {Uint8Array} msg\n * @param {Uint8Array} signature\n * @returns {boolean}\n */\nexport function bls12381_min_pk_verify_aggregate(public_keys, msg, signature) {\n    const ptr0 = passArray8ToWasm0(msg, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.bls12381_min_pk_verify_aggregate(public_keys, ptr0, len0, ptr1, len1);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return ret[0] !== 0;\n}\n\nconst BlobEncoderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_blobencoder_free(ptr >>> 0, 1));\n\nexport class BlobEncoder {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BlobEncoderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blobencoder_free(ptr, 0);\n    }\n    /**\n     * @param {number} n_shards\n     */\n    constructor(n_shards) {\n        const ret = wasm.blobencoder_new(n_shards);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        BlobEncoderFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * WASM wrapper for [walrus_core::encoding::blob_encoding::BlobEncoder::encode_with_metadata].\n     * Returns a tuple with a vector of [walrus_core::encoding::slivers::SliverPair]s and a [walrus_core::metadata::VerifiedBlobMetadataWithId]`.\n     * @param {Uint8Array} data\n     * @returns {any}\n     */\n    encode_with_metadata(data) {\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.blobencoder_encode_with_metadata(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * WASM wrapper for [walrus_core::encoding::blob_encoding::BlobEncoder::compute_metadata].\n     * Returns [walrus_core::metadata::VerifiedBlobMetadataWithId].\n     * @param {Uint8Array} data\n     * @returns {any}\n     */\n    compute_metadata(data) {\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.blobencoder_compute_metadata(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * WASM wrapper for [walrus_core::encoding::blob_encoding::BlobEncoder::decode].\n     * The input `slivers` is expected to be a `Vec<SliverData<Primary>>`.\n     * Returns `Vec<u8>`.\n     * @param {any} blob_id\n     * @param {bigint} blob_size\n     * @param {any} slivers\n     * @returns {any}\n     */\n    decode(blob_id, blob_size, slivers) {\n        const ret = wasm.blobencoder_decode(this.__wbg_ptr, blob_id, blob_size, slivers);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_String_fed4d24b68977888 = function(arg0, arg1) {\n        const ret = String(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = arg0.buffer;\n        return ret;\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = arg0.call(arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {\n        const ret = arg0.done;\n        return ret;\n    };\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(arg0, arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\n        const ret = arg0[arg1 >>> 0];\n        return ret;\n    };\n    imports.wbg.__wbg_getwithrefkey_bb8f74a92cb2e784 = function(arg0, arg1) {\n        const ret = arg0[arg1];\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_isArray_a1eab7e0d067391b = function(arg0) {\n        const ret = Array.isArray(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(arg0) {\n        const ret = Number.isSafeInteger(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {\n        const ret = Symbol.iterator;\n        return ret;\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\n        const ret = new Object();\n        return ret;\n    };\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\n        const ret = new Array();\n        return ret;\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {\n        const ret = arg0.next;\n        return ret;\n    };\n    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() { return handleError(function (arg0) {\n        const ret = arg0.next();\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {\n        arg0[arg1 >>> 0] = arg2;\n    };\n    imports.wbg.__wbg_set_3fda3bac07393de4 = function(arg0, arg1, arg2) {\n        arg0[arg1] = arg2;\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {\n        const ret = arg0.value;\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = arg0;\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbindgen_in = function(arg0, arg1) {\n        const ret = arg0 in arg1;\n        return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_4;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(arg0) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = arg0;\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = arg0 === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = arg0 == arg1;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = arg1;\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return ret;\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = arg1;\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('walrus_wasm_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport init, {\n\tBlobEncoder,\n\tbls12381_min_pk_aggregate,\n\tbls12381_min_pk_verify,\n} from '@mysten/walrus-wasm';\n\nimport type { StorageConfirmation } from './storage-node/types.js';\nimport type { EncodingType, ProtocolMessageCertificate } from './types.js';\nimport type { BlobMetadata, BlobMetadataWithId, SliverData, SliverPair } from './utils/bcs.js';\nimport { BlobId, blobIdFromBytes } from './utils/bcs.js';\n\nexport interface EncodedBlob {\n\tsliverPairs: (typeof SliverPair.$inferInput)[];\n\tblobId: string;\n\tmetadata: typeof BlobMetadata.$inferInput;\n\trootHash: Uint8Array;\n}\n\nexport async function getWasmBindings(url?: string) {\n\tawait init({ module_or_path: url });\n\n\tfunction encodeBlob(\n\t\tnShards: number,\n\t\tbytes: Uint8Array,\n\t\tencodingType: EncodingType = 'RS2',\n\t): EncodedBlob {\n\t\tconst encoder = new BlobEncoder(nShards);\n\n\t\tif (encodingType !== 'RS2') {\n\t\t\tthrow new Error(`Unsupported encoding type: ${encodingType}`);\n\t\t}\n\n\t\tconst [sliverPairs, metadata, rootHash] = encoder.encode_with_metadata(bytes);\n\n\t\treturn {\n\t\t\tsliverPairs,\n\t\t\tblobId: blobIdFromBytes(new Uint8Array(metadata.blob_id)),\n\t\t\tmetadata: metadata.metadata,\n\t\t\trootHash: new Uint8Array(rootHash.Digest),\n\t\t};\n\t}\n\n\tfunction combineSignatures(\n\t\tconfirmations: StorageConfirmation[],\n\t\tsignerIndices: number[],\n\t): ProtocolMessageCertificate {\n\t\tconst signature = bls12381_min_pk_aggregate(\n\t\t\tconfirmations.map((confirmation) => fromBase64(confirmation.signature)),\n\t\t);\n\n\t\treturn {\n\t\t\tsigners: signerIndices,\n\t\t\tserializedMessage: fromBase64(confirmations[0].serializedMessage),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\tfunction decodePrimarySlivers(\n\t\tblobId: string,\n\t\tnShards: number,\n\t\tsize: number | bigint | string,\n\t\tslivers: (typeof SliverData.$inferInput)[],\n\t\tencodingType: EncodingType = 'RS2',\n\t): Uint8Array {\n\t\tconst encoder = new BlobEncoder(nShards);\n\n\t\tif (encodingType !== 'RS2') {\n\t\t\tthrow new Error(`Unsupported encoding type: ${encodingType}`);\n\t\t}\n\n\t\tconst [bytes] = encoder.decode(\n\t\t\tBlobId.serialize(blobId).toBytes(),\n\t\t\tBigInt(size),\n\t\t\tslivers.map((sliver) => ({\n\t\t\t\t...sliver,\n\t\t\t\t_sliver_type: undefined,\n\t\t\t})),\n\t\t);\n\n\t\treturn new Uint8Array(bytes);\n\t}\n\n\tfunction getVerifySignature() {\n\t\treturn (confirmation: StorageConfirmation, publicKey: Uint8Array) =>\n\t\t\tbls12381_min_pk_verify(\n\t\t\t\tfromBase64(confirmation.signature),\n\t\t\t\tpublicKey,\n\t\t\t\tfromBase64(confirmation.serializedMessage),\n\t\t\t);\n\t}\n\n\tfunction computeMetadata(\n\t\tnShards: number,\n\t\tbytes: Uint8Array,\n\t\tencodingType: EncodingType = 'RS2',\n\t): typeof BlobMetadataWithId.$inferInput & { blobId: string; rootHash: Uint8Array } {\n\t\tconst encoder = new BlobEncoder(nShards);\n\t\tconst [metadata, rootHash] = encoder.compute_metadata(bytes);\n\n\t\tif (encodingType !== 'RS2') {\n\t\t\tthrow new Error(`Unsupported encoding type: ${encodingType}`);\n\t\t}\n\n\t\treturn {\n\t\t\t...metadata,\n\t\t\tblobId: blobIdFromBytes(new Uint8Array(metadata.blob_id)),\n\t\t\trootHash: new Uint8Array(rootHash.Digest),\n\t\t};\n\t}\n\n\treturn {\n\t\tencodeBlob,\n\t\tcombineSignatures,\n\t\tdecodePrimarySlivers,\n\t\tgetVerifySignature,\n\t\tcomputeMetadata,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ConnectionTimeoutError, StorageNodeAPIError } from '../storage-node/error.js';\nimport { UserAbortError } from '../storage-node/error.js';\nimport type { mergeHeaders } from '../storage-node/utils.js';\nimport type {\n\tEncodingType,\n\tUploadRelayTipConfig,\n\tProtocolMessageCertificate,\n\tWalrusClientRequestOptions,\n} from '../types.js';\nimport { fromUrlSafeBase64, urlSafeBase64 } from '../utils/index.js';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\nexport type UploadRelayClientOptions = {\n\thost: string;\n\t/**\n\t * An optional custom fetch function.\n\t *\n\t * If not provided, defaults to the global `fetch` function (`globalThis.fetch`).\n\t *\n\t * @default globalThis.fetch\n\t */\n\tfetch?: Fetch;\n\n\t/**\n\t * An optional timeout for requests.\n\t * @default 30_000ms (30 seconds)\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Callback for individual network errors.\n\t */\n\tonError?: (error: Error) => void;\n};\n\nexport type RequestOptions = {\n\tpath: string;\n\ttimeout?: number;\n\theaders?: ReturnType<typeof mergeHeaders>;\n} & Omit<RequestInit, 'headers'>;\n\nexport type WriteBlobToUploadRelayOptions = {\n\tblobId: string;\n\tnonce: Uint8Array;\n\ttxDigest: string;\n\tblob: Uint8Array;\n\tblobObjectId: string;\n\tdeletable: boolean;\n\trequiresTip: boolean;\n\tencodingType?: EncodingType;\n} & WalrusClientRequestOptions;\n\nexport class UploadRelayClient {\n\thost: string;\n\t#fetch: Fetch;\n\t#timeout: number;\n\t#onError?: (error: Error) => void;\n\tconstructor({ host, fetch: overriddenFetch, timeout, onError }: UploadRelayClientOptions) {\n\t\tthis.host = host;\n\t\tthis.#fetch = overriddenFetch ?? globalThis.fetch;\n\t\tthis.#timeout = timeout ?? 30_000;\n\t\tthis.#onError = onError;\n\t}\n\n\tasync tipConfig(): Promise<UploadRelayTipConfig | null> {\n\t\tconst response = await this.#request({\n\t\t\tmethod: 'GET',\n\t\t\tpath: '/v1/tip-config',\n\t\t});\n\n\t\tconst data = (await response.json()) as\n\t\t\t| {\n\t\t\t\t\tsend_tip: {\n\t\t\t\t\t\taddress: string;\n\t\t\t\t\t\tkind:\n\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\tconst: number;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\tlinear: {\n\t\t\t\t\t\t\t\t\t\tbase: number;\n\t\t\t\t\t\t\t\t\t\tencoded_size_mul_per_kib: number;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t  };\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| 'no_tip';\n\n\t\tif (typeof data === 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ('const' in data.send_tip.kind) {\n\t\t\treturn {\n\t\t\t\taddress: data.send_tip.address,\n\t\t\t\tkind: {\n\t\t\t\t\tconst: data.send_tip.kind.const,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\taddress: data.send_tip.address,\n\t\t\tkind: {\n\t\t\t\tlinear: {\n\t\t\t\t\tbase: data.send_tip.kind.linear.base,\n\t\t\t\t\tperEncodedKib: data.send_tip.kind.linear.encoded_size_mul_per_kib,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\tasync writeBlob({\n\t\tblobId,\n\t\tnonce,\n\t\ttxDigest,\n\t\tblob,\n\t\tdeletable,\n\t\tblobObjectId,\n\t\trequiresTip,\n\t\tencodingType,\n\t\t...options\n\t}: WriteBlobToUploadRelayOptions): Promise<{\n\t\tblobId: string;\n\t\tcertificate: ProtocolMessageCertificate;\n\t}> {\n\t\tconst query = new URLSearchParams({\n\t\t\tblob_id: blobId,\n\t\t});\n\n\t\tif (requiresTip) {\n\t\t\tquery.set('nonce', urlSafeBase64(nonce));\n\t\t\tquery.set('tx_id', txDigest);\n\t\t}\n\n\t\tif (deletable) {\n\t\t\tquery.set('deletable_blob_object', blobObjectId);\n\t\t}\n\n\t\tif (encodingType) {\n\t\t\tquery.set('encoding_type', encodingType);\n\t\t}\n\n\t\tconst response = await this.#request({\n\t\t\tmethod: 'POST',\n\t\t\tpath: `/v1/blob-upload-relay?${query.toString()}`,\n\t\t\tbody: blob as Uint8Array<ArrayBuffer>,\n\t\t\t...options,\n\t\t});\n\n\t\tconst data: {\n\t\t\tblob_id: number[];\n\t\t\tconfirmation_certificate: {\n\t\t\t\tsigners: number[];\n\t\t\t\tserialized_message: number[];\n\t\t\t\tsignature: string;\n\t\t\t};\n\t\t} = await response.json();\n\n\t\treturn {\n\t\t\tblobId,\n\t\t\tcertificate: {\n\t\t\t\tsigners: data.confirmation_certificate.signers,\n\t\t\t\tserializedMessage: new Uint8Array(data.confirmation_certificate.serialized_message),\n\t\t\t\tsignature: fromUrlSafeBase64(data.confirmation_certificate.signature),\n\t\t\t},\n\t\t};\n\t}\n\n\tasync #request(options: RequestOptions) {\n\t\tconst { signal, timeout, ...init } = options;\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new UserAbortError();\n\t\t}\n\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout ?? this.#timeout);\n\n\t\tlet response: Response | undefined;\n\n\t\ttry {\n\t\t\tconst fetch = this.#fetch;\n\t\t\tresponse = await fetch(`${this.host}${options.path}`, {\n\t\t\t\t...init,\n\t\t\t\tsignal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (signal?.aborted) {\n\t\t\t\tthrow new UserAbortError();\n\t\t\t}\n\n\t\t\tif (error instanceof Error && error.name === 'AbortError') {\n\t\t\t\tconst error = new ConnectionTimeoutError();\n\t\t\t\tthis.#onError?.(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthis.#onError?.(error as Error);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text().catch((reason) => reason);\n\t\t\tconst errorJSON = safeParseJSON(errorText);\n\t\t\tconst errorMessage = errorJSON ? undefined : errorText;\n\t\t\tconst error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);\n\t\t\tthis.#onError?.(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn response;\n\t}\n}\n\nfunction safeParseJSON(value: string) {\n\ttry {\n\t\treturn JSON.parse(value);\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { EncodingType } from '../types.js';\nimport type { QuiltPatchV1 } from './bcs.js';\nimport { QuiltIndexV1, QuiltPatchBlobHeader, QuiltPatchId, QuiltPatchTags } from './bcs.js';\nimport {\n\tfromUrlSafeBase64,\n\tgetSourceSymbols,\n\tMAX_SYMBOL_SIZE_BY_ENCODING_TYPE,\n\tREQUIRED_ALIGNMENT_BY_ENCODING_TYPE,\n\turlSafeBase64,\n} from './index.js';\n\nexport const QUILT_INDEX_SIZE_BYTES_LENGTH = 4;\nexport const QUILT_VERSION_BYTES_LENGTH = 1;\nexport const QUILT_INDEX_PREFIX_SIZE = QUILT_VERSION_BYTES_LENGTH + QUILT_INDEX_SIZE_BYTES_LENGTH;\nexport const QUILT_PATCH_BLOB_HEADER_SIZE = 1 + 4 + 1; // bcs length of QuiltPatchBlobHeader\n\nexport const BLOB_IDENTIFIER_SIZE_BYTES_LENGTH = 2;\nexport const TAGS_SIZE_BYTES_LENGTH = 2;\nexport const MAX_BLOB_IDENTIFIER_BYTES_LENGTH = (1 << (8 * BLOB_IDENTIFIER_SIZE_BYTES_LENGTH)) - 1;\nexport const MAX_NUM_SLIVERS_FOR_QUILT_INDEX = 10;\n\nexport const HAS_TAGS_FLAG = 1 << 0;\n\n/**\n * Finds the minimum symbol size needed to store blobs in a fixed number of columns.\n * Each blob must be stored in consecutive columns exclusively.\n *\n * A binary search is used to find the minimum symbol size:\n * 1. Compute the upper and lower bounds for the symbol size.\n * 2. Check if the all the blobs can be fit into the quilt with the current symbol size.\n * 3. Adjust the bounds based on the result and repeat until the symbol size is found.\n *\n * @param blobsSizes - Slice of blob lengths, including the index size as the first element.\n *   Note that the len of the blob_size should be between 1 and n_columns.\n * @param nColumns - Number of columns available.\n * @param nRows - Number of rows available.\n * @param maxNumColumnsForQuiltIndex - The maximum number of columns that can be used to\n *   store the quilt index.\n * @param encodingType - The encoding type to use.\n *\n * @returns The minimum symbol size needed.\n **/\nexport function computeSymbolSize(\n\tblobsSizes: number[],\n\tnColumns: number,\n\tnRows: number,\n\tmaxNumColumnsForQuiltIndex: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tif (blobsSizes.length > nColumns) {\n\t\tthrow new Error('Too many blobs, the number of blobs must be less than the number of columns');\n\t}\n\n\tif (blobsSizes.length === 0) {\n\t\tthrow new Error('No blobs provided');\n\t}\n\n\tlet minVal = Math.max(\n\t\tblobsSizes.reduce((acc, size) => acc + size, 0) / (nColumns * nRows),\n\t\tblobsSizes[0] / (nRows * maxNumColumnsForQuiltIndex),\n\t\tMath.ceil(QUILT_INDEX_PREFIX_SIZE / nRows),\n\t);\n\n\tlet maxVal = Math.ceil((Math.max(...blobsSizes) / (nColumns / blobsSizes.length)) * nRows);\n\n\twhile (minVal < maxVal) {\n\t\tconst mid = (minVal + maxVal) / 2;\n\t\tif (canBlobsFitIntoMatrix(blobsSizes, nColumns, mid * nRows)) {\n\t\t\tmaxVal = mid;\n\t\t} else {\n\t\t\tminVal = mid + 1;\n\t\t}\n\t}\n\n\tconst symbolSize =\n\t\tMath.ceil(minVal / REQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType]) *\n\t\tREQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType];\n\n\tif (!canBlobsFitIntoMatrix(blobsSizes, nColumns, symbolSize * nRows)) {\n\t\tthrow new Error('Quilt oversize');\n\t}\n\n\tif (symbolSize > MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]) {\n\t\tthrow new Error(\n\t\t\t`Quilt oversize: the resulting symbol size ${symbolSize} is larger than the maximum symbol size ${MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]}; remove some blobs`,\n\t\t);\n\t}\n\n\treturn symbolSize;\n}\n\nfunction canBlobsFitIntoMatrix(\n\tblobsSizes: number[],\n\tnColumns: number,\n\tcolumnSize: number,\n): boolean {\n\treturn blobsSizes.reduce((acc, size) => acc + Math.ceil(size / columnSize), 0) <= nColumns;\n}\n\nexport function parseQuiltPatchId(id: string) {\n\treturn QuiltPatchId.parse(fromUrlSafeBase64(id));\n}\n\nexport function encodeQuiltPatchId(id: typeof QuiltPatchId.$inferInput) {\n\treturn urlSafeBase64(QuiltPatchId.serialize(id).toBytes());\n}\n\nexport function parseWalrusId(id: string) {\n\tconst bytes = fromUrlSafeBase64(id);\n\n\tif (bytes.length === 32) {\n\t\treturn {\n\t\t\tkind: 'blob' as const,\n\t\t\tid,\n\t\t};\n\t}\n\n\treturn {\n\t\tkind: 'quiltPatch' as const,\n\t\tid: parseQuiltPatchId(id),\n\t};\n}\n\nexport interface EncodeQuiltOptions {\n\tblobs: {\n\t\tcontents: Uint8Array;\n\t\tidentifier: string;\n\t\ttags?: Record<string, string>;\n\t}[];\n\tnumShards: number;\n\tencodingType?: EncodingType;\n}\n\nexport function encodeQuilt({ blobs, numShards, encodingType }: EncodeQuiltOptions) {\n\tconst { primarySymbols: nRows, secondarySymbols: nCols } = getSourceSymbols(\n\t\tnumShards,\n\t\tencodingType,\n\t);\n\n\tconst sortedBlobs = blobs.sort((a, b) => (a.identifier < b.identifier ? -1 : 1));\n\tconst identifiers = new Set<string>();\n\tconst index = {\n\t\tpatches: [] as (typeof QuiltPatchV1.$inferInput & { startIndex: number })[],\n\t};\n\tconst tags = sortedBlobs.map((blob) =>\n\t\tblob.tags && Object.keys(blob.tags).length > 0\n\t\t\t? QuiltPatchTags.serialize(blob.tags).toBytes()\n\t\t\t: null,\n\t);\n\n\tfor (const blob of sortedBlobs) {\n\t\tif (identifiers.has(blob.identifier)) {\n\t\t\tthrow new Error(`Duplicate blob identifier: ${blob.identifier}`);\n\t\t}\n\t\tidentifiers.add(blob.identifier);\n\t\tindex.patches.push({\n\t\t\tstartIndex: 0,\n\t\t\tendIndex: 0,\n\t\t\tidentifier: blob.identifier,\n\t\t\ttags: blob.tags ?? {},\n\t\t});\n\t}\n\n\tconst indexSize = QUILT_INDEX_PREFIX_SIZE + QuiltIndexV1.serialize(index).toBytes().length;\n\tconst blobMetadata = sortedBlobs.map((blob, i) => {\n\t\tconst identifierBytes = bcs.string().serialize(blob.identifier).toBytes();\n\t\tlet metadataSize =\n\t\t\tQUILT_PATCH_BLOB_HEADER_SIZE + BLOB_IDENTIFIER_SIZE_BYTES_LENGTH + identifierBytes.length;\n\n\t\tlet mask = 0;\n\t\tlet offset = 0;\n\n\t\tif (tags[i]) {\n\t\t\tmetadataSize += TAGS_SIZE_BYTES_LENGTH + tags[i].length;\n\t\t\tmask |= HAS_TAGS_FLAG << 0;\n\t\t}\n\n\t\tconst metadata = new Uint8Array(metadataSize);\n\t\tconst metadataView = new DataView(metadata.buffer);\n\n\t\tconst header = QuiltPatchBlobHeader.serialize({\n\t\t\tversion: 1,\n\t\t\tlength: metadataSize - QUILT_PATCH_BLOB_HEADER_SIZE + blob.contents.length,\n\t\t\tmask,\n\t\t}).toBytes();\n\n\t\tmetadata.set(header, offset);\n\t\toffset += header.length;\n\n\t\tmetadataView.setUint16(offset, identifierBytes.length, true);\n\t\toffset += BLOB_IDENTIFIER_SIZE_BYTES_LENGTH;\n\t\tmetadata.set(identifierBytes, offset);\n\t\toffset += identifierBytes.length;\n\n\t\tif (tags[i]) {\n\t\t\tmetadataView.setUint16(offset, tags[i].length, true);\n\t\t\toffset += TAGS_SIZE_BYTES_LENGTH;\n\t\t\tmetadata.set(tags[i], offset);\n\t\t\toffset += tags[i].length;\n\t\t}\n\n\t\treturn metadata;\n\t});\n\n\tconst blobSizes = [\n\t\tindexSize,\n\t\t...sortedBlobs.map((blob, i) => {\n\t\t\tif (blob.identifier.length > MAX_BLOB_IDENTIFIER_BYTES_LENGTH) {\n\t\t\t\tthrow new Error(`Blob identifier too long: ${blob.identifier}`);\n\t\t\t}\n\n\t\t\treturn blobMetadata[i].length + blob.contents.length;\n\t\t}),\n\t];\n\n\tconst symbolSize = computeSymbolSize(\n\t\tblobSizes,\n\t\tnCols,\n\t\tnRows,\n\t\tMAX_NUM_SLIVERS_FOR_QUILT_INDEX,\n\t\tencodingType,\n\t);\n\n\tconst rowSize = symbolSize * nCols;\n\tconst columnSize = symbolSize * nRows;\n\tconst indexColumnsNeeded = Math.ceil(indexSize / columnSize);\n\n\tif (indexColumnsNeeded > MAX_NUM_SLIVERS_FOR_QUILT_INDEX) {\n\t\tthrow new Error('Index too large');\n\t}\n\n\tconst quilt = new Uint8Array(rowSize * nRows);\n\tlet currentColumn = indexColumnsNeeded;\n\n\tfor (let i = 0; i < sortedBlobs.length; i++) {\n\t\tconst blob = sortedBlobs[i];\n\t\tindex.patches[i].startIndex = currentColumn;\n\t\tcurrentColumn += writeBlobToQuilt(\n\t\t\tquilt,\n\t\t\tblob.contents,\n\t\t\trowSize,\n\t\t\tcolumnSize,\n\t\t\tsymbolSize,\n\t\t\tcurrentColumn,\n\t\t\tblobMetadata[i],\n\t\t);\n\t\tindex.patches[i].endIndex = currentColumn;\n\t}\n\n\tconst indexBytes = QuiltIndexV1.serialize(index).toBytes();\n\tconst quiltIndex = new Uint8Array(QUILT_INDEX_PREFIX_SIZE + indexBytes.length);\n\tconst view = new DataView(quiltIndex.buffer);\n\tview.setUint8(0, 1);\n\tview.setUint32(1, indexBytes.length, true);\n\tquiltIndex.set(indexBytes, QUILT_INDEX_PREFIX_SIZE);\n\n\twriteBlobToQuilt(quilt, quiltIndex, rowSize, columnSize, symbolSize, 0);\n\n\treturn { quilt, index };\n}\n\nfunction writeBlobToQuilt(\n\tquilt: Uint8Array,\n\tblob: Uint8Array,\n\trowSize: number,\n\tcolumnSize: number,\n\tsymbolSize: number,\n\tstartColumn: number,\n\tprefix?: Uint8Array,\n) {\n\tconst nRows = columnSize / symbolSize;\n\tlet bytesWritten = 0;\n\n\tif (rowSize % symbolSize !== 0) {\n\t\tthrow new Error('Row size must be divisible by symbol size');\n\t}\n\n\tif (columnSize % symbolSize !== 0) {\n\t\tthrow new Error('Column size must be divisible by symbol size');\n\t}\n\n\tif (prefix) {\n\t\twriteBytes(prefix);\n\t}\n\n\twriteBytes(blob);\n\n\treturn Math.ceil(bytesWritten / columnSize);\n\n\tfunction writeBytes(bytes: Uint8Array) {\n\t\tconst offset = bytesWritten;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet index = 0;\n\t\twhile (index < bytes.length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst len = Math.min(symbolSize - remainingOffset, bytes.length - index);\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tquilt[startIndex + i] = bytes[index + i];\n\t\t\t}\n\t\t\tindex += len;\n\t\t\tremainingOffset = 0;\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol++;\n\t\t\t}\n\t\t}\n\n\t\tbytesWritten += bytes.length;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { FileReader } from '../file.js';\nimport type { QuiltReader } from './quilt.js';\n\nexport interface QuiltBlobHeader {\n\tidentifier: string;\n\ttags: Record<string, string> | null;\n\tblobSize: number;\n\tcontentOffset: number;\n\tcolumnSize: number;\n}\n\nexport class QuiltFileReader implements FileReader {\n\t#quilt: QuiltReader;\n\t#sliverIndex: number;\n\t#identifier: string | null;\n\t#tags?: Record<string, string>;\n\n\tconstructor({\n\t\tquilt,\n\t\tsliverIndex,\n\t\tidentifier,\n\t\ttags,\n\t}: {\n\t\tquilt: QuiltReader;\n\t\tsliverIndex: number;\n\t\tidentifier?: string;\n\t\ttags?: Record<string, string>;\n\t}) {\n\t\tthis.#quilt = quilt;\n\t\tthis.#sliverIndex = sliverIndex;\n\t\tthis.#identifier = identifier ?? null;\n\t\tthis.#tags = tags;\n\t}\n\n\tasync getBytes(): Promise<Uint8Array> {\n\t\tconst { blobContents, identifier, tags } = await this.#quilt.readBlob(this.#sliverIndex);\n\t\tthis.#identifier = identifier;\n\t\tthis.#tags = tags ?? {};\n\t\treturn blobContents;\n\t}\n\n\tasync getIdentifier() {\n\t\tif (this.#identifier !== null) {\n\t\t\treturn this.#identifier;\n\t\t}\n\n\t\tconst header = await this.#quilt.getBlobHeader(this.#sliverIndex);\n\n\t\tthis.#identifier = header.identifier;\n\t\treturn this.#identifier;\n\t}\n\n\tasync getTags() {\n\t\tif (this.#tags !== undefined) {\n\t\t\treturn this.#tags;\n\t\t}\n\n\t\tconst header = await this.#quilt.getBlobHeader(this.#sliverIndex);\n\t\tthis.#tags = header.tags ?? {};\n\t\treturn this.#tags;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '@mysten/sui/experimental';\nimport type { BlobReader } from './blob.js';\nimport { QuiltPatchBlobHeader, QuiltPatchId } from '../../utils/bcs.js';\nimport {\n\tHAS_TAGS_FLAG,\n\tparseQuiltPatchId,\n\tQUILT_PATCH_BLOB_HEADER_SIZE,\n} from '../../utils/quilts.js';\nimport { bcs } from '@mysten/bcs';\nimport { QuiltPatchTags } from '../../utils/bcs.js';\nimport { QuiltIndexV1 } from '../../utils/bcs.js';\nimport { urlSafeBase64 } from '../../utils/index.js';\nimport { QuiltFileReader } from './quilt-file.js';\n\nexport interface QuiltReaderOptions {\n\tblob: BlobReader;\n}\n\nexport class QuiltReader {\n\t#blob: BlobReader;\n\t#cache = new ClientCache();\n\n\tconstructor({ blob }: QuiltReaderOptions) {\n\t\tthis.#blob = blob;\n\t}\n\n\tasync #readBytesFromSlivers(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (!length) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\n\t\t// start loading the first sliver, but don't wait for it (may improve columnSize lookup)\n\t\tthis.#blob.getSecondarySliver({ sliverIndex: sliver }).catch(() => {});\n\n\t\tcolumnSize = columnSize ?? (await this.#blob.getColumnSize());\n\t\tconst columnOffset = Math.floor(offset / columnSize);\n\t\tlet remainingOffset = offset % columnSize;\n\t\tconst bytes = new Uint8Array(length);\n\n\t\tlet bytesRead = 0;\n\n\t\tconst nSlivers = Math.ceil(length / columnSize);\n\t\tconst slivers = new Array(nSlivers)\n\t\t\t.fill(0)\n\t\t\t.map((_, i) => this.#blob.getSecondarySliver({ sliverIndex: sliver + columnOffset + i }));\n\n\t\t// ignore errors from slivers that are not consumed below\n\t\tslivers.forEach((p) => p.catch(() => {}));\n\n\t\tfor (const sliverPromise of slivers) {\n\t\t\tconst sliver = await sliverPromise;\n\t\t\tlet chunk = remainingOffset > 0 ? sliver.subarray(remainingOffset) : sliver;\n\t\t\tremainingOffset -= chunk.length;\n\t\t\tif (chunk.length > length - bytesRead) {\n\t\t\t\tchunk = chunk.subarray(0, length - bytesRead);\n\t\t\t}\n\n\t\t\tbytes.set(chunk, bytesRead);\n\t\t\tbytesRead += chunk.length;\n\n\t\t\tif (bytesRead >= length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\tasync #readBytesFromBlob(startColumn: number, length: number, offset = 0) {\n\t\tconst result = new Uint8Array(length);\n\n\t\tif (!length) {\n\t\t\treturn result;\n\t\t}\n\t\tconst blob = await this.#blob.getBytes();\n\n\t\tconst [rowSize, symbolSize] = await Promise.all([\n\t\t\tthis.#blob.getRowSize(),\n\t\t\tthis.#blob.getSymbolSize(),\n\t\t]);\n\n\t\tconst nRows = blob.length / rowSize;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet bytesRead = 0;\n\n\t\twhile (bytesRead < length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst endIndex = Math.min(\n\t\t\t\tbaseIndex + symbolSize,\n\t\t\t\tstartIndex + length - bytesRead,\n\t\t\t\tblob.length,\n\t\t\t);\n\n\t\t\tif (startIndex >= blob.length) {\n\t\t\t\tthrow new Error('Index out of bounds');\n\t\t\t}\n\n\t\t\tconst size = endIndex - startIndex;\n\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[bytesRead + i] = blob[startIndex + i];\n\t\t\t}\n\n\t\t\tbytesRead += size;\n\n\t\t\tremainingOffset = 0;\n\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync #readBytes(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (this.#blob.hasStartedLoadingFullBlob) {\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\n\t\ttry {\n\t\t\tconst bytes = await this.#readBytesFromSlivers(sliver, length, offset, columnSize);\n\n\t\t\treturn bytes;\n\t\t} catch {\n\t\t\t// fallback to reading the full blob\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\t}\n\n\tasync getBlobHeader(sliverIndex: number) {\n\t\treturn this.#cache.read(['getBlobHeader', sliverIndex.toString()], async () => {\n\t\t\tconst blobHeader = QuiltPatchBlobHeader.parse(\n\t\t\t\tawait this.#readBytes(sliverIndex, QUILT_PATCH_BLOB_HEADER_SIZE),\n\t\t\t);\n\n\t\t\tlet offset = QUILT_PATCH_BLOB_HEADER_SIZE;\n\t\t\tlet blobSize = blobHeader.length;\n\n\t\t\tconst identifierLength = new DataView(\n\t\t\t\t(await this.#readBytes(sliverIndex, 2, offset)).buffer,\n\t\t\t).getUint16(0, true);\n\t\t\tblobSize -= 2 + identifierLength;\n\t\t\toffset += 2;\n\n\t\t\tconst identifier = bcs\n\t\t\t\t.string()\n\t\t\t\t.parse(await this.#readBytes(sliverIndex, identifierLength, offset));\n\n\t\t\toffset += identifierLength;\n\n\t\t\tlet tags: Record<string, string> | null = null;\n\t\t\tif (blobHeader.mask & HAS_TAGS_FLAG) {\n\t\t\t\tconst tagsSize = new DataView(\n\t\t\t\t\t(await this.#readBytes(sliverIndex, 2, offset)).buffer,\n\t\t\t\t).getUint16(0, true);\n\t\t\t\toffset += 2;\n\n\t\t\t\ttags = QuiltPatchTags.parse(await this.#readBytes(sliverIndex, tagsSize, offset));\n\t\t\t\tblobSize -= tagsSize + 2;\n\t\t\t\toffset += tagsSize;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tidentifier,\n\t\t\t\ttags,\n\t\t\t\tblobSize,\n\t\t\t\tcontentOffset: offset,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync readBlob(sliverIndex: number) {\n\t\tconst { identifier, tags, blobSize, contentOffset } = await this.getBlobHeader(sliverIndex);\n\n\t\tconst blobContents = await this.#readBytes(sliverIndex, blobSize, contentOffset);\n\n\t\treturn {\n\t\t\tidentifier,\n\t\t\ttags,\n\t\t\tblobContents,\n\t\t};\n\t}\n\n\treaderForPatchId(id: string) {\n\t\tconst { quiltId, patchId } = parseQuiltPatchId(id);\n\n\t\tif (quiltId !== this.#blob.blobId) {\n\t\t\tthrow new Error(\n\t\t\t\t`The requested patch ${patchId} is not part of the quilt ${this.#blob.blobId}`,\n\t\t\t);\n\t\t}\n\n\t\treturn new QuiltFileReader({ quilt: this, sliverIndex: patchId.startIndex });\n\t}\n\n\tasync readIndex() {\n\t\tconst header = new DataView((await this.#readBytes(0, 5)).buffer);\n\n\t\tconst version = header.getUint8(0);\n\n\t\tif (version !== 1) {\n\t\t\tthrow new Error(`Unsupported quilt version ${version}`);\n\t\t}\n\n\t\tconst indexSize = header.getUint32(1, true);\n\t\tconst indexBytes = await this.#readBytes(0, indexSize, 5);\n\t\tconst columnSize = await this.#blob.getColumnSize();\n\t\tconst indexSlivers = Math.ceil(indexSize / columnSize);\n\t\tconst index = QuiltIndexV1.parse(indexBytes);\n\n\t\treturn index.patches.map((patch, i) => {\n\t\t\tconst startIndex = i === 0 ? indexSlivers : index.patches[i - 1].endIndex;\n\t\t\tconst reader = new QuiltFileReader({\n\t\t\t\tquilt: this,\n\t\t\t\tsliverIndex: startIndex,\n\t\t\t\tidentifier: patch.identifier,\n\t\t\t\ttags: patch.tags,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tidentifier: patch.identifier,\n\t\t\t\tpatchId: urlSafeBase64(\n\t\t\t\t\tQuiltPatchId.serialize({\n\t\t\t\t\t\tquiltId: this.#blob.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}).toBytes(),\n\t\t\t\t),\n\t\t\t\ttags: patch.tags,\n\t\t\t\treader,\n\t\t\t};\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { ClientCache } from '@mysten/sui/experimental';\nimport type { FileReader } from '../file.js';\nimport type { WalrusClient } from '../../client.js';\nimport { getSizes, getSourceSymbols } from '../../utils/index.js';\nimport { QuiltReader } from './quilt.js';\n\nexport interface BlobReaderOptions {\n\tclient: WalrusClient;\n\tblobId: string;\n\tnumShards: number;\n}\n\nexport class BlobReader implements FileReader {\n\tblobId: string;\n\n\t#cache = new ClientCache();\n\n\t#client: WalrusClient;\n\t#secondarySlivers = new Map<number, Uint8Array | Promise<Uint8Array>>();\n\thasStartedLoadingFullBlob = false;\n\t#numShards: number;\n\n\tconstructor({ client, blobId, numShards }: BlobReaderOptions) {\n\t\tthis.#client = client;\n\t\tthis.blobId = blobId;\n\t\tthis.#numShards = numShards;\n\t}\n\n\tasync getIdentifier() {\n\t\treturn null;\n\t}\n\n\tasync getTags() {\n\t\treturn {};\n\t}\n\n\tgetQuiltReader() {\n\t\treturn new QuiltReader({ blob: this });\n\t}\n\n\tasync getBytes() {\n\t\treturn this.#cache.read(['getBytes'], async () => {\n\t\t\tthis.hasStartedLoadingFullBlob = true;\n\t\t\ttry {\n\t\t\t\tconst blob = await this.#client.readBlob({ blobId: this.blobId });\n\t\t\t\treturn blob;\n\t\t\t} catch (error) {\n\t\t\t\tthis.hasStartedLoadingFullBlob = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t}\n\n\tgetMetadata() {\n\t\treturn this.#cache.read(['getMetadata'], () =>\n\t\t\tthis.#client.getBlobMetadata({ blobId: this.blobId }),\n\t\t);\n\t}\n\n\tasync getColumnSize() {\n\t\treturn this.#cache.read(['getColumnSize'], async () => {\n\t\t\tconst loadingSlivers = [...this.#secondarySlivers.values()];\n\n\t\t\tif (loadingSlivers.length > 0) {\n\t\t\t\tconst sliver = await Promise.any(loadingSlivers).catch(() => null);\n\n\t\t\t\tif (sliver) {\n\t\t\t\t\treturn sliver.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.hasStartedLoadingFullBlob) {\n\t\t\t\tconst blob = await this.getBytes();\n\t\t\t\tconst { columnSize } = getSizes(blob.length, this.#numShards);\n\t\t\t\treturn columnSize;\n\t\t\t}\n\n\t\t\tconst metadata = await this.getMetadata();\n\t\t\tconst { columnSize } = getSizes(\n\t\t\t\tNumber(metadata.metadata.V1.unencoded_length),\n\t\t\t\tthis.#numShards,\n\t\t\t);\n\n\t\t\treturn columnSize;\n\t\t});\n\t}\n\n\tasync getSymbolSize() {\n\t\tconst columnSize = await this.getColumnSize();\n\t\tconst { primarySymbols } = getSourceSymbols(this.#numShards);\n\n\t\tif (columnSize % primarySymbols !== 0) {\n\t\t\tthrow new Error('column size should be divisible by primary symbols');\n\t\t}\n\n\t\treturn columnSize / primarySymbols;\n\t}\n\n\tasync getRowSize() {\n\t\tconst symbolSize = await this.getSymbolSize();\n\t\tconst { secondarySymbols } = getSourceSymbols(this.#numShards);\n\t\treturn symbolSize * secondarySymbols;\n\t}\n\n\tasync getSecondarySliver({ sliverIndex, signal }: { sliverIndex: number; signal?: AbortSignal }) {\n\t\tif (this.#secondarySlivers.has(sliverIndex)) {\n\t\t\treturn this.#secondarySlivers.get(sliverIndex)!;\n\t\t}\n\n\t\tconst sliverPromise = this.#client\n\t\t\t.getSecondarySliver({\n\t\t\t\tblobId: this.blobId,\n\t\t\t\tindex: sliverIndex,\n\t\t\t\tsignal,\n\t\t\t})\n\t\t\t.then((sliver) => new Uint8Array(sliver.symbols.data));\n\n\t\tthis.#secondarySlivers.set(sliverIndex, sliverPromise);\n\n\t\ttry {\n\t\t\tconst sliver = await sliverPromise;\n\t\t\tthis.#secondarySlivers.set(sliverIndex, sliver);\n\t\t\treturn sliver;\n\t\t} catch (error) {\n\t\t\tthis.#secondarySlivers.delete(sliverIndex);\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { FileReader } from '../file.js';\n\nexport class LocalReader implements FileReader {\n\t#contents: Uint8Array | Blob;\n\t#identifier: string | null;\n\t#tags: Record<string, string>;\n\n\tconstructor({\n\t\tcontents,\n\t\tidentifier,\n\t\ttags,\n\t}: {\n\t\tcontents: Uint8Array | Blob;\n\t\tidentifier?: string;\n\t\ttags?: Record<string, string>;\n\t}) {\n\t\tthis.#contents = contents;\n\t\tthis.#identifier = identifier ?? null;\n\t\tthis.#tags = tags ?? {};\n\t}\n\n\tasync getBytes() {\n\t\tif ('arrayBuffer' in this.#contents) {\n\t\t\treturn new Uint8Array(await this.#contents.arrayBuffer());\n\t\t}\n\n\t\treturn this.#contents;\n\t}\n\n\tasync getIdentifier() {\n\t\treturn this.#identifier;\n\t}\n\n\tasync getTags() {\n\t\treturn this.#tags;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { LocalReader } from './readers/local.js';\n\nexport interface FileReader {\n\tgetIdentifier(): Promise<string | null>;\n\tgetTags(): Promise<Record<string, string>>;\n\tgetBytes(): Promise<Uint8Array>;\n}\n\nexport class WalrusFile {\n\t#reader: FileReader;\n\n\tstatic from(options: {\n\t\tcontents: Uint8Array | Blob;\n\t\tidentifier: string;\n\t\ttags?: Record<string, string>;\n\t}) {\n\t\treturn new WalrusFile({\n\t\t\treader: new LocalReader(options),\n\t\t});\n\t}\n\n\tconstructor({ reader }: { reader: FileReader }) {\n\t\tthis.#reader = reader;\n\t}\n\n\tgetIdentifier() {\n\t\treturn this.#reader.getIdentifier();\n\t}\n\tgetTags() {\n\t\treturn this.#reader.getTags();\n\t}\n\n\tbytes() {\n\t\treturn this.#reader.getBytes();\n\t}\n\n\tasync text() {\n\t\tconst bytes = await this.bytes();\n\n\t\treturn new TextDecoder().decode(bytes);\n\t}\n\n\tasync json() {\n\t\treturn JSON.parse(await this.text());\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalrusClient } from '../client.js';\nimport type { BlobReader } from './readers/blob.js';\nimport { WalrusFile } from './file.js';\nimport { ClientCache } from '@mysten/sui/experimental';\n\nexport class WalrusBlob {\n\t#reader: BlobReader;\n\t#client: WalrusClient;\n\t#cache = new ClientCache();\n\n\tconstructor({ reader, client }: { reader: BlobReader; client: WalrusClient }) {\n\t\tthis.#reader = reader;\n\t\tthis.#client = client;\n\t}\n\n\t// Get the blob as a file (i.e. do not use Quilt encoding)\n\tasFile() {\n\t\treturn new WalrusFile({ reader: this.#reader });\n\t}\n\n\tasync blobId(): Promise<string | null> {\n\t\treturn this.#reader.blobId;\n\t}\n\n\t// Gets quilt-based files associated with this blob.\n\tasync files(\n\t\tfilters: {\n\t\t\tids?: string[];\n\t\t\ttags?: { [tagName: string]: string }[];\n\t\t\tidentifiers?: string[];\n\t\t} = {},\n\t) {\n\t\tconst quiltReader = await this.#reader.getQuiltReader();\n\t\tconst index = await quiltReader.readIndex();\n\n\t\tconst files = [];\n\n\t\tfor (const patch of index) {\n\t\t\tif (filters.ids && !filters.ids.includes(patch.patchId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (filters.identifiers && !filters.identifiers.includes(patch.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tfilters.tags &&\n\t\t\t\t!filters.tags.some((tags) =>\n\t\t\t\t\tObject.entries(tags).every(([tagName, tagValue]) => patch.tags[tagName] === tagValue),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfiles.push(new WalrusFile({ reader: quiltReader.readerForPatchId(patch.patchId) }));\n\t\t}\n\n\t\treturn files;\n\t}\n\n\tasync #blobStatus() {\n\t\treturn this.#cache.read(['blobStatus', this.#reader.blobId], () =>\n\t\t\tthis.#client.getVerifiedBlobStatus({ blobId: this.#reader.blobId }),\n\t\t);\n\t}\n\n\tasync exists() {\n\t\tconst status = await this.#blobStatus();\n\t\treturn status.type === 'permanent' || status.type === 'deletable';\n\t}\n\n\tasync storedUntil() {\n\t\tconst status = await this.#blobStatus();\n\n\t\tif (status.type === 'permanent') {\n\t\t\treturn status.endEpoch;\n\t\t}\n\n\t\treturn null;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport async function retry<T>(\n\tfn: () => Promise<T>,\n\toptions: {\n\t\tcondition?: (error: Error) => boolean;\n\t\tcount?: number;\n\t\tdelay?: number;\n\t\tjitter?: number;\n\t},\n): Promise<T> {\n\tlet remaining = options.count ?? 3;\n\n\twhile (remaining > 0) {\n\t\ttry {\n\t\t\tremaining -= 1;\n\t\t\treturn await fn();\n\t\t} catch (error) {\n\t\t\tif (remaining <= 0 || (options.condition && !options.condition(error as Error))) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (options.delay) {\n\t\t\t\tawait new Promise((resolve) =>\n\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t\t(options.delay ?? 1000) + (options.jitter ? Math.random() * options.jitter : 0),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Should never be reached\n\tthrow new Error('Retry count exceeded');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferBcsType } from '@mysten/bcs';\nimport { bcs } from '@mysten/bcs';\nimport { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { ClientCache, ClientWithCoreApi } from '@mysten/sui/experimental';\nimport type { TransactionObjectArgument, TransactionResult } from '@mysten/sui/transactions';\nimport { coinWithBalance, Transaction } from '@mysten/sui/transactions';\nimport { normalizeStructTag, parseStructTag } from '@mysten/sui/utils';\n\nimport {\n\tMAINNET_WALRUS_PACKAGE_CONFIG,\n\tstatusLifecycleRank,\n\tTESTNET_WALRUS_PACKAGE_CONFIG,\n} from './constants.js';\nimport {\n\taddMetadata,\n\tBlob,\n\tinsertOrUpdateMetadataPair,\n\tremoveMetadataPair,\n} from './contracts/walrus/blob.js';\nimport type { Committee } from './contracts/walrus/committee.js';\nimport * as metadata from './contracts/walrus/metadata.js';\nimport { StakingInnerV1 } from './contracts/walrus/staking_inner.js';\nimport { StakingPool } from './contracts/walrus/staking_pool.js';\nimport { Staking } from './contracts/walrus/staking.js';\nimport { Storage } from './contracts/walrus/storage_resource.js';\nimport { SystemStateInnerV1 } from './contracts/walrus/system_state_inner.js';\nimport {\n\tcertifyBlob,\n\tdeleteBlob,\n\textendBlob,\n\tregisterBlob,\n\treserveSpace,\n\tSystem,\n} from './contracts/walrus/system.js';\nimport {\n\tBehindCurrentEpochError,\n\tBlobBlockedError,\n\tBlobNotCertifiedError,\n\tInconsistentBlobError,\n\tNoBlobMetadataReceivedError,\n\tNoBlobStatusReceivedError,\n\tNotEnoughBlobConfirmationsError,\n\tNotEnoughSliversReceivedError,\n\tNoVerifiedBlobStatusReceivedError,\n\tRetryableWalrusClientError,\n\tWalrusClientError,\n} from './error.js';\nimport { StorageNodeClient } from './storage-node/client.js';\nimport {\n\tBlobNotRegisteredError,\n\tLegallyUnavailableError,\n\tNotFoundError,\n\tUserAbortError,\n} from './storage-node/error.js';\nimport type { BlobMetadataWithId, BlobStatus, GetSliverResponse } from './storage-node/types.js';\nimport type {\n\tCertifyBlobOptions,\n\tCommitteeInfo,\n\tComputeBlobMetadataOptions,\n\tDeleteBlobOptions,\n\tEncodingType,\n\tExtendBlobOptions,\n\tUploadRelayConfig,\n\tGetBlobMetadataOptions,\n\tGetCertificationEpochOptions,\n\tGetSecondarySliverOptions,\n\tGetSliversOptions,\n\tGetStorageConfirmationOptions,\n\tGetVerifiedBlobStatusOptions,\n\tProtocolMessageCertificate,\n\tReadBlobOptions,\n\tRegisterBlobOptions,\n\tSliversForNode,\n\tStorageNode,\n\tStorageWithSizeOptions,\n\tWalrusClientConfig,\n\tWalrusClientExtensionOptions,\n\tWalrusPackageConfig,\n\tWriteBlobAttributesOptions,\n\tWriteBlobOptions,\n\tWriteBlobToUploadRelayOptions,\n\tWriteEncodedBlobOptions,\n\tWriteEncodedBlobToNodesOptions,\n\tWriteMetadataOptions,\n\tWriteQuiltOptions,\n\tWriteSliverOptions,\n\tWriteSliversToNodeOptions,\n\tWriteFilesOptions,\n\tWriteFilesFlowOptions,\n\tWriteFilesFlow,\n\tWriteFilesFlowRegisterOptions,\n\tWriteFilesFlowUploadOptions,\n\tWriteBlobFlow,\n\tWriteBlobFlowOptions,\n\tWriteBlobFlowRegisterOptions,\n\tWriteBlobFlowUploadOptions,\n\tWalrusOptions,\n} from './types.js';\nimport { blobIdToInt, IntentType, SliverData, StorageConfirmation } from './utils/bcs.js';\nimport {\n\tencodedBlobLength,\n\tgetShardIndicesByNodeId,\n\tgetSourceSymbols,\n\tisAboveValidity,\n\tisQuorum,\n\tsignersToBitmap,\n\tsliverPairIndexFromSecondarySliverIndex,\n\tstorageUnitsFromSize,\n\ttoPairIndex,\n\ttoShardIndex,\n} from './utils/index.js';\nimport { SuiObjectDataLoader } from './utils/object-loader.js';\nimport { shuffle, weightedShuffle } from './utils/randomness.js';\nimport { getWasmBindings } from './wasm.js';\nimport { chunk } from '@mysten/utils';\nimport { UploadRelayClient } from './upload-relay/client.js';\nimport { encodeQuilt, encodeQuiltPatchId, parseWalrusId } from './utils/quilts.js';\nimport { BlobReader } from './files/readers/blob.js';\nimport { WalrusBlob } from './files/blob.js';\nimport { WalrusFile } from './files/file.js';\nimport { QuiltFileReader } from './files/readers/quilt-file.js';\nimport { QuiltReader } from './files/readers/quilt.js';\nimport { retry } from './utils/retry.js';\n\nexport function walrus<const Name = 'walrus'>({\n\tpackageConfig,\n\tnetwork,\n\tname = 'walrus' as Name,\n\t...options\n}: WalrusOptions<Name> = {}) {\n\treturn {\n\t\tname,\n\t\tregister: (client: ClientWithCoreApi) => {\n\t\t\tconst walrusNetwork = network || client.network;\n\n\t\t\tif (walrusNetwork !== 'mainnet' && walrusNetwork !== 'testnet') {\n\t\t\t\tthrow new WalrusClientError('Walrus client only supports mainnet and testnet');\n\t\t\t}\n\n\t\t\treturn new WalrusClient(\n\t\t\t\tpackageConfig\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tpackageConfig,\n\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tnetwork: walrusNetwork as 'mainnet' | 'testnet',\n\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t},\n\t\t\t);\n\t\t},\n\t};\n}\n\nexport class WalrusClient {\n\t#storageNodeClient: StorageNodeClient;\n\t#wasmUrl: string | undefined;\n\n\t#packageConfig: WalrusPackageConfig;\n\t#suiClient: ClientWithCoreApi;\n\t#objectLoader: SuiObjectDataLoader;\n\n\t#blobMetadataConcurrencyLimit = 10;\n\t#readCommittee?: CommitteeInfo | Promise<CommitteeInfo> | null;\n\n\t#cache: ClientCache;\n\n\t#uploadRelayConfig: UploadRelayConfig | null = null;\n\t#uploadRelayClient: UploadRelayClient | null = null;\n\n\tconstructor(config: WalrusClientConfig) {\n\t\tif (config.network && !config.packageConfig) {\n\t\t\tconst network = config.network;\n\t\t\tswitch (network) {\n\t\t\t\tcase 'testnet':\n\t\t\t\t\tthis.#packageConfig = TESTNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mainnet':\n\t\t\t\t\tthis.#packageConfig = MAINNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new WalrusClientError(`Unsupported network: ${network}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#packageConfig = config.packageConfig!;\n\t\t}\n\n\t\tthis.#wasmUrl = config.wasmUrl;\n\t\tthis.#uploadRelayConfig = config.uploadRelay ?? null;\n\t\tif (this.#uploadRelayConfig) {\n\t\t\tthis.#uploadRelayClient = new UploadRelayClient(this.#uploadRelayConfig);\n\t\t}\n\n\t\tthis.#suiClient =\n\t\t\tconfig.suiClient ??\n\t\t\tnew SuiClient({\n\t\t\t\turl: config.suiRpcUrl,\n\t\t\t});\n\n\t\tthis.#storageNodeClient = new StorageNodeClient(config.storageNodeClientOptions);\n\t\tthis.#objectLoader = new SuiObjectDataLoader(this.#suiClient);\n\t\tthis.#cache = this.#suiClient.cache.scope('@mysten/walrus');\n\t}\n\n\t/** @deprecated use `walrus()` instead */\n\tstatic experimental_asClientExtension({\n\t\tpackageConfig,\n\t\tnetwork,\n\t\t...options\n\t}: WalrusClientExtensionOptions = {}) {\n\t\treturn {\n\t\t\tname: 'walrus' as const,\n\t\t\tregister: (client: ClientWithCoreApi) => {\n\t\t\t\tconst walrusNetwork = network || client.network;\n\n\t\t\t\tif (walrusNetwork !== 'mainnet' && walrusNetwork !== 'testnet') {\n\t\t\t\t\tthrow new WalrusClientError('Walrus client only supports mainnet and testnet');\n\t\t\t\t}\n\n\t\t\t\treturn new WalrusClient(\n\t\t\t\t\tpackageConfig\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpackageConfig,\n\t\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tnetwork: walrusNetwork as 'mainnet' | 'testnet',\n\t\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n\t/** The Move type for a WAL coin */\n\t#walType() {\n\t\treturn this.#cache.read(['walType'], async () => {\n\t\t\tconst stakeWithPool = await this.#suiClient.core.getMoveFunction({\n\t\t\t\tpackageId: await this.#getPackageId(),\n\t\t\t\tmoduleName: 'staking',\n\t\t\t\tname: 'stake_with_pool',\n\t\t\t});\n\n\t\t\tconst toStake = stakeWithPool.function.parameters[1];\n\t\t\tconst toStakeCoin = toStake.body.$kind === 'datatype' ? toStake.body.datatype : null;\n\t\t\tconst toStakeCoinType =\n\t\t\t\ttoStakeCoin?.typeParameters[0]?.$kind === 'datatype' ? toStakeCoin.typeParameters[0] : null;\n\n\t\t\tif (toStakeCoinType?.$kind !== 'datatype') {\n\t\t\t\tthrow new WalrusClientError('WAL type not found');\n\t\t\t}\n\n\t\t\treturn normalizeStructTag(toStakeCoinType.datatype.typeName);\n\t\t});\n\t}\n\n\t#getPackageId() {\n\t\treturn this.#cache.read(['getPackageId'], async () => {\n\t\t\tconst system = await this.#objectLoader.load(this.#packageConfig.systemObjectId);\n\t\t\treturn parseStructTag(system.type!).address;\n\t\t});\n\t}\n\n\t/** The Move type for a Blob object */\n\tgetBlobType() {\n\t\treturn this.#cache.read(['getBlobType'], async () => {\n\t\t\treturn `${await this.#getPackageId()}::blob::Blob`;\n\t\t});\n\t}\n\n\t#getWalrusPackageId() {\n\t\treturn this.#cache.read(['getSystemPackageId'], async () => {\n\t\t\tconst { package_id } = await this.systemObject();\n\t\t\treturn package_id;\n\t\t});\n\t}\n\n\t#wasmBindings() {\n\t\treturn this.#cache.read(['wasmBindings'], async () => {\n\t\t\treturn getWasmBindings(this.#wasmUrl);\n\t\t});\n\t}\n\n\t/** The cached system object for the walrus package */\n\tsystemObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.systemObjectId, System);\n\t}\n\n\t/** The cached staking pool object for the walrus package */\n\tstakingObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.stakingPoolId, Staking);\n\t}\n\n\t/** The system state for the current version of walrus contract  */\n\tasync systemState() {\n\t\tconst systemState = await this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.systemObjectId,\n\t\t\t{ type: 'u64', value: (await this.systemObject()).version },\n\t\t\tSystemStateInnerV1,\n\t\t);\n\n\t\treturn systemState;\n\t}\n\n\t/** The staking state for the current version of walrus contract */\n\tasync stakingState() {\n\t\treturn this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.stakingPoolId,\n\t\t\t{\n\t\t\t\ttype: 'u64',\n\t\t\t\tvalue: (await this.stakingObject()).version,\n\t\t\t},\n\t\t\tStakingInnerV1,\n\t\t);\n\t}\n\n\t/** Read a blob from the storage nodes */\n\treadBlob = this.#retryOnPossibleEpochChange(this.#internalReadBlob);\n\n\tasync #internalReadBlob({ blobId, signal }: ReadBlobOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst numShards = systemState.committee.n_shards;\n\n\t\tconst blobMetadata = await this.getBlobMetadata({ blobId, signal });\n\n\t\tconst slivers = await this.getSlivers({ blobId, signal });\n\n\t\tconst bindings = await this.#wasmBindings();\n\n\t\tconst blobBytes = bindings.decodePrimarySlivers(\n\t\t\tblobId,\n\t\t\tnumShards,\n\t\t\tblobMetadata.metadata.V1.unencoded_length,\n\t\t\tslivers,\n\t\t);\n\n\t\tconst reconstructedBlobMetadata = bindings.computeMetadata(\n\t\t\tsystemState.committee.n_shards,\n\t\t\tblobBytes,\n\t\t);\n\n\t\tif (reconstructedBlobMetadata.blobId !== blobId) {\n\t\t\tthrow new InconsistentBlobError('The specified blob was encoded incorrectly.');\n\t\t}\n\n\t\treturn blobBytes;\n\t}\n\n\tasync computeBlobMetadata({ bytes, numShards }: ComputeBlobMetadataOptions) {\n\t\tlet shardCount: number | undefined;\n\t\tif (typeof numShards === 'number') {\n\t\t\tshardCount = numShards;\n\t\t} else {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tshardCount = systemState.committee.n_shards;\n\t\t}\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, rootHash } = bindings.computeMetadata(shardCount, bytes);\n\t\tlet sha256Hash: Promise<Uint8Array> | undefined;\n\t\tconst nonce = crypto.getRandomValues(new Uint8Array(32));\n\n\t\treturn {\n\t\t\trootHash,\n\t\t\tblobId,\n\t\t\tmetadata: {\n\t\t\t\tencodingType: metadata.V1.encoding_type,\n\t\t\t\thashes: Array.from(metadata.V1.hashes).map((hashes) => ({\n\t\t\t\t\tprimaryHash: hashes.primary_hash,\n\t\t\t\t\tsecondaryHash: hashes.secondary_hash,\n\t\t\t\t})),\n\t\t\t\tunencodedLength: metadata.V1.unencoded_length,\n\t\t\t},\n\t\t\tnonce,\n\t\t\tblobDigest: () => {\n\t\t\t\tif (!sha256Hash) {\n\t\t\t\t\tsha256Hash = crypto.subtle\n\t\t\t\t\t\t.digest('SHA-256', bytes as BufferSource)\n\t\t\t\t\t\t.then((hash) => new Uint8Array(hash));\n\t\t\t\t}\n\n\t\t\t\treturn sha256Hash;\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getBlobMetadata({ blobId, signal }: GetBlobMetadataOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = shuffle(committee.nodes);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\t\tconst controller = new AbortController();\n\n\t\tconst metadataExecutors = randomizedNodes.map((node) => async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.#storageNodeClient.getBlobMetadata(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{\n\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\tnumNotFoundWeight += node.shardIndices.length;\n\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\tnumBlockedWeight += node.shardIndices.length;\n\t\t\t\t}\n\n\t\t\t\ttotalErrorCount += 1;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tconst attemptGetMetadata = metadataExecutors.shift()!;\n\t\t\treturn await attemptGetMetadata();\n\t\t} catch {\n\t\t\tconst chunkSize = Math.floor(metadataExecutors.length / this.#blobMetadataConcurrencyLimit);\n\t\t\tconst chunkedExecutors = chunk(metadataExecutors, chunkSize);\n\n\t\t\treturn await new Promise<BlobMetadataWithId>((resolve, reject) => {\n\t\t\t\tchunkedExecutors.forEach(async (executors) => {\n\t\t\t\t\tfor (const executor of executors) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst result = await executor();\n\t\t\t\t\t\t\tcontroller.abort('Blob metadata successfully retrieved.');\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (error instanceof UserAbortError) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else if (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (totalErrorCount === metadataExecutors.length) {\n\t\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\t\tnew NoBlobMetadataReceivedError(\n\t\t\t\t\t\t\t\t\t\t'No valid blob metadata could be retrieved from any storage node.',\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tgetSecondarySliver = this.#retryOnPossibleEpochChange(this.internalGetSecondarySliver);\n\n\tasync internalGetSecondarySliver({ blobId, index, signal }: GetSecondarySliverOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(index, numShards);\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`No node found for shard index ${shardIndex}`);\n\t\t}\n\n\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType: 'secondary' },\n\t\t\t{\n\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\tsignal,\n\t\t\t},\n\t\t);\n\n\t\treturn sliver;\n\t}\n\n\tasync getSlivers({ blobId, signal }: GetSliversOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = weightedShuffle(\n\t\t\tcommittee.nodes.map((node) => ({\n\t\t\t\tvalue: node,\n\t\t\t\tweight: node.shardIndices.length,\n\t\t\t})),\n\t\t);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst { primarySymbols: minSymbols } = getSourceSymbols(numShards);\n\n\t\tconst sliverPairIndices = randomizedNodes.flatMap((node) =>\n\t\t\tnode.shardIndices.map((shardIndex) => ({\n\t\t\t\turl: node.networkUrl,\n\t\t\t\tsliverPairIndex: toPairIndex(shardIndex, blobId, numShards),\n\t\t\t})),\n\t\t);\n\n\t\tconst controller = new AbortController();\n\t\tconst chunkedSliverPairIndices = chunk(sliverPairIndices, minSymbols);\n\t\tconst slivers: GetSliverResponse[] = [];\n\t\tconst failedNodes = new Set<string>();\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\n\t\treturn new Promise<GetSliverResponse[]>((resolve, reject) => {\n\t\t\tchunkedSliverPairIndices[0].forEach(async (_, colIndex) => {\n\t\t\t\tfor (let rowIndex = 0; rowIndex < chunkedSliverPairIndices.length; rowIndex += 1) {\n\t\t\t\t\tconst value = chunkedSliverPairIndices.at(rowIndex)?.at(colIndex);\n\t\t\t\t\tif (!value) break;\n\n\t\t\t\t\tconst { url, sliverPairIndex } = value;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (failedNodes.has(url)) {\n\t\t\t\t\t\t\tthrow new Error(`Skipping node at ${url} due to previous failure.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t\t\t\t\t{ blobId, sliverPairIndex, sliverType: 'primary' },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: url,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (slivers.length === minSymbols) {\n\t\t\t\t\t\t\tcontroller.abort('Enough slivers successfully retrieved.');\n\t\t\t\t\t\t\tresolve(slivers);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tslivers.push(sliver);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\t\t\tnumBlockedWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfailedNodes.add(url);\n\t\t\t\t\t\ttotalErrorCount += 1;\n\n\t\t\t\t\t\tconst remainingTasks = sliverPairIndices.length - (slivers.length + totalErrorCount);\n\t\t\t\t\t\tconst tooManyFailures = slivers.length + remainingTasks < minSymbols;\n\n\t\t\t\t\t\tif (tooManyFailures) {\n\t\t\t\t\t\t\tconst abortError = new NotEnoughSliversReceivedError(\n\t\t\t\t\t\t\t\t`Unable to retrieve enough slivers to decode blob ${blobId}.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Gets the blob status from multiple storage nodes and returns the latest status that can be verified.\n\t */\n\tasync getVerifiedBlobStatus({ blobId, signal }: GetVerifiedBlobStatusOptions) {\n\t\t// Read from the latest committee because, during epoch change, it is the committee\n\t\t// that will have the most up-to-date information on old and newly certified blobs:\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst controller = new AbortController();\n\n\t\tconst statuses = await new Promise<{ status: BlobStatus; weight: number }[]>(\n\t\t\t(resolve, reject) => {\n\t\t\t\tconst results: { status: BlobStatus; weight: number }[] = [];\n\t\t\t\tlet successWeight = 0;\n\t\t\t\tlet numNotFoundWeight = 0;\n\t\t\t\tlet settledCount = 0;\n\n\t\t\t\tcommittee.nodes.forEach(async (node) => {\n\t\t\t\t\tconst weight = node.shardIndices.length;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst status = await this.#storageNodeClient.getBlobStatus(\n\t\t\t\t\t\t\t{ blobId },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isQuorum(successWeight, numShards)) {\n\t\t\t\t\t\t\tcontroller.abort('Quorum of blob statuses retrieved successfully.');\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsuccessWeight += weight;\n\t\t\t\t\t\t\tresults.push({ status, weight });\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += weight;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError = new BlobNotCertifiedError('The blob does not exist.');\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsettledCount += 1;\n\t\t\t\t\t\tif (settledCount === committee.nodes.length) {\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew NoBlobStatusReceivedError(\n\t\t\t\t\t\t\t\t\t'Not enough statuses were retrieved to achieve quorum.',\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\n\t\tconst aggregatedStatuses = statuses.reduce((accumulator, value) => {\n\t\t\tconst { status, weight } = value;\n\t\t\tconst key = JSON.stringify(status);\n\n\t\t\tconst existing = accumulator.get(key);\n\t\t\tif (existing) {\n\t\t\t\texisting.totalWeight += weight;\n\t\t\t} else {\n\t\t\t\taccumulator.set(key, { status, totalWeight: weight });\n\t\t\t}\n\n\t\t\treturn accumulator;\n\t\t}, new Map<string, { status: BlobStatus; totalWeight: number }>());\n\n\t\tconst uniqueStatuses = [...aggregatedStatuses.values()];\n\t\tconst sortedStatuses = uniqueStatuses.toSorted(\n\t\t\t(a, b) => statusLifecycleRank[b.status.type] - statusLifecycleRank[a.status.type],\n\t\t);\n\n\t\tfor (const value of sortedStatuses) {\n\t\t\t// TODO: We can check the chain via the `event` field as a fallback here.\n\t\t\tif (isAboveValidity(value.totalWeight, numShards)) {\n\t\t\t\treturn value.status;\n\t\t\t}\n\t\t}\n\n\t\tthrow new NoVerifiedBlobStatusReceivedError(\n\t\t\t`The blob status could not be verified for blob ${blobId},`,\n\t\t);\n\t}\n\n\tasync #getCertificationEpoch({ blobId, signal }: GetCertificationEpochOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst currentEpoch = stakingState.epoch;\n\n\t\tif (stakingState.epoch_state.$kind === 'EpochChangeSync') {\n\t\t\tconst status = await this.getVerifiedBlobStatus({ blobId, signal });\n\t\t\tif (status.type === 'nonexistent' || status.type === 'invalid') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is ${status.type}.`);\n\t\t\t}\n\n\t\t\tif (typeof status.initialCertifiedEpoch !== 'number') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`);\n\t\t\t}\n\n\t\t\tif (status.initialCertifiedEpoch > currentEpoch) {\n\t\t\t\tthrow new BehindCurrentEpochError(\n\t\t\t\t\t`The client is at epoch ${currentEpoch} while the specified blob was certified at epoch ${status.initialCertifiedEpoch}.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn status.initialCertifiedEpoch;\n\t\t}\n\n\t\treturn currentEpoch;\n\t}\n\n\t/**\n\t * Retrieves the node committee responsible for serving reads.\n\t *\n\t * During an epoch change, reads should be served by the previous committee if the blob was\n\t * certified in an earlier epoch. This ensures that we read from nodes with the most accurate\n\t * information as nodes from the current committee might still be receiving transferred shards\n\t * from the previous committee.\n\t */\n\tasync #getReadCommittee(options: ReadBlobOptions) {\n\t\tif (!this.#readCommittee) {\n\t\t\tthis.#readCommittee = this.#forceGetReadCommittee(options);\n\t\t}\n\t\treturn this.#readCommittee;\n\t}\n\n\tasync #forceGetReadCommittee({ blobId, signal }: ReadBlobOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst isTransitioning = stakingState.epoch_state.$kind === 'EpochChangeSync';\n\t\tconst certificationEpoch = await this.#getCertificationEpoch({ blobId, signal });\n\n\t\tif (isTransitioning && certificationEpoch < stakingState.epoch) {\n\t\t\treturn await this.#getCommittee(stakingState.previous_committee);\n\t\t}\n\t\treturn await this.#getActiveCommittee();\n\t}\n\n\t/**\n\t * Calculate the cost of storing a blob for a given a size and number of epochs.\n\t */\n\tasync storageCost(size: number, epochs: number) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\tconst storageUnits = storageUnitsFromSize(encodedSize);\n\t\tconst storageCost =\n\t\t\tBigInt(storageUnits) * BigInt(systemState.storage_price_per_unit_size) * BigInt(epochs);\n\t\tBigInt(epochs);\n\n\t\tconst writeCost = BigInt(storageUnits) * BigInt(systemState.write_price_per_unit_size);\n\n\t\treturn { storageCost, writeCost, totalCost: storageCost + writeCost };\n\t}\n\n\t/**\n\t * A utility for creating a storage object in a transaction.\n\t *\n\t * @example\n\t * ```ts\n\t * tx.transferObjects([client.createStorage({ size: 1000, epochs: 3 })], owner);\n\t * ```\n\t */\n\tcreateStorage({ size, epochs, walCoin }: StorageWithSizeOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemObject = await this.systemObject();\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\t\tconst [{ storageCost }, walrusPackageId] = await Promise.all([\n\t\t\t\tthis.storageCost(size, epochs),\n\t\t\t\tthis.#getWalrusPackageId(),\n\t\t\t]);\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, (coin, tx) => {\n\t\t\t\t\treturn tx.add(\n\t\t\t\t\t\treserveSpace({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: systemObject.id.id,\n\t\t\t\t\t\t\t\tstorageAmount: encodedSize,\n\t\t\t\t\t\t\t\tepochsAhead: epochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t#withWal<T extends TransactionResult | void>(\n\t\tamount: bigint,\n\t\tsource: TransactionObjectArgument | null,\n\t\tfn: (coin: TransactionObjectArgument, tx: Transaction) => T | Promise<T>,\n\t) {\n\t\treturn async (tx: Transaction): Promise<T> => {\n\t\t\tconst walType = await this.#walType();\n\t\t\tconst coin = source\n\t\t\t\t? tx.splitCoins(source, [amount])[0]\n\t\t\t\t: tx.add(\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t\ttype: walType,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\tconst result = await fn(coin, tx);\n\n\t\t\ttx.moveCall({\n\t\t\t\ttarget: '0x2::coin::destroy_zero',\n\t\t\t\ttypeArguments: [walType],\n\t\t\t\targuments: [coin],\n\t\t\t});\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that creates a storage object\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.createStorageTransaction({ size: 1000, epochs: 3, owner: signer.toSuiAddress() });\n\t * ```\n\t */\n\tcreateStorageTransaction({\n\t\ttransaction = new Transaction(),\n\t\tsize,\n\t\tepochs,\n\t\towner,\n\t}: StorageWithSizeOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be transferred to */\n\t\towner: string;\n\t}) {\n\t\ttransaction.transferObjects([this.createStorage({ size, epochs })], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that creates a storage object\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest, storage } = await client.executeCreateStorageTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeCreateStorageTransaction({\n\t\tsigner,\n\t\t...options\n\t}: StorageWithSizeOptions & { transaction?: Transaction; signer: Signer }) {\n\t\tconst transaction = this.createStorageTransaction({\n\t\t\t...options,\n\t\t\towner: options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'create storage',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Storage object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tstorage: Storage.parse(await suiBlobObject.content),\n\t\t};\n\t}\n\n\t/**\n\t * Register a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * tx.transferObjects([client.registerBlob({ size: 1000, epochs: 3, blobId, rootHash, deletable: true })], owner);\n\t * ```\n\t */\n\tregisterBlob({\n\t\tsize,\n\t\tepochs,\n\t\tblobId,\n\t\trootHash,\n\t\tdeletable,\n\t\twalCoin,\n\t\tattributes,\n\t}: RegisterBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst { writeCost } = await this.storageCost(size, epochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(writeCost, walCoin ?? null, async (writeCoin, tx) => {\n\t\t\t\t\tconst blob = tx.add(\n\t\t\t\t\t\tregisterBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: tx.object(this.#packageConfig.systemObjectId),\n\t\t\t\t\t\t\t\tstorage: this.createStorage({ size, epochs, walCoin }),\n\t\t\t\t\t\t\t\tblobId: blobIdToInt(blobId),\n\t\t\t\t\t\t\t\trootHash: BigInt(bcs.u256().parse(rootHash)),\n\t\t\t\t\t\t\t\tsize,\n\t\t\t\t\t\t\t\tencodingType: 1,\n\t\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\t\twritePayment: writeCoin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\t\t\t\tattributes,\n\t\t\t\t\t\t\t\texistingAttributes: null,\n\t\t\t\t\t\t\t\tblob,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn blob;\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\taddAuthPayload({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst nonceDigest = await crypto.subtle.digest('SHA-256', nonce as BufferSource);\n\t\t\tconst lengthBytes = bcs.u64().serialize(size).toBytes();\n\t\t\tconst digest = typeof blobDigest === 'function' ? await blobDigest() : blobDigest;\n\t\t\tconst authPayload = new Uint8Array(\n\t\t\t\tnonceDigest.byteLength + digest.byteLength + lengthBytes.byteLength,\n\t\t\t);\n\n\t\t\tauthPayload.set(digest, 0);\n\t\t\tauthPayload.set(new Uint8Array(nonceDigest), digest.byteLength);\n\t\t\tauthPayload.set(lengthBytes, nonceDigest.byteLength + digest.byteLength);\n\t\t\ttransaction.pure(authPayload);\n\t\t};\n\t}\n\n\t#loadTipConfig() {\n\t\treturn this.#cache.read(['upload-relay-tip-config'], async () => {\n\t\t\tif (!this.#uploadRelayConfig?.sendTip || !this.#uploadRelayClient) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ('kind' in this.#uploadRelayConfig.sendTip) {\n\t\t\t\treturn this.#uploadRelayConfig.sendTip;\n\t\t\t}\n\n\t\t\tconst tipConfig = await this.#uploadRelayClient.tipConfig();\n\n\t\t\tif (!tipConfig) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...tipConfig,\n\t\t\t\tmax: this.#uploadRelayConfig.sendTip.max,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync calculateUploadRelayTip(options: { size: number }) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(options.size, systemState.committee.n_shards);\n\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\tif (!tipConfig) {\n\t\t\treturn 0n;\n\t\t}\n\n\t\tconst { max, kind } = tipConfig;\n\n\t\tconst amount =\n\t\t\t'const' in kind\n\t\t\t\t? kind.const\n\t\t\t\t: BigInt(kind.linear.base) +\n\t\t\t\t\tBigInt(kind.linear.perEncodedKib) * ((BigInt(encodedSize) + 1023n) / 1024n); // Compute the ceiling of the division.\n\n\t\tif (max != null && amount > max) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Tip amount (${amount}) exceeds the maximum allowed tip (${max})`,\n\t\t\t);\n\t\t}\n\n\t\treturn amount;\n\t}\n\n\tsendUploadRelayTip({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\t\tif (tipConfig) {\n\t\t\t\ttransaction.add(this.addAuthPayload({ size, blobDigest, nonce }));\n\t\t\t\tconst amount = await this.calculateUploadRelayTip({ size });\n\t\t\t\tconst { address } = tipConfig;\n\t\t\t\ttransaction.transferObjects(\n\t\t\t\t\t[\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\taddress,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that registers a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.registerBlobTransaction({ size: 1000, epochs: 3, blobId, rootHash, deletable: true });\n\t * ```\n\t */\n\tregisterBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the blob should be transferred to */\n\t\towner: string;\n\t}) {\n\t\tconst registration = transaction.add(this.registerBlob(options));\n\n\t\ttransaction.transferObjects([registration], options.owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that registers a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest, blob } = await client.executeRegisterBlobTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeRegisterBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t\t/** Address the blob should be transferred to */\n\t\towner?: string;\n\t}): Promise<{\n\t\tblob: (typeof Blob)['$inferType'];\n\t\tdigest: string;\n\t}> {\n\t\tconst transaction = this.registerBlobTransaction({\n\t\t\t...options,\n\t\t\towner: options.owner ?? options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'register blob',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tblob: Blob.parse(await suiBlobObject.content),\n\t\t};\n\t}\n\n\tasync #getCreatedBlob(digest: string) {\n\t\tconst blobType = await this.getBlobType();\n\t\tconst {\n\t\t\ttransaction: { effects },\n\t\t} = await this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn Blob.parse(await suiBlobObject.content);\n\t}\n\n\tasync certificateFromConfirmations({\n\t\tconfirmations,\n\t\tblobId,\n\t\tdeletable,\n\t\tblobObjectId,\n\t}: Extract<\n\t\tCertifyBlobOptions,\n\t\t{ confirmations: unknown[] }\n\t>): Promise<ProtocolMessageCertificate> {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tif (confirmations.length !== systemState.committee.members.length) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t'Invalid number of confirmations. Confirmations array must contain an entry for each node',\n\t\t\t);\n\t\t}\n\n\t\tconst confirmationMessage = StorageConfirmation.serialize({\n\t\t\tintent: IntentType.BLOB_CERT_MSG,\n\t\t\tepoch: systemState.committee.epoch,\n\t\t\tmessageContents: {\n\t\t\t\tblobId,\n\t\t\t\tblobType: deletable\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tDeletable: {\n\t\t\t\t\t\t\t\tobjectId: blobObjectId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tPermanent: null,\n\t\t\t\t\t\t},\n\t\t\t},\n\t\t}).toBase64();\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst verifySignature = bindings.getVerifySignature();\n\n\t\tconst filteredConfirmations = confirmations\n\t\t\t.map((confirmation, index) => {\n\t\t\t\tconst isValid =\n\t\t\t\t\tconfirmation?.serializedMessage === confirmationMessage &&\n\t\t\t\t\tverifySignature(\n\t\t\t\t\t\tconfirmation,\n\t\t\t\t\t\tnew Uint8Array(committee.nodes[index].info.public_key.bytes),\n\t\t\t\t\t);\n\n\t\t\t\treturn isValid\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t...confirmation,\n\t\t\t\t\t\t}\n\t\t\t\t\t: null;\n\t\t\t})\n\t\t\t.filter((confirmation) => confirmation !== null);\n\n\t\tif (!isQuorum(filteredConfirmations.length, systemState.committee.members.length)) {\n\t\t\tthrow new NotEnoughBlobConfirmationsError(\n\t\t\t\t`Too many invalid confirmations received for blob (${filteredConfirmations.length} of ${systemState.committee.members.length})`,\n\t\t\t);\n\t\t}\n\n\t\treturn bindings.combineSignatures(\n\t\t\tfilteredConfirmations,\n\t\t\tfilteredConfirmations.map(({ index }) => index),\n\t\t);\n\t}\n\n\t/**\n\t * Certify a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * tx.add(client.certifyBlob({ blobId, blobObjectId, confirmations }));\n\t * ```\n\t */\n\tcertifyBlob({ blobId, blobObjectId, confirmations, certificate, deletable }: CertifyBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst combinedSignature =\n\t\t\t\tcertificate ??\n\t\t\t\t(await this.certificateFromConfirmations({\n\t\t\t\t\tconfirmations,\n\t\t\t\t\tblobId,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tblobObjectId,\n\t\t\t\t}));\n\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\ttx.add(\n\t\t\t\tcertifyBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\tsignature: tx.pure.vector('u8', combinedSignature.signature),\n\t\t\t\t\t\tsignersBitmap: tx.pure.vector(\n\t\t\t\t\t\t\t'u8',\n\t\t\t\t\t\t\tsignersToBitmap(combinedSignature.signers, systemState.committee.members.length),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tmessage: tx.pure.vector('u8', combinedSignature.serializedMessage),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that certifies a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.certifyBlobTransaction({ blobId, blobObjectId, confirmations });\n\t * ```\n\t */\n\tcertifyBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t}) {\n\t\ttransaction.add(this.certifyBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that certifies a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeCertifyBlobTransaction({ blobId, blobObjectId, confirmations, signer });\n\t * ```\n\t */\n\tasync executeCertifyBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t}) {\n\t\tconst transaction = this.certifyBlobTransaction(options);\n\n\t\tconst { digest } = await this.#executeTransaction(transaction, signer, 'certify blob');\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Delete a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * const storage = await client.deleteBlob({ blobObjectId });\n\t * tx.transferObjects([storage], owner);\n\t * ```\n\t */\n\tdeleteBlob({ blobObjectId }: DeleteBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\t\t\tconst storage = tx.add(\n\t\t\t\tdeleteBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn storage;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that deletes a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.deleteBlobTransaction({ blobObjectId, owner });\n\t * ```\n\t */\n\tdeleteBlobTransaction({\n\t\towner,\n\t\tblobObjectId,\n\t\ttransaction = new Transaction(),\n\t}: DeleteBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be returned to */\n\t\towner: string;\n\t}) {\n\t\tconst storage = transaction.add(this.deleteBlob({ blobObjectId }));\n\t\ttransaction.transferObjects([storage], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that deletes a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeDeleteBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeDeleteBlobTransaction({\n\t\tsigner,\n\t\ttransaction = new Transaction(),\n\t\tblobObjectId,\n\t}: DeleteBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tthis.deleteBlobTransaction({\n\t\t\t\tblobObjectId,\n\t\t\t\ttransaction,\n\t\t\t\towner: transaction.getData().sender ?? signer.toSuiAddress(),\n\t\t\t}),\n\t\t\tsigner,\n\t\t\t'delete blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Extend a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\textendBlob({ blobObjectId, epochs, endEpoch, walCoin }: ExtendBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst blob = await this.#objectLoader.load(blobObjectId, Blob);\n\t\t\tconst numEpochs = typeof epochs === 'number' ? epochs : endEpoch - blob.storage.end_epoch;\n\n\t\t\tif (numEpochs <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { storageCost } = await this.storageCost(Number(blob.storage.storage_size), numEpochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, async (coin, tx) => {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\textendBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\t\t\textendedEpochs: numEpochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that extends a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\tasync extendBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: ExtendBlobOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(this.extendBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that extends a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeExtendBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeExtendBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: ExtendBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.extendBlobTransaction(options),\n\t\t\tsigner,\n\t\t\t'extend blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\tasync readBlobAttributes({\n\t\tblobObjectId,\n\t}: {\n\t\tblobObjectId: string;\n\t}): Promise<Record<string, string> | null> {\n\t\tconst response = await this.#suiClient.core.getDynamicField({\n\t\t\tparentId: blobObjectId,\n\t\t\tname: {\n\t\t\t\ttype: 'vector<u8>',\n\t\t\t\tbcs: bcs.string().serialize('metadata').toBytes(),\n\t\t\t},\n\t\t});\n\n\t\tconst parsedMetadata = metadata.Metadata.parse(response.dynamicField.value.bcs);\n\n\t\treturn Object.fromEntries(\n\t\t\tparsedMetadata.metadata.contents.map(({ key, value }) => [key, value]),\n\t\t);\n\t}\n\n\t#writeBlobAttributesForRef({\n\t\tattributes,\n\t\texistingAttributes,\n\t\tblob,\n\t}: {\n\t\tattributes: Record<string, string | null>;\n\t\texistingAttributes: Record<string, string> | null;\n\t\tblob: TransactionObjectArgument;\n\t}) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\tif (!existingAttributes) {\n\t\t\t\ttx.add(\n\t\t\t\t\taddMetadata({\n\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\tmetadata: metadata._new({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tObject.keys(attributes).forEach((key) => {\n\t\t\t\tconst value = attributes[key];\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\tif (existingAttributes && key in existingAttributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tremoveMetadataPair({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\tinsertOrUpdateMetadataPair({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Write attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @example\n\t * ```ts\n\t * tx.add(client.writeBlobAttributes({ blobObjectId, attributes: { key: 'value', keyToRemove: null } }));\n\t * ```\n\t */\n\twriteBlobAttributes({ blobObject, blobObjectId, attributes }: WriteBlobAttributesOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst existingAttributes = blobObjectId\n\t\t\t\t? await this.readBlobAttributes({ blobObjectId })\n\t\t\t\t: null;\n\t\t\tconst blob = blobObject ?? tx.object(blobObjectId);\n\n\t\t\ttx.add(\n\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\tattributes,\n\t\t\t\t\texistingAttributes,\n\t\t\t\t\tblob,\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.writeBlobAttributesTransaction({ blobObjectId, attributes: { key: 'value', keyToRemove: null } });\n\t * ```\n\t */\n\tasync writeBlobAttributesTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: WriteBlobAttributesOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(await this.writeBlobAttributes(options));\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeWriteBlobAttributesTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeWriteBlobAttributesTransaction({\n\t\tsigner,\n\t\t...options\n\t}: WriteBlobAttributesOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.writeBlobAttributesTransaction(options),\n\t\t\tsigner,\n\t\t\t'write blob attributes',\n\t\t);\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Write a sliver to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const res = await client.writeSliver({ blobId, sliverPairIndex, sliverType, sliver });\n\t * ```\n\t */\n\tasync writeSliver({ blobId, sliverPairIndex, sliverType, sliver, signal }: WriteSliverOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, systemState.committee.n_shards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\treturn this.#storageNodeClient.storeSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType, sliver },\n\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t);\n\t}\n\n\t/**\n\t * Write metadata to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const res = await client.writeMetadataToNode({ nodeIndex, blobId, metadata });\n\t * ```\n\t */\n\tasync writeMetadataToNode({ nodeIndex, blobId, metadata, signal }: WriteMetadataOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\treturn retry(\n\t\t\t() =>\n\t\t\t\tthis.#storageNodeClient.storeBlobMetadata(\n\t\t\t\t\t{ blobId, metadata },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t),\n\t\t\t{\n\t\t\t\tcount: 3,\n\t\t\t\tdelay: 1000,\n\t\t\t\tcondition: (error) => error instanceof BlobNotRegisteredError,\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Get a storage confirmation from a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const confirmation = await client.getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId });\n\t * ```\n\t */\n\tasync getStorageConfirmationFromNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tdeletable,\n\t\tobjectId,\n\t\tsignal,\n\t}: GetStorageConfirmationOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\tconst result = deletable\n\t\t\t? await this.#storageNodeClient.getDeletableBlobConfirmation(\n\t\t\t\t\t{ blobId, objectId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t)\n\t\t\t: await this.#storageNodeClient.getPermanentBlobConfirmation(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t);\n\n\t\treturn result?.success?.data?.signed ?? null;\n\t}\n\n\t/**\n\t * Encode a blob into slivers for each node\n\t *\n\t * @example\n\t * ```ts\n\t * const { blobId, metadata, sliversByNode, rootHash } = await client.encodeBlob(blob);\n\t * ```\n\t */\n\tasync encodeBlob(blob: Uint8Array) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst numShards = systemState.committee.n_shards;\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, sliverPairs, rootHash } = bindings.encodeBlob(numShards, blob);\n\n\t\tconst sliversByNodeMap = new Map<number, SliversForNode>();\n\n\t\twhile (sliverPairs.length > 0) {\n\t\t\t// remove from list so we don't preserve references to the original data\n\t\t\tconst { primary, secondary } = sliverPairs.pop()!;\n\t\t\tconst sliverPairIndex = primary.index;\n\n\t\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\t\tif (!sliversByNodeMap.has(node.nodeIndex)) {\n\t\t\t\tsliversByNodeMap.set(node.nodeIndex, { primary: [], secondary: [] });\n\t\t\t}\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.primary.push({\n\t\t\t\tsliverIndex: primary.index,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: SliverData.serialize(primary).toBytes(),\n\t\t\t});\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.secondary.push({\n\t\t\t\tsliverIndex: secondary.index,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: SliverData.serialize(secondary).toBytes(),\n\t\t\t});\n\t\t}\n\n\t\tconst sliversByNode = new Array<SliversForNode>();\n\n\t\tfor (let i = 0; i < systemState.committee.members.length; i++) {\n\t\t\tsliversByNode.push(sliversByNodeMap.get(i) ?? { primary: [], secondary: [] });\n\t\t}\n\n\t\treturn { blobId, metadata, rootHash, sliversByNode };\n\t}\n\n\t/**\n\t * Write slivers to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * await client.writeSliversToNode({ blobId, slivers, signal });\n\t * ```\n\t */\n\tasync writeSliversToNode({ blobId, slivers, signal }: WriteSliversToNodeOptions) {\n\t\tconst controller = new AbortController();\n\t\tconst combinedSignal = signal\n\t\t\t? AbortSignal.any([controller.signal, signal])\n\t\t\t: controller.signal;\n\n\t\tconst primarySliverWrites = slivers.primary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'primary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tconst secondarySliverWrites = slivers.secondary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'secondary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tawait Promise.all([...primarySliverWrites, ...secondarySliverWrites]).catch((error) => {\n\t\t\tcontroller.abort(error);\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @example\n\t * ```ts\n\t * await client.writeEncodedBlobToNodes({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNodes({\n\t\tblobId,\n\t\tmetadata,\n\t\tsliversByNode,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobToNodesOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst controller = new AbortController();\n\t\tlet failures = 0;\n\n\t\tconst confirmations = await Promise.all(\n\t\t\tsliversByNode.map((slivers, nodeIndex) => {\n\t\t\t\treturn this.writeEncodedBlobToNode({\n\t\t\t\t\tblobId,\n\t\t\t\t\tnodeIndex,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tslivers,\n\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t...options,\n\t\t\t\t}).catch(() => {\n\t\t\t\t\tfailures += committee.nodes[nodeIndex].shardIndices.length;\n\n\t\t\t\t\tif (isAboveValidity(failures, systemState.committee.n_shards)) {\n\t\t\t\t\t\tconst error = new NotEnoughBlobConfirmationsError(\n\t\t\t\t\t\t\t`Too many failures while writing blob ${blobId} to nodes`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontroller.abort(error);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\treturn confirmations;\n\t}\n\n\t/**\n\t * Writes a blob to to an upload relay\n\t *\n\t * @example\n\t * ```ts\n\t * await client.writeBlobToUploadRelay({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlobToUploadRelay(options: WriteBlobToUploadRelayOptions): Promise<{\n\t\tblobId: string;\n\t\tcertificate: ProtocolMessageCertificate;\n\t}> {\n\t\tif (!this.#uploadRelayClient) {\n\t\t\tthrow new WalrusClientError('Upload relay not configured');\n\t\t}\n\n\t\treturn this.#uploadRelayClient.writeBlob({\n\t\t\t...options,\n\t\t\trequiresTip: !!this.#uploadRelayConfig?.sendTip,\n\t\t});\n\t}\n\n\t/**\n\t * Write encoded blob to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const res = await client.writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tmetadata,\n\t\tslivers,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobOptions) {\n\t\tawait this.writeMetadataToNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\tmetadata,\n\t\t\tsignal,\n\t\t});\n\n\t\tawait this.writeSliversToNode({ blobId, slivers, signal, nodeIndex });\n\n\t\treturn this.getStorageConfirmationFromNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\t...options,\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @example\n\t * ```ts\n\t * const { blobId, blobObject } = await client.writeBlob({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlob({\n\t\tblob,\n\t\tdeletable,\n\t\tepochs,\n\t\tsigner,\n\t\tsignal,\n\t\towner,\n\t\tattributes,\n\t}: WriteBlobOptions) {\n\t\tif (!this.#uploadRelayConfig) {\n\t\t\tconst encoded = await this.encodeBlob(blob);\n\t\t\tconst blobId = encoded.blobId;\n\t\t\tconst { sliversByNode, metadata, rootHash } = encoded;\n\n\t\t\tconst suiBlobObject = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId,\n\t\t\t\trootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tconst blobObjectId = suiBlobObject.blob.id.id;\n\n\t\t\tconst confirmations = await this.writeEncodedBlobToNodes({\n\t\t\t\tblobId,\n\t\t\t\tmetadata,\n\t\t\t\tsliversByNode,\n\t\t\t\tdeletable,\n\t\t\t\tobjectId: blobObjectId,\n\t\t\t\tsignal,\n\t\t\t});\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tconfirmations,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t} else {\n\t\t\tconst metadata = await this.computeBlobMetadata({\n\t\t\t\tbytes: blob,\n\t\t\t});\n\t\t\tconst blobId = metadata.blobId;\n\n\t\t\tconst transaction = new Transaction();\n\n\t\t\ttransaction.add(\n\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\tsize: blob.length,\n\t\t\t\t\tblobDigest: metadata.blobDigest,\n\t\t\t\t\tnonce: metadata.nonce,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst registerResult = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\ttransaction,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\t\tdigest: registerResult.digest,\n\t\t\t});\n\n\t\t\tconst result = await this.writeBlobToUploadRelay({\n\t\t\t\tblobId,\n\t\t\t\tblob,\n\t\t\t\tnonce: metadata.nonce,\n\t\t\t\ttxDigest: registerResult.digest,\n\t\t\t\tsignal,\n\t\t\t\tdeletable,\n\t\t\t\tblobObjectId: registerResult.blob.id.id,\n\t\t\t\tencodingType: metadata.metadata.encodingType as EncodingType,\n\t\t\t});\n\n\t\t\tconst certificate = result.certificate;\n\t\t\tconst blobObjectId = registerResult.blob.id.id;\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tcertificate,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t}\n\t}\n\n\tasync writeQuilt({ blobs, ...options }: WriteQuiltOptions) {\n\t\tconst encoded = await this.encodeQuilt({ blobs });\n\t\tconst result = await this.writeBlob({\n\t\t\t...options,\n\t\t\tblob: encoded.quilt,\n\t\t\tattributes: {\n\t\t\t\t_walrusBlobType: 'quilt',\n\t\t\t\t...options.attributes,\n\t\t\t},\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tindex: {\n\t\t\t\t...encoded.index,\n\t\t\t\tpatches: encoded.index.patches.map((patch) => ({\n\t\t\t\t\t...patch,\n\t\t\t\t\tpatchId: encodeQuiltPatchId({\n\t\t\t\t\t\tquiltId: result.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t})),\n\t\t\t},\n\t\t};\n\t}\n\n\tasync encodeQuilt({\n\t\tblobs,\n\t}: {\n\t\tblobs: {\n\t\t\tcontents: Uint8Array;\n\t\t\tidentifier: string;\n\t\t\ttags?: Record<string, string>;\n\t\t}[];\n\t}) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encoded = encodeQuilt({\n\t\t\tblobs,\n\t\t\tnumShards: systemState.committee.n_shards,\n\t\t});\n\n\t\treturn encoded;\n\t}\n\n\tasync #executeTransaction(transaction: Transaction, signer: Signer, action: string) {\n\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\n\t\tconst { digest, effects } = await signer.signAndExecuteTransaction({\n\t\t\ttransaction,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (effects?.status.error) {\n\t\t\tthrow new WalrusClientError(`Failed to ${action} (${digest}): ${effects?.status.error}`);\n\t\t}\n\n\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\treturn { digest, effects };\n\t}\n\n\tasync #getCommittee(committee: InferBcsType<typeof Committee>) {\n\t\tconst stakingPool = await this.#stakingPool(committee);\n\t\tconst shardIndicesByNodeId = getShardIndicesByNodeId(committee);\n\n\t\tconst byShardIndex = new Map<number, StorageNode>();\n\t\tconst nodes = stakingPool.map(({ node_info }, nodeIndex) => {\n\t\t\tconst shardIndices = shardIndicesByNodeId.get(node_info.node_id) ?? [];\n\t\t\tconst node: StorageNode = {\n\t\t\t\tid: node_info.node_id,\n\t\t\t\tinfo: node_info,\n\t\t\t\tnetworkUrl: `https://${node_info.network_address}`,\n\t\t\t\tshardIndices,\n\t\t\t\tnodeIndex,\n\t\t\t};\n\n\t\t\tfor (const shardIndex of shardIndices) {\n\t\t\t\tbyShardIndex.set(shardIndex, node);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\n\t\treturn {\n\t\t\tbyShardIndex,\n\t\t\tnodes,\n\t\t};\n\t}\n\n\t#getActiveCommittee() {\n\t\treturn this.#cache.read(['getActiveCommittee'], async () => {\n\t\t\tconst stakingState = await this.stakingState();\n\t\t\treturn this.#getCommittee(stakingState.committee);\n\t\t});\n\t}\n\n\tasync #stakingPool(committee: InferBcsType<typeof Committee>) {\n\t\tconst nodeIds = committee[0].contents.map((node) => node.key);\n\t\treturn this.#objectLoader.loadManyOrThrow(nodeIds, StakingPool);\n\t}\n\n\tasync #getNodeByShardIndex(committeeInfo: CommitteeInfo, index: number) {\n\t\tconst node = committeeInfo.byShardIndex.get(index);\n\t\tif (!node) {\n\t\t\tthrow new WalrusClientError(`Node for shard index ${index} not found`);\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reset cached data in the client\n\t *\n\t * @example\n\t * ```ts\n\t * client.reset();\n\t * ```\n\t */\n\treset() {\n\t\tthis.#objectLoader.clearAll();\n\t\tthis.#cache.clear();\n\t}\n\n\t#retryOnPossibleEpochChange<T extends (...args: any[]) => Promise<any>>(fn: T): T {\n\t\treturn (async (...args: Parameters<T>) => {\n\t\t\ttry {\n\t\t\t\treturn await fn.apply(this, args);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof RetryableWalrusClientError) {\n\t\t\t\t\tthis.reset();\n\t\t\t\t\treturn await fn.apply(this, args);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tasync getBlob({ blobId }: { blobId: string }) {\n\t\treturn new WalrusBlob({\n\t\t\treader: new BlobReader({\n\t\t\t\tclient: this,\n\t\t\t\tblobId,\n\t\t\t\tnumShards: (await this.systemState()).committee.n_shards,\n\t\t\t}),\n\t\t\tclient: this,\n\t\t});\n\t}\n\n\tasync getFiles({ ids }: { ids: string[] }) {\n\t\tconst readersByBlobId = new Map<string, BlobReader>();\n\t\tconst quiltReadersByBlobId = new Map<string, QuiltReader>();\n\t\tconst parsedIds = ids.map((id) => parseWalrusId(id));\n\t\tconst numShards = (await this.systemState()).committee.n_shards;\n\n\t\tfor (const id of parsedIds) {\n\t\t\tconst blobId = id.kind === 'blob' ? id.id : id.id.quiltId;\n\t\t\tif (!readersByBlobId.has(blobId)) {\n\t\t\t\treadersByBlobId.set(\n\t\t\t\t\tblobId,\n\t\t\t\t\tnew BlobReader({\n\t\t\t\t\t\tclient: this,\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnumShards,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (id.kind === 'quiltPatch') {\n\t\t\t\tif (!quiltReadersByBlobId.has(blobId)) {\n\t\t\t\t\tquiltReadersByBlobId.set(\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnew QuiltReader({\n\t\t\t\t\t\t\tblob: readersByBlobId.get(blobId)!,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parsedIds.map((id) => {\n\t\t\tif (id.kind === 'blob') {\n\t\t\t\treturn new WalrusFile({\n\t\t\t\t\treader: readersByBlobId.get(id.id)!,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new WalrusFile({\n\t\t\t\treader: new QuiltFileReader({\n\t\t\t\t\tquilt: quiltReadersByBlobId.get(id.id.quiltId)!,\n\t\t\t\t\tsliverIndex: id.id.patchId.startIndex,\n\t\t\t\t}),\n\t\t\t});\n\t\t});\n\t}\n\n\tasync writeFiles({ files, ...options }: WriteFilesOptions) {\n\t\tconst { blobId, index, blobObject } = await this.writeQuilt({\n\t\t\t...options,\n\t\t\tblobs: await Promise.all(\n\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t})),\n\t\t\t),\n\t\t});\n\n\t\treturn index.patches.map((patch) => ({\n\t\t\tid: patch.patchId,\n\t\t\tblobId,\n\t\t\tblobObject,\n\t\t}));\n\t}\n\n\twriteFilesFlow({ files }: WriteFilesFlowOptions): WriteFilesFlow {\n\t\tconst encode = async () => {\n\t\t\tconst { quilt, index } = await this.encodeQuilt({\n\t\t\t\tblobs: await Promise.all(\n\t\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t\t})),\n\t\t\t\t),\n\t\t\t});\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: quilt,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(quilt);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: quilt.length,\n\t\t\t\tdata: this.#uploadRelayClient ? quilt : undefined,\n\t\t\t\tindex,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, index, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteFilesFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t_walrusBlobType: 'quilt',\n\t\t\t\t\t\t\t...attributes,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tindex,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ index, data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteFilesFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tindex,\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tindex,\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function listFiles({ index, blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn index.patches.map((patch) => ({\n\t\t\t\tid: encodeQuiltPatchId({\n\t\t\t\t\tquiltId: metadata.blobId,\n\t\t\t\t\tpatchId: {\n\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t}));\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tlistFiles?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteFilesFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteFilesFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tlistFiles: async () => {\n\t\t\t\treturn listFiles(getResults('certify', 'listFiles'));\n\t\t\t},\n\t\t};\n\t}\n\n\twriteBlobFlow({ blob }: WriteBlobFlowOptions): WriteBlobFlow {\n\t\tconst encode = async () => {\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: blob,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(blob);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: blob.length,\n\t\t\t\tdata: this.#uploadRelayClient ? blob : undefined,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteBlobFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteBlobFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function getBlob({ blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn {\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t};\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tgetBlob?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteBlobFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteBlobFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tgetBlob: async () => {\n\t\t\t\treturn getBlob(getResults('certify', 'getBlob'));\n\t\t\t},\n\t\t};\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AA0BA,QAAIA,eAEJ,WAAY;AACV,eAASA,YAAW,aAAa,SAAS;AACxC,YAAI,OAAO,gBAAgB,YAAY;AACrC,gBAAM,IAAI,UAAU,mEAAmE,4DAA4D,cAAc,IAAI;AAAA,QACvK;AAEA,aAAK,eAAe;AACpB,aAAK,gBAAgB,qBAAqB,OAAO;AACjD,aAAK,mBAAmB,wBAAwB,OAAO;AACvD,aAAK,cAAc,mBAAmB,OAAO;AAC7C,aAAK,YAAY,iBAAiB,OAAO;AACzC,aAAK,SAAS;AACd,aAAK,OAAO,aAAa,OAAO;AAAA,MAClC;AAGA,UAAI,SAASA,YAAW;AAKxB,aAAO,OAAO,SAAS,KAAK,KAAK;AAC/B,YAAI,QAAQ,QAAQ,QAAQ,QAAW;AACrC,gBAAM,IAAI,UAAU,8DAA8D,cAAc,OAAO,GAAG,IAAI,IAAI;AAAA,QACpH;AAEA,YAAI,QAAQ,gBAAgB,IAAI;AAChC,YAAI,WAAW,KAAK;AACpB,YAAI;AAEJ,YAAI,UAAU;AACZ,qBAAW,KAAK,YAAY,GAAG;AAC/B,cAAI,gBAAgB,SAAS,IAAI,QAAQ;AAEzC,cAAI,eAAe;AACjB,gBAAI,YAAY,MAAM,cAAc,MAAM,YAAY,CAAC;AACvD,mBAAO,IAAI,QAAQ,SAAU,SAAS;AACpC,wBAAU,KAAK,WAAY;AACzB,wBAAQ,aAAa;AAAA,cACvB,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAAA,QACF;AAIA,cAAM,KAAK,KAAK,GAAG;AACnB,YAAI,UAAU,IAAI,QAAQ,SAAU,SAAS,QAAQ;AACnD,gBAAM,UAAU,KAAK;AAAA,YACnB;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAED,YAAI,UAAU;AACZ,mBAAS,IAAI,UAAU,OAAO;AAAA,QAChC;AAEA,eAAO;AAAA,MACT;AAuBA,aAAO,WAAW,SAAS,SAAS,MAAM;AACxC,YAAI,CAAC,YAAY,IAAI,GAAG;AACtB,gBAAM,IAAI,UAAU,oEAAoE,cAAc,OAAO,IAAI;AAAA,QACnH;AAGA,YAAI,eAAe,CAAC;AAEpB,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,uBAAa,KAAK,KAAK,KAAK,KAAK,CAAC,CAAC,EAAE,OAAO,EAAE,SAAU,OAAO;AAC7D,mBAAO;AAAA,UACT,CAAC,CAAC;AAAA,QACJ;AAEA,eAAO,QAAQ,IAAI,YAAY;AAAA,MACjC;AAOA,aAAO,QAAQ,SAAS,MAAM,KAAK;AACjC,YAAI,WAAW,KAAK;AAEpB,YAAI,UAAU;AACZ,cAAI,WAAW,KAAK,YAAY,GAAG;AAEnC,mBAAS,QAAQ,EAAE,QAAQ;AAAA,QAC7B;AAEA,eAAO;AAAA,MACT;AAQA,aAAO,WAAW,SAAS,WAAW;AACpC,YAAI,WAAW,KAAK;AAEpB,YAAI,UAAU;AACZ,mBAAS,MAAM;AAAA,QACjB;AAEA,eAAO;AAAA,MACT;AASA,aAAO,QAAQ,SAAS,MAAM,KAAK,OAAO;AACxC,YAAI,WAAW,KAAK;AAEpB,YAAI,UAAU;AACZ,cAAI,WAAW,KAAK,YAAY,GAAG;AAGnC,cAAI,SAAS,IAAI,QAAQ,MAAM,QAAW;AAGxC,gBAAI;AAEJ,gBAAI,iBAAiB,OAAO;AAC1B,wBAAU,QAAQ,OAAO,KAAK;AAG9B,sBAAQ,OAAO,EAAE,WAAY;AAAA,cAAC,CAAC;AAAA,YACjC,OAAO;AACL,wBAAU,QAAQ,QAAQ,KAAK;AAAA,YACjC;AAEA,qBAAS,IAAI,UAAU,OAAO;AAAA,UAChC;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAQA,aAAOA;AAAA,IACT,GAAE;AA4BF,QAAI,wBAAwB,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,aAAa,SAAU,IAAI;AAChH,UAAI,CAAC,iBAAiB;AACpB,0BAAkB,QAAQ,QAAQ;AAAA,MACpC;AAEA,sBAAgB,KAAK,WAAY;AAC/B,gBAAQ,SAAS,EAAE;AAAA,MACrB,CAAC;AAAA,IACH,IAAI,OAAO,iBAAiB,aAAa,SAAU,IAAI;AACrD,mBAAa,EAAE;AAAA,IACjB,IAAI,SAAU,IAAI;AAChB,iBAAW,EAAE;AAAA,IACf;AAEA,QAAI;AAIJ,aAAS,gBAAgB,QAAQ;AAG/B,UAAI,gBAAgB,OAAO;AAE3B,UAAI,kBAAkB,QAAQ,CAAC,cAAc,iBAAiB,cAAc,KAAK,SAAS,OAAO,eAAe;AAC9G,eAAO;AAAA,MACT;AAGA,UAAI,WAAW;AAAA,QACb,eAAe;AAAA,QACf,MAAM,CAAC;AAAA,QACP,WAAW,CAAC;AAAA,MACd;AAEA,aAAO,SAAS;AAEhB,aAAO,iBAAiB,WAAY;AAClC,sBAAc,QAAQ,QAAQ;AAAA,MAChC,CAAC;AAED,aAAO;AAAA,IACT;AAEA,aAAS,cAAc,QAAQ,OAAO;AAEpC,YAAM,gBAAgB;AAEtB,UAAI,MAAM,KAAK,WAAW,GAAG;AAC3B,yBAAiB,KAAK;AACtB;AAAA,MACF;AAIA,UAAI;AAEJ,UAAI;AACF,uBAAe,OAAO,aAAa,MAAM,IAAI;AAAA,MAC/C,SAAS,GAAG;AACV,eAAO,eAAe,QAAQ,OAAO,IAAI,UAAU,kIAAuI,4BAA4B,OAAO,CAAC,IAAI,IAAI,CAAC;AAAA,MACzO;AAGA,UAAI,CAAC,gBAAgB,OAAO,aAAa,SAAS,YAAY;AAC5D,eAAO,eAAe,QAAQ,OAAO,IAAI,UAAU,sIAA2I,2BAA2B,OAAO,YAAY,IAAI,IAAI,CAAC;AAAA,MACvP;AAGA,mBAAa,KAAK,SAAU,QAAQ;AAElC,YAAI,CAAC,YAAY,MAAM,GAAG;AACxB,gBAAM,IAAI,UAAU,sIAA2I,uCAAuC,OAAO,MAAM,IAAI,IAAI;AAAA,QAC7N;AAEA,YAAI,OAAO,WAAW,MAAM,KAAK,QAAQ;AACvC,gBAAM,IAAI,UAAU,+MAA8N,gBAAgB,OAAO,MAAM,IAAI,MAAM,kBAAkB,OAAO,MAAM,EAAE;AAAA,QAC5T;AAGA,yBAAiB,KAAK;AAEtB,iBAAS,IAAI,GAAG,IAAI,MAAM,UAAU,QAAQ,KAAK;AAC/C,cAAI,SAAS,OAAO,CAAC;AAErB,cAAI,kBAAkB,OAAO;AAC3B,kBAAM,UAAU,CAAC,EAAE,OAAO,MAAM;AAAA,UAClC,OAAO;AACL,kBAAM,UAAU,CAAC,EAAE,QAAQ,MAAM;AAAA,UACnC;AAAA,QACF;AAAA,MACF,CAAC,EAAE,OAAO,EAAE,SAAU,OAAO;AAC3B,uBAAe,QAAQ,OAAO,KAAK;AAAA,MACrC,CAAC;AAAA,IACH;AAIA,aAAS,eAAe,QAAQ,OAAO,OAAO;AAE5C,uBAAiB,KAAK;AAEtB,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK,QAAQ,KAAK;AAC1C,eAAO,MAAM,MAAM,KAAK,CAAC,CAAC;AAC1B,cAAM,UAAU,CAAC,EAAE,OAAO,KAAK;AAAA,MACjC;AAAA,IACF;AAGA,aAAS,iBAAiB,OAAO;AAC/B,UAAI,MAAM,WAAW;AACnB,iBAAS,IAAI,GAAG,IAAI,MAAM,UAAU,QAAQ,KAAK;AAC/C,gBAAM,UAAU,CAAC,EAAE;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAGA,aAAS,qBAAqB,SAAS;AACrC,UAAI,cAAc,CAAC,WAAW,QAAQ,UAAU;AAEhD,UAAI,CAAC,aAAa;AAChB,eAAO;AAAA,MACT;AAEA,UAAI,eAAe,WAAW,QAAQ;AAEtC,UAAI,iBAAiB,QAAW;AAC9B,eAAO;AAAA,MACT;AAEA,UAAI,OAAO,iBAAiB,YAAY,eAAe,GAAG;AACxD,cAAM,IAAI,UAAU,6CAA6C,YAAY;AAAA,MAC/E;AAEA,aAAO;AAAA,IACT;AAGA,aAAS,wBAAwB,SAAS;AACxC,UAAI,kBAAkB,WAAW,QAAQ;AAEzC,UAAI,oBAAoB,QAAW;AACjC,eAAO;AAAA,MACT;AAEA,UAAI,OAAO,oBAAoB,YAAY;AACzC,cAAM,IAAI,UAAU,yCAAyC,eAAe;AAAA,MAC9E;AAEA,aAAO;AAAA,IACT;AAGA,aAAS,mBAAmB,SAAS;AACnC,UAAI,aAAa,WAAW,QAAQ;AAEpC,UAAI,eAAe,QAAW;AAC5B,eAAO,SAAU,KAAK;AACpB,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,UAAI,OAAO,eAAe,YAAY;AACpC,cAAM,IAAI,UAAU,oCAAoC,UAAU;AAAA,MACpE;AAEA,aAAO;AAAA,IACT;AAGA,aAAS,iBAAiB,SAAS;AACjC,UAAI,cAAc,CAAC,WAAW,QAAQ,UAAU;AAEhD,UAAI,CAAC,aAAa;AAChB,eAAO;AAAA,MACT;AAEA,UAAI,WAAW,WAAW,QAAQ;AAElC,UAAI,aAAa,QAAW;AAC1B,eAAO,oBAAI,IAAI;AAAA,MACjB;AAEA,UAAI,aAAa,MAAM;AACrB,YAAI,iBAAiB,CAAC,OAAO,OAAO,UAAU,OAAO;AACrD,YAAI,mBAAmB,eAAe,OAAO,SAAU,QAAQ;AAC7D,iBAAO,YAAY,OAAO,SAAS,MAAM,MAAM;AAAA,QACjD,CAAC;AAED,YAAI,iBAAiB,WAAW,GAAG;AACjC,gBAAM,IAAI,UAAU,sCAAsC,iBAAiB,KAAK,IAAI,CAAC;AAAA,QACvF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,aAAS,aAAa,SAAS;AAC7B,UAAI,WAAW,QAAQ,MAAM;AAC3B,eAAO,QAAQ;AAAA,MACjB;AAEA,aAAO;AAAA,IACT;AAGA,aAAS,YAAY,GAAG;AACtB,aAAO,OAAO,MAAM,YAAY,MAAM,QAAQ,OAAO,EAAE,WAAW,aAAa,EAAE,WAAW,KAAK,EAAE,SAAS,KAAK,OAAO,UAAU,eAAe,KAAK,GAAG,EAAE,SAAS,CAAC;AAAA,IACvK;AAEA,WAAO,UAAUA;AAAA;AAAA;;;AClbV,IAAM,gCAAgC;EAC5C,gBAAgB;EAChB,eAAe;EACf,aAAa;IACZ;IACA;IACA;IACA;EACD;AACD;AAEO,IAAM,gCAAgC;EAC5C,gBAAgB;EAChB,eAAe;AAChB;AAGO,IAAM,sBAA0D;EACtE,aAAa;EACb,WAAW;EACX,WAAW;EACX,SAAS;AACV;;;ACpBA,IAAM,sBAAsB,oBAAoB,KAAK;AACrD,IAAM,wBAAwB,oBAAoB,KAAK;AACvD,IAAM,qBAAqB,oBAAoB,KAAK;AAI7C,SAAS,iBAAiB,SAAgD;AAChF,QAAM,YAAY,OAAO,YAAY,WAAW,kBAAkB,aAAa,OAAO,IAAI;AAE1F,MAAI,QAAQ,WAAW;AACtB,WAAO,OAAI;EACZ,WAAW,SAAS,WAAW;AAC9B,WAAO,OAAI;EACZ,WAAW,SAAS,WAAW;AAC9B,WAAO,OAAI;EACZ,WAAW,SAAS,WAAW;AAC9B,WAAO,OAAI;EACZ,WAAW,UAAU,WAAW;AAC/B,WAAO,OAAI;EACZ,WAAW,UAAU,WAAW;AAC/B,WAAO,OAAI;EACZ,WAAW,aAAa,WAAW;AAClC,WAAO,OAAI;EACZ,WAAW,UAAU,WAAW;AAC/B,WAAO,OAAI;EACZ,WAAW,YAAY,WAAW;AACjC,UAAM,OAAO,iBAAiB,UAAU,MAAM;AAC9C,WAAO,OAAO,OAAI,OAAO,IAAI,IAAI;EAClC,WAAW,YAAY,WAAW;AACjC,UAAM,YAAY,UAAU;AAC5B,UAAM,MAAM,oBAAoB,UAAU,OAAO,OAAO;AAExD,QAAI,QAAQ,qBAAqB;AAChC,WACE,UAAU,WAAW,WAAW,UAAU,WAAW,aACtD,UAAU,SAAS,UAClB;AACD,eAAO,OAAI;MACZ;AAEA,UAAI,UAAU,WAAW,YAAY,UAAU,SAAS,UAAU;AACjE,cAAM,OAAO,iBAAiB,UAAU,WAAW,CAAC,CAAE;AACtD,eAAO,OAAO,OAAI,OAAO,IAAI,IAAI;MAClC;IACD;AAEA,QAAI,QAAQ,yBAAyB,UAAU,WAAW,YAAY,UAAU,SAAS,MAAM;AAC9F,aAAO,OAAI;IACZ;EACD;AAEA,SAAO;AACR;AAEO,SAAS,uBACf,MACA,UACA,gBACC;AACD,QAAM,SAAS,MAAM,QAAQ,IAAI,IAAI,KAAK,SAAS,OAAO,KAAK,IAAI,EAAE;AACrE,MAAI,kBAAkB,WAAW,eAAe,QAAQ;AACvD,UAAM,IAAI;MACT,yCAAyC,eAAe,MAAM,SAAS,MAAM;IAC9E;EACD;AAEA,QAAM,iBAAwC,CAAC;AAE/C,MAAI,QAAQ;AACZ,aAAW,CAAC,GAAG,OAAO,KAAK,SAAS,QAAQ,GAAG;AAC9C,QAAI,YAAY,GAAG,qBAAqB,yBAAyB;AAChE,qBAAe,KAAK,CAAC,OAAO,GAAG,OAAO,SAAS,CAAC;AAChD;IACD;AAEA,QAAI,YAAY,GAAG,qBAAqB,oBAAoB;AAC3D,qBAAe,KAAK,CAAC,OAAO,GAAG,OAAO,OAAO,CAAC;AAC9C;IACD;AAEA,QAAI,YAAY,GAAG,qBAAqB,kBAAkB;AACzD,qBAAe,KAAK,CAAC,OAAO,GAAG,OAAO,MAAM,CAAC;AAC7C;IACD;AAEA,QAAI,YAAY,GAAG,kBAAkB,gCAAgC;AACpE,qBAAe,KAAK,CAAC,OAAO,GAAG,OAAO,OAAO,CAAC;AAC9C;IACD;AAEA,QAAI;AACJ,QAAI,MAAM,QAAQ,IAAI,GAAG;AACxB,UAAI,SAAS,KAAK,QAAQ;AACzB,cAAM,IAAI;UACT,kDAAkD,QAAQ,CAAC,SAAS,KAAK,MAAM;QAChF;MACD;AACA,YAAM,KAAK,KAAK;IACjB,OAAO;AACN,UAAI,CAAC,gBAAgB;AACpB,cAAM,IAAI,MAAM,6CAA6C;MAC9D;AACA,YAAM,OAAO,eAAe,KAAK;AACjC,YAAM,KAAK,IAAyB;AAEpC,UAAI,OAAO,MAAM;AAChB,cAAM,IAAI,MAAM,aAAa,IAAI,cAAc;MAChD;IACD;AAEA,aAAS;AAET,QAAI,OAAO,QAAQ,cAAc,WAAW,GAAG,GAAG;AACjD,qBAAe,KAAK,GAA0B;AAC9C;IACD;AAEA,UAAM,OAAO,SAAS,CAAC;AACvB,UAAM,UAAU,iBAAiB,IAAI;AAErC,QAAI,SAAS;AACZ,YAAM,QAAQ,QAAQ,UAAU,GAAY;AAC5C,qBAAe,KAAK,CAAC,OAAO,GAAG,KAAK,KAAK,CAAC;AAC1C;IACD,WAAW,OAAO,QAAQ,UAAU;AACnC,qBAAe,KAAK,CAAC,OAAO,GAAG,OAAO,GAAG,CAAC;AAC1C;IACD;AAEA,UAAM,IAAI,MAAM,oBAAoB,UAAU,GAAG,CAAC,aAAa,IAAI,EAAE;EACtE;AAEA,SAAO;AACR;AAEO,IAAM,aAAN,cAGG,UAAmB;AAAC;AAEvB,IAAM,WAAN,cAGG,QAAiB;AAAC;AAErB,IAAM,YAAN,cAGG,SAAkB;AAAC;AAE7B,SAAS,UAAU,KAAc;AAChC,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,KAAK,UAAU,KAAK,CAACC,SAAiBA,IAAG;EACjD;AACA,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,IAAI,SAAS;EACrB;AAEA,SAAO;AACR;;;AChKA,IAAM,cAAc;AACb,IAAM,MAAM,IAAI,WAAW;EACjC,MAAM,GAAG,WAAW;EACpB,QAAQ;IACP,IAAI,OAAI;EACT;AACD,CAAC;;;ACND,IAAMC,eAAc;AACb,IAAM,UAAU,IAAI,WAAW;EACrC,MAAM,GAAGA,YAAW;EACpB,QAAQ;IACP,IAAW;IACX,aAAa,OAAI,IAAI;IACrB,WAAW,OAAI,IAAI;IACnB,cAAc,OAAI,IAAI;EACvB;AACD,CAAC;;;ACRD,IAAMC,eAAc;AACb,IAAM,OAAO,IAAI,WAAW;EAClC,MAAM,GAAGA,YAAW;EACpB,QAAQ;IACP,IAAW;IACX,kBAAkB,OAAI,IAAI;IAC1B,SAAS,OAAI,KAAK;IAClB,MAAM,OAAI,IAAI;IACd,eAAe,OAAI,GAAG;IACtB,iBAAiB,OAAI,OAAO,OAAI,IAAI,CAAC;IACrC,SAA0B;IAC1B,WAAW,OAAI,KAAK;EACrB;AACD,CAAC;AACM,IAAM,mBAAmB,IAAI,WAAW;EAC9C,MAAM,GAAGA,YAAW;EACpB,QAAQ;IACP,eAAe,OAAI,GAAG;IACtB,MAAM,OAAI,IAAI;IACd,WAAW,OAAI,KAAK;EACrB;AACD,CAAC;AAqQM,SAAS,YAAY,SAA6B;AACxD,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB,GAAG,cAAc;EAClB;AACA,QAAM,iBAAiB,CAAC,QAAQ,UAAU;AAC1C,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;AA8EO,SAAS,2BAA2B,SAA4C;AACtF,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB;IACA;EACD;AACA,QAAM,iBAAiB,CAAC,QAAQ,OAAO,OAAO;AAC9C,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;AAgBO,SAAS,mBAAmB,SAAoC;AACtE,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB;EACD;AACA,QAAM,iBAAiB,CAAC,QAAQ,KAAK;AACrC,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;;;ACtaA,IAAMC,eAAc;AAEb,SAAS,SAAyD,gBAAwB;AAChG,SAAO,IAAI,WAAW;IACrB,MAAM,GAAGA,YAAW,WAAW,eAAe,CAAC,EAAE,IAAiB,KAAK,eAAe,CAAC,EAAE,IAAiB;IAC1G,QAAQ;MACP,KAAK,eAAe,CAAC;MACrB,OAAO,eAAe,CAAC;IACxB;EACD,CAAC;AACF;AAUO,SAAS,UAA0D,gBAAwB;AACjG,SAAO,IAAI,WAAW;IACrB,MAAM,GAAGA,YAAW,YAAY,eAAe,CAAC,EAAE,IAAiB,KAAK,eAAe,CAAC,EAAE,IAAiB;IAC3G,QAAQ;MACP,UAAU,OAAI,OAAO,MAAM,eAAe,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;IACjE;EACD,CAAC;AACF;;;ACtBA,IAAMC,eAAc;AACb,IAAM,WAAW,IAAI,WAAW;EACtC,MAAM,GAAGA,YAAW;EACpB,QAAQ;IACP,UAAkB,OAAO,OAAI,OAAO,GAAG,OAAI,OAAO,CAAC;EACpD;AACD,CAAC;AAMM,SAAS,KAAK,UAAsB,CAAC,GAAG;AAC9C,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;EACX,CAAC;AACH;;;AChBA,IAAMC,eAAc;AACb,IAAM,cAAc,IAAI,WAAW;EACzC,MAAM,GAAGA,YAAW;EACpB,QAAQ;;IAEP,IAAW;;IAEX,MAAM,OAAI,IAAI;EACf;AACD,CAAC;;;ACZD,IAAMC,eAAc;AACb,IAAM,gBAAgB,IAAI,WAAW;EAC3C,MAAM,GAAGA,YAAW;EACpB,QAAQ;IACP,IAAW;EACZ;AACD,CAAC;AACM,IAAM,MAAM,IAAI,UAAU,EAAE,MAAM,GAAGA,YAAW,SAAS,QAAQ,CAAC,OAAI,KAAK,CAAC,EAAE,CAAC;;;ACJtF,IAAMC,eAAc;AACb,IAAM,YAAY,IAAI,UAAU;EACtC,MAAM,GAAGA,YAAW;EACpB,QAAQ,CAAS,OAAO,OAAI,SAAS,OAAI,OAAO,OAAI,IAAI,CAAC,CAAC,CAAC;AAC5D,CAAC;;;ACdD,IAAMC,eAAc;AACb,IAAM,cAAc,IAAI,WAAW;EACzC,MAAM,GAAGA,YAAW;EACpB,QAAQ;;IAEP,qBAAqB,OAAI,IAAI;;IAE7B,6BAA6B,OAAI,IAAI;;IAErC,2BAA2B,OAAI,IAAI;EACpC;AACD,CAAC;;;ACPD,IAAMC,gBAAc;AAEb,IAAM,aAAa,IAAI,SAAS;EACtC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,iBAAiB,OAAI,IAAI;IACzB,iBAAiB,OAAI,IAAI;IACzB,oBAAoB,OAAI,IAAI;EAC7B;AACD,CAAC;AACM,IAAM,iBAAiB,IAAI,WAAW;EAC5C,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,UAAU,OAAI,IAAI;;IAElB,gBAAgB,OAAI,IAAI;;;;;IAKxB,mBAAmB,OAAI,IAAI;;;;;;;;IAQ3B,OAAoB;;;;;IAKpB,OAAO,OAAI,IAAI;;IAEf,YAA2B;;IAE3B,gBAAgB,OAAI,OAAiB,SAAS;;IAE9C,WAAqB;;IAErB,oBAA8B;;IAE9B,mBAAmB,OAAI,OAAwB,WAAW;;IAE1D,aAAa;;;;;;;IAOb,wBAAuC;EACxC;AACD,CAAC;;;ACxDD,IAAMC,gBAAc;AACb,IAAM,UAAU,IAAI,WAAW;EACrC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,OAAO,OAAI,OAAO,OAAI,GAAG,CAAC;EAC3B;AACD,CAAC;;;ACLD,IAAMC,gBAAc;AACb,IAAM,uBAAuB,IAAI,WAAW;EAClD,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,yBAAyB,OAAI,IAAI;IACjC,OAAO,OAAI,IAAI;EAChB;AACD,CAAC;AACM,IAAM,YAAY,IAAI,WAAW;EACvC,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,SAAS,OAAI,KAAK;;IAElB,mCAAmC,OAAI,IAAI;EAC5C;AACD,CAAC;AACM,IAAM,8BAA8B,IAAI,WAAW;EACzD,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,uBAAuB,OAAI,OAAO,SAAS;;IAE3C,2BAAmC,OAAO,WAAW,OAAI,IAAI,CAAC;EAC/D;AACD,CAAC;;;ACvBD,IAAMC,gBAAc;AACb,IAAM,kBAAkB,IAAI,WAAW;EAC7C,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,MAAM,OAAI,OAAO;IACjB,SAAS,OAAI;IACb,iBAAiB,OAAI,OAAO;IAC5B,YAAsB;IACtB,uBAAuB,OAAI,OAAiB,OAAO;IACnD,oBAAoB,OAAI,OAAO,OAAI,GAAG,CAAC;IACvC,UAAyB;EAC1B;AACD,CAAC;AACM,IAAM,iBAAiB,IAAI,WAAW;EAC5C,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,IAAW;IACX,SAAS,OAAI;IACb,sBAAsB,OAAI,IAAI;IAC9B,6BAA6B,OAAI,OAAkB,oBAAoB;;IAEvE,gBAAgB,OAAI,KAAK;;IAEzB,oBAAoB,OAAI,IAAI;;IAE5B,gBAAgB,OAAI,IAAI;EACzB;AACD,CAAC;;;AChCD,IAAMC,gBAAc;AACb,IAAM,gBAAgB,IAAI,UAAU;EAC1C,MAAM,GAAGA,aAAW;EACpB,QAAQ,CAAS,OAAO,OAAI,IAAI,GAAG,OAAI,IAAI,CAAC,CAAC;AAC9C,CAAC;;;ACiBD,IAAMC,gBAAc;AACb,IAAM,QAAQ,IAAI,WAAW;EACnC,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,IAAW;;IAEX,MAAM,OAAI,IAAI;EACf;AACD,CAAC;;;ACxBD,IAAMC,gBAAc;AACb,IAAM,UAAU,IAAI,WAAW;EACrC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,OAAO,OAAI,IAAI;EAChB;AACD,CAAC;;;ACVD,IAAMC,gBAAc;AAKb,IAAM,gBAAgB,IAAI,SAAS;EACzC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,QAAQ,OAAI;IACZ,QAAQ,OAAI;EACb;AACD,CAAC;AAKM,IAAM,aAAa,IAAI,SAAS;EACtC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,SAAS,OAAI;IACb,UAAU,OAAI;EACf;AACD,CAAC;;;ACED,IAAMC,gBAAc;AACb,IAAM,MAAM,IAAI,WAAW;EACjC,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,IAAW;;IAEX,MAAM,OAAI,IAAI;EACf;AACD,CAAC;;;AC1BD,IAAMC,gBAAc;AACb,IAAM,eAAe,IAAI,WAAW;EAC1C,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,eAAe,OAAI,IAAI;;IAEvB,aAAa,OAAI,IAAI;;IAErB,eAAe,OAAI,IAAI;EACxB;AACD,CAAC;AAEM,IAAM,YAAY,IAAI,SAAS;EACrC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,QAAQ;IACR,aAAa,OAAI,IAAI;IACrB,WAAW;EACZ;AACD,CAAC;AACM,IAAM,cAAc,IAAI,WAAW;EACzC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,IAAW;;IAEX,OAAO;;IAEP,eAAe;;IAEf,WAAwB;;;;;IAKxB,kBAAkB,OAAI,IAAI;;IAE1B,cAAc,OAAI,IAAI;;IAEtB,aAAa,OAAI,IAAI;;IAErB,YAAY,OAAI,IAAI;;;;;IAKpB,yBAAwC;;;;;;IAMxC,wBAAuC;;;;;;IAMvC,yBAAwC;;IAExC,iBAAiB,OAAI,IAAI;;;;;;IAMzB,gBAAsB;;;;;;;;;;;;;IAatB,eAA8B;;IAE9B,cAAsB;;IAEtB,YAAoB;;IAEpB,qBAA0B;;IAE1B,uBAA4B;;IAE5B,cAAkB;EACnB;AACD,CAAC;;;AC/FD,IAAMC,gBAAc;AACb,IAAM,UAAU,IAAI,WAAW;EACrC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,IAAW;IACX,SAAS,OAAI,IAAI;IACjB,YAAY,OAAI;IAChB,gBAAgB,OAAI,OAAO,OAAI,OAAO;EACvC;AACD,CAAC;;;ACdD,IAAMC,gBAAc;AACb,IAAM,qBAAqB,IAAI,WAAW;EAChD,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,YAAsB;IACtB,QAAQ,OAAI,IAAI;IAChB,SAAS,OAAI;EACd;AACD,CAAC;AACM,IAAM,eAAe,IAAI,WAAW;EAC1C,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,SAAS,OAAI,OAAO,kBAAkB;;IAEtC,UAAU,OAAI,IAAI;;IAElB,OAAO,OAAI,IAAI;;IAEf,sBAAgC;EACjC;AACD,CAAC;AAEM,IAAM,iBAAiB,IAAI,SAAS;EAC1C,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,QAAQ;;IAER,gBAAgB;EACjB;AACD,CAAC;;;AC7BD,IAAMC,gBAAc;AACb,IAAM,mBAAmB,IAAI,WAAW;EAC9C,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,OAAO,OAAI,IAAI;;;;;IAKf,eAAe,OAAI,IAAI;IACvB,uBAA+B;EAChC;AACD,CAAC;AACM,IAAM,6BAA6B,IAAI,WAAW;EACxD,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,eAAe,OAAI,IAAI;IACvB,QAAQ,OAAI,IAAI;IAChB,aAAa,OAAI,OAAO,gBAAgB;EACzC;AACD,CAAC;;;ACnBD,IAAMC,gBAAc;AACb,IAAM,qBAAqB,IAAI,WAAW;EAChD,MAAM,GAAGA,aAAW;EACpB,QAAQ;;IAEP,WAAyB;;;;;IAKzB,qBAAqB,OAAI,IAAI;;IAE7B,oBAAoB,OAAI,IAAI;;IAE5B,6BAA6B,OAAI,IAAI;;IAErC,2BAA2B,OAAI,IAAI;;IAEnC,mBAAsC;;IAEtC,gCAA2C;;;;;;;;;IAS3C,iBAAgC;EACjC;AACD,CAAC;;;AC7BD,IAAMC,gBAAc;AACb,IAAM,SAAS,IAAI,WAAW;EACpC,MAAM,GAAGA,aAAW;EACpB,QAAQ;IACP,IAAW;IACX,SAAS,OAAI,IAAI;IACjB,YAAY,OAAI;IAChB,gBAAgB,OAAI,OAAO,OAAI,OAAO;EACvC;AACD,CAAC;AAiHM,SAAS,aAAa,SAA8B;AAC1D,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB;IACA;IACA,kFAAkF,cAAc;EACjG;AACA,QAAM,iBAAiB,CAAC,QAAQ,iBAAiB,eAAe,SAAS;AACzE,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;AA0EO,SAAS,aAAa,SAA8B;AAC1D,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB,GAAG,cAAc;IACjB;IACA;IACA;IACA;IACA;IACA,kFAAkF,cAAc;EACjG;AACA,QAAM,iBAAiB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;AACA,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;AAwBO,SAAS,YAAY,SAA6B;AACxD,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB,GAAG,cAAc;IACjB;IACA;IACA;EACD;AACA,QAAM,iBAAiB,CAAC,QAAQ,QAAQ,aAAa,iBAAiB,SAAS;AAC/E,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;AAYO,SAAS,WAAW,SAA4B;AACtD,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB,GAAG,cAAc;EAClB;AACA,QAAM,iBAAiB,CAAC,QAAQ,MAAM;AACtC,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;AA0DO,SAAS,WAAW,SAA4B;AACtD,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;IACtB,GAAG,cAAc;IACjB,GAAG,cAAc;IACjB;IACA,kFAAkF,cAAc;EACjG;AACA,QAAM,iBAAiB,CAAC,QAAQ,QAAQ,kBAAkB,SAAS;AACnE,SAAO,CAAC,OACP,GAAG,SAAS;IACX,SAAS;IACT,QAAQ;IACR,UAAU;IACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,cAAc;EACpF,CAAC;AACH;;;ACrYO,IAAM,oBAAN,cAAgC,MAAM;AAAC;AAEvC,IAAM,6BAAN,cAAyC,kBAAkB;AAAC;AAG5D,IAAM,4BAAN,cAAwC,kBAAkB;AAAC;AAG3D,IAAM,oCAAN,cAAgD,kBAAkB;AAAC;AAGnE,IAAM,8BAAN,cAA0C,2BAA2B;AAAC;AAGtE,IAAM,gCAAN,cAA4C,2BAA2B;AAAC;AAGxE,IAAM,kCAAN,cAA8C,2BAA2B;AAAC;AAG1E,IAAM,0BAAN,cAAsC,2BAA2B;AAAC;AAGlE,IAAM,wBAAN,cAAoC,2BAA2B;AAAC;AAGhE,IAAM,wBAAN,cAAoC,kBAAkB;AAAC;AAGvD,IAAM,mBAAN,cAA+B,MAAM;AAAC;;;AC1B7C,IAAM,aAAa,OAAI,KAAK,cAAc;EACzC,OAAO;EACP,QAAQ,OAAI,MAAM,EAAE;AACrB,CAAC;AAED,IAAM,qBAAqB,OAAI,OAAO,sBAAsB;EAC3D,cAAc;EACd,gBAAgB;AACjB,CAAC;AAEM,IAAM,eAAe,OAC1B,KAAK,gBAAgB;EACrB,UAAU;EACV,KAAK;AACN,CAAC,EACA,UAAU;EACV,OAAO,CACN,iBAMA,OAAO,iBAAiB,WACpB,EAAE,CAAC,YAAY,GAAG,KAAK,IACxB;EACJ,QAAQ,CAAC,iBAAiB;AAC3B,CAAC;AAEK,IAAM,iBAAiB,OAAI,OAAO,kBAAkB;EAC1D,eAAe;EACf,kBAAkB,OAAI,IAAI;EAC1B,QAAQ,OAAI,OAAO,kBAAkB;AACtC,CAAC;AAEM,IAAM,eAAe,OAAI,KAAK,gBAAgB;EACpD,IAAI;AACL,CAAC;AAEM,IAAM,SAAS,OAAI,KAAK,EAAE,UAAU;EAC1C,OAAO,CAAC,WAA6B,OAAO,WAAW,WAAW,YAAY,MAAM,IAAI;EACxF,QAAQ,CAAC,OAAe,cAAc,EAAE;AACzC,CAAC;AAEM,SAAS,cAAc,QAAiC;AAC9D,SAAO,OACL,KAAK,EACL,UAAU,MAAM,EAChB,SAAS,EACT,QAAQ,OAAO,EAAE,EACjB,WAAW,KAAK,GAAG,EACnB,WAAW,KAAK,GAAG;AACtB;AAEO,SAAS,gBAAgB,QAA4B;AAC3D,SAAO,cAAc,OAAI,KAAK,EAAE,MAAM,MAAM,CAAC;AAC9C;AAEO,SAAS,YAAY,QAAwB;AACnD,SAAO,OAAO,OAAI,KAAK,EAAE,WAAW,OAAO,WAAW,KAAK,GAAG,EAAE,WAAW,KAAK,GAAG,CAAC,CAAC;AACtF;AAEO,IAAM,qBAAqB,OAAI,OAAO,sBAAsB;EAClE,QAAQ;EACR,UAAU;AACX,CAAC;AAED,IAAM,UAAU,OAAI,OAAO,WAAW;EACrC,MAAM,OAAI,WAAW;EACrB,aAAa,OAAI,IAAI;AACtB,CAAC;AAEM,IAAM,aAAa,OAAI,OAAO,cAAc;EAClD,SAAS;EACT,OAAO,OAAI,IAAI;AAChB,CAAC;AAEM,IAAM,SAAS,OAAI,KAAK,UAAU;EACxC,SAAS;EACT,WAAW;AACZ,CAAC;AAEM,IAAM,aAAa,OAAI,OAAO,cAAc;EAClD,SAAS;EACT,WAAW;AACZ,CAAC;AAEM,IAAK,cAAL,CAAKC,gBAAL;AACNA,cAAAA,YAAA,yBAAA,IAA0B,CAAA,IAA1B;AACAA,cAAAA,YAAA,eAAA,IAAgB,CAAA,IAAhB;AACAA,cAAAA,YAAA,qBAAA,IAAsB,CAAA,IAAtB;AACAA,cAAAA,YAAA,gBAAA,IAAiB,CAAA,IAAjB;AAJW,SAAAA;AAAA,GAAA,cAAA,CAAA,CAAA;AAOL,IAAM,SAAS,OACpB,OAAO,UAAU;EACjB,MAAM,OAAI,GAAG,EAAE,UAAU;IACxB,OAAO,CAAC,SAAqB;IAC7B,QAAQ,CAAC,SAAiB;EAC3B,CAAC;EACD,SAAS,OAAI,GAAG;EAChB,OAAO,OAAI,GAAG;AACf,CAAC,EACA,UAAU;EACV,OAAO,CAAC,YAAwB;IAC/B,MAAM;IACN,SAAS;IACT,OAAO;EACR;EACA,QAAQ,CAAC,WAAW,OAAO;AAC5B,CAAC;AAEK,SAAS,gBAAwC,iBAAoB;AAC3E,SAAO,OAAI,OAAO,mBAAmB,gBAAgB,IAAI,KAAK;IAC7D,QAAQ;IACR,OAAO,OAAI,IAAI;IACf;EACD,CAAC;AACF;AAEO,IAAM,sBAAsB,OAAI,KAAK,uBAAuB;EAClE,WAAW;EACX,WAAW,OAAI,OAAO,aAAa;IAClC,UAAU,OAAI;EACf,CAAC;AACF,CAAC;AACM,IAAM,0BAA0B,OAAI,OAAO,2BAA2B;EAC5E,QAAQ;EACR,UAAU;AACX,CAAC;AAEM,IAAM,sBAAsB,gBAAgB,uBAAuB;AAEnE,SAAS,SACZ,gBACF;AACD,SAAO,OAAI,OAAO,SAAS;IAC1B,IAAI,OAAI;IACR,MAAM,eAAe,CAAC;IACtB,OAAO,eAAe,CAAC;EACxB,CAAC;AACF;AAEO,IAAM,iBAAiB,OAAI,IAAI,OAAI,OAAO,GAAG,OAAI,OAAO,CAAC,EAAE,UAAU;;EAE3E,OAAO,CAAC,SACP,IAAI;IACH,CAAC,GAAI,gBAAgB,MAAM,OAAO,OAAO,QAAQ,IAAI,CAAE,EAAE;MAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;;QAErE,gBAAgB,OAAI,OAAO,EAAE,UAAU,CAAC,EAAE,QAAQ,GAAG,OAAI,OAAO,EAAE,UAAU,CAAC,EAAE,QAAQ,CAAC;;IACzF;EACD;EACD,QAAQ,CAAC,SAA8B,OAAO,YAAY,IAAI;AAC/D,CAAC;AAEM,IAAM,eAAe,OAAI,OAAO,gBAAgB;EACtD,UAAU,OAAI,IAAI;EAClB,YAAY,OAAI,OAAO;EACvB,MAAM;AACP,CAAC;AAED,SAAS,gBAAgB,GAAe,GAAe;AAEtD,MAAI,EAAE,WAAW,EAAE,QAAQ;AAC1B,WAAO,EAAE,SAAS,EAAE;EACrB;AAEA,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAClC,QAAI,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG;AAClB,aAAO,EAAE,CAAC,IAAI,EAAE,CAAC;IAClB;EACD;AAEA,SAAO;AACR;AAEO,IAAM,eAAe,OAAI,OAAO,gBAAgB;EACtD,SAAS,OAAI,OAAO,YAAY;AACjC,CAAC;AAEM,IAAM,eAAe,OAAI,OAAO,gBAAgB;EACtD,SAAS;EACT,SAAS,OAAI,OAAO,wBAAwB;IAC3C,SAAS,OAAI,GAAG;IAChB,YAAY,OAAI,IAAI;IACpB,UAAU,OAAI,IAAI;EACnB,CAAC;AACF,CAAC;AAEM,IAAM,uBAAuB,OAAI,OAAO,wBAAwB;EACtE,SAAS,OAAI,GAAG;EAChB,QAAQ,OAAI,IAAI;EAChB,MAAM,OAAI,GAAG;AACd,CAAC;;;;;;;;;ACvMD,IAAA;AAAA,IAAA;AAGO,IAAM,mBAAN,cAA+B,MAAM;AAAC;AAEtC,IAAM,uBAAN,MAAMC,8BAGH,iBAAiB;EAO1B,YAAY,QAAiB,OAAe,SAA6B;AAf1E,QAAA;AAgBE,UAAM,gBAAA,KAAAA,uBAAoB,6BAAA,cAAA,EAApB,KAAA,IAAiC,QAAQ,OAAO,OAAA,CAAQ;AAC9D,SAAK,SAAS;AACd,SAAK,QAAQ;EACd;EAoBA,OAAO,SACN,QACA,eACA,SACsB;AACtB,QAAI,CAAC,QAAQ;AACZ,aAAO,IAAI,gBAAgB,EAAE,QAAQ,CAAC;IACvC;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,gBAAgB,SAAS,QAAQ,eAAe,OAAO;IAC/D;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,oBAAoB,QAAQ,eAAe,OAAO;IAC9D;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,sBAAsB,QAAQ,eAAe,OAAO;IAChE;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,cAAc,QAAQ,eAAe,OAAO;IACxD;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,cAAc,QAAQ,eAAe,OAAO;IACxD;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,yBAAyB,QAAQ,eAAe,OAAO;IACnE;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,eAAe,QAAQ,eAAe,OAAO;IACzD;AAEA,QAAI,WAAW,KAAK;AACnB,aAAO,IAAI,wBAAwB,QAAQ,eAAe,OAAO;IAClE;AAEA,QAAI,UAAU,KAAK;AAClB,aAAO,IAAI,oBAAoB,QAAQ,eAAe,OAAO;IAC9D;AAEA,WAAO,IAAIA,sBAAoB,QAAQ,eAAe,OAAO;EAC9D;AACD;AAjFO,8BAAA,oBAAA,QAAA;AAgBC,iBAAY,SAAC,QAA4B,OAAgB,SAA6B;AAC5F,WAAS,gBAAgBC,QAAqD;;AAC7E,WAAO,SAAOA,sCAAO,UAAPA,mBAAc,aAAY;EACzC;AAEA,QAAM,kBAAkB,gBAAgB,KAAK,IAAI,MAAM,MAAM,UAAU;AACvE,QAAM,eAAe,kBAAkB,kBAAkB,KAAK,UAAU,KAAK;AAE7E,MAAI,UAAU,cAAc;AAC3B,WAAO,GAAG,MAAM,IAAI,YAAY;EACjC,WAAW,cAAc;AACxB,WAAO;EACR,WAAW,QAAQ;AAClB,WAAO,GAAG,MAAM;EACjB;AACA,SAAO;AACR;AAhCM,aAAM,sBAAN,2BAAA;AAAA,IAAM,sBAAN;AAmFA,IAAM,iBAAN,cAA6B,oBAA0C;EAC7E,YAAY,EAAE,QAAQ,IAA0B,CAAC,GAAG;AACnD,UAAM,QAAW,QAAW,WAAW,sBAAsB;EAC9D;AACD;AAEO,IAAM,kBAAN,cAA8B,oBAA0C;EAC9E,YAAY,EAAE,QAAQ,GAAqC;AAC1D,UAAM,QAAW,QAAW,WAAW,mBAAmB;EAC3D;AACD;AAEO,IAAM,yBAAN,cAAqC,oBAA0C;EACrF,YAAY,EAAE,QAAQ,IAA0B,CAAC,GAAG;AACnD,UAAM,QAAW,QAAW,WAAW,oBAAoB;EAC5D;AACD;AAEO,IAAM,kBAAN,MAAM,yBAAwB,oBAAyB;EAC7D,OAAO,SACN,QACA,eACA,SACsB;;AACtB,QAAI,iBAAiB,OAAO,kBAAkB,YAAY,WAAW,eAAe;AACnF,YAAM,QAAQ,cAAc;AAO5B,YAAI,iBAAM,YAAN,mBAAgB,OAAhB,mBAAoB,YAAW,kBAAkB;AACpD,eAAO,IAAI,uBAAuB,eAAe,OAAO;MACzD;IACD;AAEA,WAAO,IAAI,iBAAgB,QAAQ,eAAe,OAAO;EAC1D;AACD;AAEO,IAAM,yBAAN,cAAqC,oBAAyB;EACpE,YAAY,OAA2B,SAA6B;AACnE,UAAM,KAAK,OAAO,OAAO;EAC1B;AACD;AAEO,IAAM,sBAAN,cAAkC,oBAAyB;AAAC;AAE5D,IAAM,wBAAN,cAAoC,oBAAyB;AAAC;AAE9D,IAAM,gBAAN,cAA4B,oBAAyB;AAAC;AAEtD,IAAM,gBAAN,cAA4B,oBAAyB;AAAC;AAEtD,IAAM,2BAAN,cAAuC,oBAAyB;AAAC;AAEjE,IAAM,iBAAN,cAA6B,oBAAyB;AAAC;AAEvD,IAAM,0BAAN,cAAsC,oBAAyB;AAAC;AAEhE,IAAM,sBAAN,cAAkC,oBAA4B;AAAC;;;AChJ/D,SAAS,gBAAgB,SAA+C;AAC9E,QAAM,gBAAgB,IAAI,QAAQ;AAElC,aAAW,UAAU,SAAS;AAC7B,QAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AAC1C;IACD;AAEA,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,UAAI,UAAU,MAAM;AACnB,sBAAc,OAAO,GAAG;MACzB,WAAW,MAAM,QAAQ,KAAK,GAAG;AAChC,mBAAW,KAAK,OAAO;AACtB,wBAAc,OAAO,KAAK,CAAW;QACtC;MACD,WAAW,UAAU,QAAW;AAC/B,sBAAc,IAAI,KAAK,KAAK;MAC7B;IACD;EACD;AAEA,SAAO;AACR;;;;;;;;;;;AC3BA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AA2DO,IAAM,oBAAN,MAAwB;EAI9B,YAAY,EAAE,OAAO,iBAAiB,SAAS,QAAQ,IAA8B,CAAC,GAAG;AAJnF,IAAAC,cAAA,MAAA,4BAAA;AACN,IAAAA,cAAA,MAAA,MAAA;AACA,IAAAA,cAAA,MAAA,QAAA;AACA,IAAAA,cAAA,MAAA,QAAA;AAEC,iBAAA,MAAK,QAAS,mBAAmB,WAAW,KAAA;AAC5C,iBAAA,MAAK,UAAW,WAAW,GAAA;AAC3B,iBAAA,MAAK,UAAW,OAAA;EACjB;;;;EAKA,MAAM,gBACL,EAAE,OAAO,GACT,SACmC;AACnC,UAAM,WAAW,MAAMC,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MAAc,aAAa,MAAM,aAAa;MACpE,GAAG;MACH,SAAS,aAAa,EAAE,QAAQ,2BAA2B,GAAG,QAAQ,OAAO;IAC9E,CAAA;AAEA,UAAM,WAAW,MAAM,SAAS,YAAY;AAC5C,WAAO,mBAAmB,MAAM,IAAI,WAAW,QAAQ,CAAC;EACzD;;;;EAKA,MAAM,cACL,EAAE,OAAO,GACT,SACiC;AACjC,UAAM,WAAW,MAAMA,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MAAc,aAAa,MAAM,WAAW,OAAA;AAEnE,UAAM,OAAiC,MAAM,SAAS,KAAK;AAC3D,UAAM,aAAa,KAAK,QAAQ;AAEhC,QAAI,eAAe,eAAe;AACjC,aAAO,EAAE,MAAM,cAAc;IAC9B;AAEA,QAAI,aAAa,YAAY;AAC5B,aAAO;QACN,MAAM;QACN,GAAG,WAAW;MACf;IACD;AAEA,QAAI,eAAe,YAAY;AAC9B,aAAO;QACN,MAAM;QACN,GAAG,WAAW;MACf;IACD;AAEA,QAAI,eAAe,YAAY;AAC9B,aAAO;QACN,MAAM;QACN,GAAG,WAAW;MACf;IACD;AAEA,UAAM,IAAI,iBAAiB,iCAAiC,UAAU,EAAE;EACzE;;;;;;;;;;EAWA,MAAM,kBACL,EAAE,QAAQ,SAAS,GACnB,SACqC;AACrC,UAAM,aAAa,OAAO,aAAa,YAAY,QAAQ;AAC3D,UAAM,OAAO,aAAa,aAAa,UAAU,QAAQ,EAAE,QAAQ,IAAI;AAEvE,UAAM,WAAW,MAAMA,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MAAc,aAAa,MAAM,aAAa;MACpE,GAAG;MACH,QAAQ;MACR;MACA,SAAS,aAAa,EAAE,gBAAgB,2BAA2B,GAAG,QAAQ,OAAO;IACtF,CAAA;AAEA,UAAM,OAAkC,MAAM,SAAS,KAAK;AAC5D,WAAO;EACR;;;;;;EAOA,MAAM,UACL,EAAE,QAAQ,iBAAiB,WAAW,GACtC,SAC6B;AAC7B,UAAM,WAAW,MAAMA,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MACtB,aAAa,MAAM,YAAY,eAAe,IAAI,UAAU,IAC5D;MACC,GAAG;MACH,SAAS,aAAa,EAAE,QAAQ,2BAA2B,GAAG,QAAQ,OAAO;IAC9E,CAAA;AAGD,UAAM,WAAW,MAAM,SAAS,YAAY;AAC5C,WAAO,WAAW,MAAM,IAAI,WAAW,QAAQ,CAAC;EACjD;;;;EAKA,MAAM,YACL,EAAE,QAAQ,iBAAiB,YAAY,OAAO,GAC9C,SAC+B;AAC/B,UAAM,aAAa,OAAO,WAAW,YAAY,aAAa;AAC9D,UAAM,OAAO,aAAa,WAAW,UAAU,MAAM,EAAE,QAAQ,IAAI;AAEnE,UAAM,WAAW,MAAMA,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MACtB,aAAa,MAAM,YAAY,eAAe,IAAI,UAAU,IAC5D;MACC,GAAG;MACH,QAAQ;MACR;MACA,SAAS,aAAa,EAAE,gBAAgB,2BAA2B,GAAG,QAAQ,OAAO;IACtF,CAAA;AAGD,UAAM,OAA4B,MAAM,SAAS,KAAK;AACtD,WAAO;EACR;;;;;EAMA,MAAM,6BACL,EAAE,QAAQ,SAAS,GACnB,SACgD;AAChD,UAAM,WAAW,MAAMA,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MACtB,aAAa,MAAM,2BAA2B,QAAQ,IACtD,OAAA;AAGD,UAAM,OAA6C,MAAM,SAAS,KAAK;AACvE,WAAO;EACR;;;;;EAMA,MAAM,6BACL,EAAE,OAAO,GACT,SACgD;AAChD,UAAM,WAAW,MAAMA,iBAAA,MAAK,8BAAA,UAAA,EAAL,KAAA,MAAc,aAAa,MAAM,2BAA2B,OAAA;AAEnF,UAAM,OAA6C,MAAM,SAAS,KAAK;AACvE,WAAO;EACR;AA8CD;AApNC,SAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AAHM,+BAAA,oBAAA,QAAA;AAyKA,aAAQ,eAAC,MAAc,SAAyB;AApOvD,MAAA,IAAA,IAAA;AAqOE,QAAM,EAAE,SAAS,QAAQ,SAAS,GAAG,KAAK,IAAI;AAE9C,MAAI,iCAAQ,SAAS;AACpB,UAAM,IAAI,eAAe;EAC1B;AAEA,QAAM,gBAAgB,YAAY,QAAQ,WAAW,aAAA,MAAK,QAAA,CAAQ;AAElE,MAAI;AAEJ,MAAI;AACH,UAAMC,SAAQ,aAAA,MAAK,MAAA;AACnB,eAAW,MAAMA,OAAM,GAAG,OAAO,GAAG,IAAI,IAAI;MAC3C,GAAG;MACH,QAAQ,SAAS,YAAY,IAAI,CAAC,eAAe,MAAM,CAAC,IAAI;IAC7D,CAAC;EACF,SAAS,OAAO;AACf,QAAI,iCAAQ,SAAS;AACpB,YAAM,IAAI,eAAe;IAC1B;AAEA,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AAC1D,YAAMC,SAAQ,IAAI,uBAAuB;AACzC,OAAA,KAAA,aAAA,MAAK,QAAA,MAAL,OAAA,SAAA,GAAA,KAAA,MAAgBA,MAAAA;AAChB,YAAMA;IACP;AAEA,KAAA,KAAA,aAAA,MAAK,QAAA,MAAL,OAAA,SAAA,GAAA,KAAA,MAAgB,KAAA;AAEhB,UAAM;EACP;AAEA,MAAI,CAAC,SAAS,IAAI;AACjB,UAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,CAAC,WAAW,MAAM;AAChE,UAAM,YAAY,cAAc,SAAS;AACzC,UAAM,eAAe,YAAY,SAAY;AAC7C,UAAM,QAAQ,oBAAoB,SAAS,SAAS,QAAQ,WAAW,YAAY;AACnF,KAAA,KAAA,aAAA,MAAK,QAAA,MAAL,OAAA,SAAA,GAAA,KAAA,MAAgB,KAAA;AAChB,UAAM;EACP;AAEA,SAAO;AACR;AAGD,SAAS,cAAc,OAAe;AACrC,MAAI;AACH,WAAO,KAAK,MAAM,KAAK;EACxB,QAAQ;AACP,WAAO;EACR;AACD;;;AC7QA,IAAM,aAAa;AACnB,IAAM,cAAc;AAEb,IAAM,sCAAsC;EAClD,KAAK;EACL,UAAU;AACX;AAEO,IAAM,mCAAmC;EAC/C,KAAK,KAAK,KAAK;EACf,UAAU,KAAK,KAAK;AACrB;AAGO,SAAS,kBACf,iBACA,SACA,eAA6B,OACpB;AACT,QAAM,aAAa,kBAAkB,iBAAiB,SAAS,YAAY;AAC3E,QAAM,WAAW,UAAU,aAAa,IAAI;AAC5C,SAAO,UAAU,WAAW;AAC7B;AAEO,SAAS,kBACf,iBACA,SACA,eAA6B,OACpB;AACT,QAAM,EAAE,gBAAgB,iBAAiB,IAAI,iBAAiB,SAAS,YAAY;AAEnF,MAAI,aACH,KAAK,OAAO,KAAK,IAAI,iBAAiB,CAAC,IAAI,MAAM,iBAAiB,iBAAiB,IAAI;AAExF,MAAI,iBAAiB,SAAS,aAAa,MAAM,GAAG;AACnD,iBAAa,aAAa;EAC3B;AAEA,QAAM,mBAAmB,iBAAiB,oBAAoB;AAE9D,SAAO,kBAAkB;AAC1B;AAEO,SAAS,iBAAiB,SAAiB,eAA6B,OAAO;AACrF,QAAM,cAAc,oBAAoB,SAAS,YAAY;AAC7D,QAAM,YAAY,kBAAkB,OAAO;AAC3C,QAAM,aAAa,UAAU;AAE7B,SAAO;IACN,gBAAgB,aAAa,YAAY;IACzC,kBAAkB,aAAa;EAChC;AACD;AAEO,SAAS,SAAS,MAAc,SAA0B;AAChE,QAAM,YAAY,kBAAkB,OAAO;AAC3C,SAAO,OAAO,IAAI;AACnB;AAEO,SAAS,gBAAgB,MAAc,SAA0B;AACvE,QAAM,YAAY,kBAAkB,OAAO;AAC3C,SAAO,OAAO;AACf;AAEO,SAAS,kBAAkB,SAAyB;AAC1D,SAAO,KAAK,OAAO,UAAU,KAAK,CAAC;AACpC;AAEA,SAAS,oBAAoB,SAAiB,cAAoC;AACjF,UAAQ,cAAc;IACrB,KAAK;AACJ,aAAO,KAAK,IAAI,GAAG,KAAK,MAAM,kBAAkB,OAAO,IAAI,CAAC,CAAC;IAC9D,KAAK;AACJ,aAAO;IACR;AACC,YAAM,IAAI,MAAM,wCAAwC,YAAY,EAAE;EACxE;AACD;AAEA,IAAM,sBAAsB,OAAO;AAE5B,SAAS,qBAAqB,MAAsB;AAC1D,SAAO,KAAK,KAAK,OAAO,mBAAmB;AAC5C;AAEA,SAAS,eAAe,OAAmB,SAAyB;AACnE,SAAO,MAAM,OAAO,CAAC,KAAK,UAAU,MAAM,MAAM,QAAQ,SAAS,CAAC;AACnE;AAEO,SAAS,aAAa,iBAAyB,QAAgB,WAA2B;AAChG,QAAM,SAAS,eAAe,OAAO,UAAU,MAAM,EAAE,QAAQ,GAAG,SAAS;AAC3E,UAAQ,kBAAkB,UAAU;AACrC;AAEO,SAAS,wCACf,aACA,WACS;AACT,SAAO,YAAY,cAAc;AAClC;AAWO,SAAS,YAAY,YAAoB,QAAgB,WAA2B;AAC1F,QAAM,SAAS,eAAe,OAAO,UAAU,MAAM,EAAE,QAAQ,GAAG,SAAS;AAC3E,UAAQ,YAAY,aAAa,UAAU;AAC5C;AAEO,SAAS,gBAAgB,SAAmB,eAAmC;AACrF,QAAM,aAAa,KAAK,KAAK,gBAAgB,CAAC;AAC9C,QAAM,SAAS,IAAI,WAAW,UAAU;AAExC,aAAW,UAAU,SAAS;AAC7B,UAAM,YAAY,KAAK,MAAM,SAAS,CAAC;AACvC,UAAM,WAAW,SAAS;AAC1B,WAAO,SAAS,KAAK,KAAK;EAC3B;AAEA,SAAO;AACR;AAEO,SAAS,wBAAwB,WAA2C;AAClF,QAAM,uBAAuB,oBAAI,IAAsB;AAEvD,aAAW,QAAQ,UAAU,CAAC,EAAE,UAAU;AACzC,QAAI,CAAC,qBAAqB,IAAI,KAAK,GAAG,GAAG;AACxC,2BAAqB,IAAI,KAAK,KAAK,CAAC,CAAC;IACtC;AACA,yBAAqB,IAAI,KAAK,GAAG,EAAG,KAAK,GAAG,KAAK,KAAK;EACvD;AAEA,SAAO;AACR;AAiEO,SAAS,cAAc,OAA2B;AACxD,SAAO,SAAS,KAAK,EAAE,QAAQ,OAAO,EAAE,EAAE,WAAW,KAAK,GAAG,EAAE,WAAW,KAAK,GAAG;AACnF;AAEO,SAAS,kBAAkB,QAA4B;AAC7D,SAAO,WAAW,OAAO,WAAW,KAAK,GAAG,EAAE,WAAW,KAAK,GAAG,CAAC;AACnE;AAEO,SAAS,SAAS,UAAkB,WAAmB;AAC7D,QAAM,kBAAkB,kBAAkB,UAAU,SAAS;AAC7D,QAAM,EAAE,gBAAgB,iBAAiB,IAAI,iBAAiB,SAAS;AACvE,QAAM,gBAAgB,iBAAiB,oBAAoB;AAE3D,MAAI,kBAAkB,iBAAiB,GAAG;AACzC,UAAM,IAAI,MAAM,wDAAwD;EACzE;AAEA,QAAM,aAAa,kBAAkB;AAErC,MAAI,kBAAkB,iBAAiB,GAAG;AACzC,UAAM,IAAI,MAAM,kDAAkD;EACnE;AAEA,QAAM,UAAU,aAAa;AAC7B,QAAM,aAAa,aAAa;AAEhC,SAAO;IACN;IACA;IACA;IACA;EACD;AACD;;;AC3OA,wBAAuB;;;;;;;AAZvB,IAAA;AAeO,IAAM,sBAAN,cAAkC,kBAAAC,QAGvC;EAED,YAAY,WAAoC;AAC/C,UAAM,OAAO,QAA2B;AACvC,YAAM,EAAE,QAAQ,IAAI,MAAM,UAAU,KAAK,WAAW;QACnD,WAAW;MACZ,CAAC;AAED,aAAO;IACR,CAAC;AARF,IAAAC,cAAA,MAAA,oBAAqB,oBAAI,IAAqE,CAAA;EAS9F;EAEA,MAAe,KAAwB,IAAY,QAAsC;AACxF,UAAM,OAAO,MAAM,MAAM,KAAK,EAAE;AAEhC,QAAI,QAAQ;AACX,aAAO,OAAO,MAAM,MAAM,KAAK,OAAO;IACvC;AAEA,WAAO;EACR;EAEA,MAAe,SACd,KACA,QACyB;AACzB,UAAM,OAAO,MAAM,MAAM,SAAS,GAAG;AAErC,QAAI,CAAC,QAAQ;AACZ,aAAO;IACR;AAEA,WAAO,QAAQ;MACd,KAAK,IAAI,OAAO,MAAM;AACrB,YAAI,aAAa,OAAO;AACvB,iBAAO;QACR;AAEA,eAAO,OAAO,MAAM,MAAM,EAAE,OAAO;MACpC,CAAC;IACF;EACD;EAEA,MAAM,gBAAmB,KAAe,QAAuC;AAC9E,UAAM,OAAO,MAAM,KAAK,SAAS,KAAK,MAAM;AAE5C,eAAW,KAAK,MAAM;AACrB,UAAI,aAAa,OAAO;AACvB,cAAM;MACP;IACD;AAEA,WAAO;EACR;EAES,WAAW;AACnB,IAAAC,cAAA,MAAK,kBAAA,EAAmB,MAAM;AAC9B,WAAO,MAAM,SAAS;EACvB;EAES,MAAM,KAAa;AAC3B,IAAAA,cAAA,MAAK,kBAAA,EAAmB,OAAO,GAAG;AAClC,WAAO,MAAM,MAAM,GAAG;EACvB;EAEA,MAAM,gBACL,QACA,MAIA,MACa;AACb,UAAM,SAAS,0BAA6B,KAAK,IAAa;AAC9D,UAAM,KAAK,qBAAqB,QAAQ,OAAO,OAAO,UAAU,KAAK,KAAK,EAAE,QAAQ,CAAC;AAErF,YAAQ,MAAM,KAAK,KAAK,IAAI,MAAM,QAAQ,IAAI,CAAC,GAAG;EACnD;AACD;AA7EC,qBAAA,oBAAA,QAAA;;;ACXM,SAAS,gBAAmB,KAA6B;AAC/D,SAAO,IACL,IAAI,CAAC,EAAE,OAAO,OAAO,OAAO;IAC5B;IACA,QAAQ,KAAK,IAAI,KAAK,OAAO,GAAG,IAAI,MAAM;EAC3C,EAAE,EACD,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,MAAM,EAClC,IAAI,CAAC,SAAS,KAAK,KAAK;AAC3B;AAEO,SAAS,QAAW,KAAe;AACzC,QAAM,SAAS,CAAC,GAAG,GAAG;AAEtB,WAAS,IAAI,OAAO,SAAS,GAAG,IAAI,GAAG,KAAK,GAAG;AAC9C,UAAM,IAAI,KAAK,MAAM,KAAK,OAAO,KAAK,IAAI,EAAE;AAC5C,KAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;EAC/C;AAEA,SAAO;AACR;;;AC3BA,IAAI;AAEJ,IAAI,kBAAkB;AAEtB,IAAI,0BAA0B;AAE9B,SAAS,uBAAuB;AAC5B,MAAI,4BAA4B,QAAQ,wBAAwB,eAAe,GAAG;AAC9E,8BAA0B,IAAI,WAAW,KAAK,OAAO,MAAM;AAAA,EAC/D;AACA,SAAO;AACX;AAEA,IAAM,oBAAqB,OAAO,gBAAgB,cAAc,IAAI,YAAY,OAAO,IAAI,EAAE,QAAQ,MAAM;AAAE,QAAM,MAAM,2BAA2B;AAAE,EAAE;AAExJ,IAAM,eAAgB,OAAO,kBAAkB,eAAe,aACxD,SAAU,KAAK,MAAM;AACvB,SAAO,kBAAkB,WAAW,KAAK,IAAI;AACjD,IACM,SAAU,KAAK,MAAM;AACvB,QAAM,MAAM,kBAAkB,OAAO,GAAG;AACxC,OAAK,IAAI,GAAG;AACZ,SAAO;AAAA,IACH,MAAM,IAAI;AAAA,IACV,SAAS,IAAI;AAAA,EACjB;AACJ;AAEA,SAAS,kBAAkB,KAAK,QAAQ,SAAS;AAE7C,MAAI,YAAY,QAAW;AACvB,UAAM,MAAM,kBAAkB,OAAO,GAAG;AACxC,UAAMC,OAAM,OAAO,IAAI,QAAQ,CAAC,MAAM;AACtC,yBAAqB,EAAE,SAASA,MAAKA,OAAM,IAAI,MAAM,EAAE,IAAI,GAAG;AAC9D,sBAAkB,IAAI;AACtB,WAAOA;AAAA,EACX;AAEA,MAAI,MAAM,IAAI;AACd,MAAI,MAAM,OAAO,KAAK,CAAC,MAAM;AAE7B,QAAM,MAAM,qBAAqB;AAEjC,MAAI,SAAS;AAEb,SAAO,SAAS,KAAK,UAAU;AAC3B,UAAM,OAAO,IAAI,WAAW,MAAM;AAClC,QAAI,OAAO,IAAM;AACjB,QAAI,MAAM,MAAM,IAAI;AAAA,EACxB;AAEA,MAAI,WAAW,KAAK;AAChB,QAAI,WAAW,GAAG;AACd,YAAM,IAAI,MAAM,MAAM;AAAA,IAC1B;AACA,UAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,IAAI,SAAS,GAAG,CAAC,MAAM;AAC9D,UAAM,OAAO,qBAAqB,EAAE,SAAS,MAAM,QAAQ,MAAM,GAAG;AACpE,UAAM,MAAM,aAAa,KAAK,IAAI;AAElC,cAAU,IAAI;AACd,UAAM,QAAQ,KAAK,KAAK,QAAQ,CAAC,MAAM;AAAA,EAC3C;AAEA,oBAAkB;AAClB,SAAO;AACX;AAEA,IAAI,wBAAwB;AAE5B,SAAS,qBAAqB;AAC1B,MAAI,0BAA0B,QAAQ,sBAAsB,OAAO,aAAa,QAAS,sBAAsB,OAAO,aAAa,UAAa,sBAAsB,WAAW,KAAK,OAAO,QAAS;AAClM,4BAAwB,IAAI,SAAS,KAAK,OAAO,MAAM;AAAA,EAC3D;AACA,SAAO;AACX;AAEA,SAAS,qBAAqB,KAAK;AAC/B,QAAM,MAAM,KAAK,wBAAwB;AACzC,OAAK,oBAAoB,IAAI,KAAK,GAAG;AACrC,SAAO;AACX;AAEA,SAAS,YAAY,GAAG,MAAM;AAC1B,MAAI;AACA,WAAO,EAAE,MAAM,MAAM,IAAI;AAAA,EAC7B,SAAS,GAAG;AACR,UAAM,MAAM,qBAAqB,CAAC;AAClC,SAAK,qBAAqB,GAAG;AAAA,EACjC;AACJ;AAEA,SAAS,YAAY,KAAK;AAEtB,QAAM,OAAO,OAAO;AACpB,MAAI,QAAQ,YAAY,QAAQ,aAAa,OAAO,MAAM;AACtD,WAAQ,GAAG,GAAG;AAAA,EAClB;AACA,MAAI,QAAQ,UAAU;AAClB,WAAO,IAAI,GAAG;AAAA,EAClB;AACA,MAAI,QAAQ,UAAU;AAClB,UAAM,cAAc,IAAI;AACxB,QAAI,eAAe,MAAM;AACrB,aAAO;AAAA,IACX,OAAO;AACH,aAAO,UAAU,WAAW;AAAA,IAChC;AAAA,EACJ;AACA,MAAI,QAAQ,YAAY;AACpB,UAAM,OAAO,IAAI;AACjB,QAAI,OAAO,QAAQ,YAAY,KAAK,SAAS,GAAG;AAC5C,aAAO,YAAY,IAAI;AAAA,IAC3B,OAAO;AACH,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,UAAM,SAAS,IAAI;AACnB,QAAI,QAAQ;AACZ,QAAI,SAAS,GAAG;AACZ,eAAS,YAAY,IAAI,CAAC,CAAC;AAAA,IAC/B;AACA,aAAQ,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC5B,eAAS,OAAO,YAAY,IAAI,CAAC,CAAC;AAAA,IACtC;AACA,aAAS;AACT,WAAO;AAAA,EACX;AAEA,QAAM,iBAAiB,sBAAsB,KAAK,SAAS,KAAK,GAAG,CAAC;AACpE,MAAI;AACJ,MAAI,kBAAkB,eAAe,SAAS,GAAG;AAC7C,gBAAY,eAAe,CAAC;AAAA,EAChC,OAAO;AAEH,WAAO,SAAS,KAAK,GAAG;AAAA,EAC5B;AACA,MAAI,aAAa,UAAU;AAIvB,QAAI;AACA,aAAO,YAAY,KAAK,UAAU,GAAG,IAAI;AAAA,IAC7C,SAAS,GAAG;AACR,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,MAAI,eAAe,OAAO;AACtB,WAAO,GAAG,IAAI,IAAI,KAAK,IAAI,OAAO;AAAA,EAAK,IAAI,KAAK;AAAA,EACpD;AAEA,SAAO;AACX;AAEA,IAAM,oBAAqB,OAAO,gBAAgB,cAAc,IAAI,YAAY,SAAS,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC,IAAI,EAAE,QAAQ,MAAM;AAAE,QAAM,MAAM,2BAA2B;AAAE,EAAE;AAE1L,IAAI,OAAO,gBAAgB,aAAa;AAAE,oBAAkB,OAAO;AAAG;AAEtE,SAAS,mBAAmB,KAAK,KAAK;AAClC,QAAM,QAAQ;AACd,SAAO,kBAAkB,OAAO,qBAAqB,EAAE,SAAS,KAAK,MAAM,GAAG,CAAC;AACnF;AAEA,SAAS,WAAW,GAAG;AACnB,SAAO,MAAM,UAAa,MAAM;AACpC;AAEA,SAAS,kBAAkB,KAAK,QAAQ;AACpC,QAAM,MAAM,OAAO,IAAI,SAAS,GAAG,CAAC,MAAM;AAC1C,uBAAqB,EAAE,IAAI,KAAK,MAAM,CAAC;AACvC,oBAAkB,IAAI;AACtB,SAAO;AACX;AAEA,SAAS,wBAAwB,KAAK;AAClC,QAAM,QAAQ,KAAK,oBAAoB,IAAI,GAAG;AAC9C,OAAK,0BAA0B,GAAG;AAClC,SAAO;AACX;AAOO,SAAS,uBAAuB,WAAW,YAAY,KAAK;AAC/D,QAAM,OAAO,kBAAkB,WAAW,KAAK,iBAAiB;AAChE,QAAM,OAAO;AACb,QAAM,OAAO,kBAAkB,YAAY,KAAK,iBAAiB;AACjE,QAAM,OAAO;AACb,QAAM,OAAO,kBAAkB,KAAK,KAAK,iBAAiB;AAC1D,QAAM,OAAO;AACb,QAAM,MAAM,KAAK,uBAAuB,MAAM,MAAM,MAAM,MAAM,MAAM,IAAI;AAC1E,MAAI,IAAI,CAAC,GAAG;AACR,UAAM,wBAAwB,IAAI,CAAC,CAAC;AAAA,EACxC;AACA,SAAO,IAAI,CAAC,MAAM;AACtB;AAEA,SAAS,oBAAoB,KAAK,KAAK;AACnC,QAAM,QAAQ;AACd,SAAO,qBAAqB,EAAE,SAAS,MAAM,GAAG,MAAM,IAAI,GAAG;AACjE;AAOO,SAAS,0BAA0B,YAAY;AAClD,QAAM,MAAM,KAAK,0BAA0B,UAAU;AACrD,MAAI,IAAI,CAAC,GAAG;AACR,UAAM,wBAAwB,IAAI,CAAC,CAAC;AAAA,EACxC;AACA,MAAI,KAAK,oBAAoB,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM;AACnD,OAAK,gBAAgB,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC;AAC1C,SAAO;AACX;AAqBA,IAAM,0BAA2B,OAAO,yBAAyB,cAC3D,EAAE,UAAU,MAAM;AAAC,GAAG,YAAY,MAAM;AAAC,EAAE,IAC3C,IAAI,qBAAqB,SAAO,KAAK,uBAAuB,QAAQ,GAAG,CAAC,CAAC;AAExE,IAAM,cAAN,MAAkB;AAAA,EAErB,qBAAqB;AACjB,UAAM,MAAM,KAAK;AACjB,SAAK,YAAY;AACjB,4BAAwB,WAAW,IAAI;AACvC,WAAO;AAAA,EACX;AAAA,EAEA,OAAO;AACH,UAAM,MAAM,KAAK,mBAAmB;AACpC,SAAK,uBAAuB,KAAK,CAAC;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,UAAU;AAClB,UAAM,MAAM,KAAK,gBAAgB,QAAQ;AACzC,QAAI,IAAI,CAAC,GAAG;AACR,YAAM,wBAAwB,IAAI,CAAC,CAAC;AAAA,IACxC;AACA,SAAK,YAAY,IAAI,CAAC,MAAM;AAC5B,4BAAwB,SAAS,MAAM,KAAK,WAAW,IAAI;AAC3D,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqB,MAAM;AACvB,UAAM,OAAO,kBAAkB,MAAM,KAAK,iBAAiB;AAC3D,UAAM,OAAO;AACb,UAAM,MAAM,KAAK,iCAAiC,KAAK,WAAW,MAAM,IAAI;AAC5E,QAAI,IAAI,CAAC,GAAG;AACR,YAAM,wBAAwB,IAAI,CAAC,CAAC;AAAA,IACxC;AACA,WAAO,wBAAwB,IAAI,CAAC,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB,MAAM;AACnB,UAAM,OAAO,kBAAkB,MAAM,KAAK,iBAAiB;AAC3D,UAAM,OAAO;AACb,UAAM,MAAM,KAAK,6BAA6B,KAAK,WAAW,MAAM,IAAI;AACxE,QAAI,IAAI,CAAC,GAAG;AACR,YAAM,wBAAwB,IAAI,CAAC,CAAC;AAAA,IACxC;AACA,WAAO,wBAAwB,IAAI,CAAC,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAO,SAAS,WAAW,SAAS;AAChC,UAAM,MAAM,KAAK,mBAAmB,KAAK,WAAW,SAAS,WAAW,OAAO;AAC/E,QAAI,IAAI,CAAC,GAAG;AACR,YAAM,wBAAwB,IAAI,CAAC,CAAC;AAAA,IACxC;AACA,WAAO,wBAAwB,IAAI,CAAC,CAAC;AAAA,EACzC;AACJ;AAEA,eAAe,WAAW,QAAQ,SAAS;AACvC,MAAI,OAAO,aAAa,cAAc,kBAAkB,UAAU;AAC9D,QAAI,OAAO,YAAY,yBAAyB,YAAY;AACxD,UAAI;AACA,eAAO,MAAM,YAAY,qBAAqB,QAAQ,OAAO;AAAA,MAEjE,SAAS,GAAG;AACR,YAAI,OAAO,QAAQ,IAAI,cAAc,KAAK,oBAAoB;AAC1D,kBAAQ,KAAK,qMAAqM,CAAC;AAAA,QAEvN,OAAO;AACH,gBAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,QAAQ,MAAM,OAAO,YAAY;AACvC,WAAO,MAAM,YAAY,YAAY,OAAO,OAAO;AAAA,EAEvD,OAAO;AACH,UAAM,WAAW,MAAM,YAAY,YAAY,QAAQ,OAAO;AAE9D,QAAI,oBAAoB,YAAY,UAAU;AAC1C,aAAO,EAAE,UAAU,OAAO;AAAA,IAE9B,OAAO;AACH,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAEA,SAAS,oBAAoB;AACzB,QAAM,UAAU,CAAC;AACjB,UAAQ,MAAM,CAAC;AACf,UAAQ,IAAI,gCAAgC,SAAS,MAAM,MAAM;AAC7D,UAAM,MAAM,OAAO,IAAI;AACvB,UAAM,OAAO,kBAAkB,KAAK,KAAK,mBAAmB,KAAK,kBAAkB;AACnF,UAAM,OAAO;AACb,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,MAAM,IAAI;AACtD,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,MAAM,IAAI;AAAA,EAC1D;AACA,UAAQ,IAAI,gCAAgC,SAAS,MAAM;AACvD,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,8BAA8B,WAAW;AAAE,WAAO,YAAY,SAAU,MAAM,MAAM;AAC5F,YAAM,MAAM,KAAK,KAAK,IAAI;AAC1B,aAAO;AAAA,IACX,GAAG,SAAS;AAAA,EAAE;AACd,UAAQ,IAAI,8BAA8B,SAAS,MAAM;AACrD,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,6BAA6B,WAAW;AAAE,WAAO,YAAY,SAAU,MAAM,MAAM;AAC3F,YAAM,MAAM,QAAQ,IAAI,MAAM,IAAI;AAClC,aAAO;AAAA,IACX,GAAG,SAAS;AAAA,EAAE;AACd,UAAQ,IAAI,6BAA6B,SAAS,MAAM,MAAM;AAC1D,UAAM,MAAM,KAAK,SAAS,CAAC;AAC3B,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,uCAAuC,SAAS,MAAM,MAAM;AACpE,UAAM,MAAM,KAAK,IAAI;AACrB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,gDAAgD,SAAS,MAAM;AACvE,QAAI;AACJ,QAAI;AACA,eAAS,gBAAgB;AAAA,IAC7B,SAAS,GAAG;AACR,eAAS;AAAA,IACb;AACA,UAAM,MAAM;AACZ,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,+CAA+C,SAAS,MAAM;AACtE,QAAI;AACJ,QAAI;AACA,eAAS,gBAAgB;AAAA,IAC7B,SAAS,GAAG;AACR,eAAS;AAAA,IACb;AACA,UAAM,MAAM;AACZ,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,iCAAiC,SAAS,MAAM;AACxD,UAAM,MAAM,MAAM,QAAQ,IAAI;AAC9B,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,uCAAuC,SAAS,MAAM;AAC9D,UAAM,MAAM,OAAO,cAAc,IAAI;AACrC,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,kCAAkC,WAAW;AACrD,UAAM,MAAM,OAAO;AACnB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,gCAAgC,SAAS,MAAM;AACvD,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,gCAAgC,SAAS,MAAM;AACvD,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,6BAA6B,WAAW;AAChD,UAAM,MAAM,IAAI,OAAO;AACvB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,6BAA6B,WAAW;AAChD,UAAM,MAAM,IAAI,MAAM;AACtB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,6BAA6B,SAAS,MAAM;AACpD,UAAM,MAAM,IAAI,WAAW,IAAI;AAC/B,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,8BAA8B,SAAS,MAAM;AACrD,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,8BAA8B,WAAW;AAAE,WAAO,YAAY,SAAU,MAAM;AACtF,YAAM,MAAM,KAAK,KAAK;AACtB,aAAO;AAAA,IACX,GAAG,SAAS;AAAA,EAAE;AACd,UAAQ,IAAI,6BAA6B,SAAS,MAAM,MAAM,MAAM;AAChE,SAAK,SAAS,CAAC,IAAI;AAAA,EACvB;AACA,UAAQ,IAAI,6BAA6B,SAAS,MAAM,MAAM,MAAM;AAChE,SAAK,IAAI,IAAI;AAAA,EACjB;AACA,UAAQ,IAAI,6BAA6B,SAAS,MAAM,MAAM,MAAM;AAChE,SAAK,IAAI,MAAM,SAAS,CAAC;AAAA,EAC7B;AACA,UAAQ,IAAI,+BAA+B,SAAS,MAAM;AACtD,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,6BAA6B,SAAS,MAAM;AACpD,UAAM,MAAM,OAAO,QAAQ,IAAI,IAAI;AACnC,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,yBAAyB,SAAS,MAAM;AAChD,UAAM,IAAI;AACV,UAAM,MAAM,OAAO,MAAO,YAAa,IAAI,IAAI,IAAK;AACpD,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,0BAA0B,SAAS,MAAM,MAAM;AACvD,UAAM,MAAM,YAAY,IAAI;AAC5B,UAAM,OAAO,kBAAkB,KAAK,KAAK,mBAAmB,KAAK,kBAAkB;AACnF,UAAM,OAAO;AACb,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,MAAM,IAAI;AACtD,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,MAAM,IAAI;AAAA,EAC1D;AACA,UAAQ,IAAI,uBAAuB,SAAS,MAAM,MAAM;AACpD,UAAM,MAAM,IAAI,MAAM,mBAAmB,MAAM,IAAI,CAAC;AACpD,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,gBAAgB,SAAS,MAAM,MAAM;AAC7C,UAAM,MAAM,QAAQ;AACpB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,kCAAkC,WAAW;AACrD,UAAM,QAAQ,KAAK;AACnB,UAAM,SAAS,MAAM,KAAK,CAAC;AAC3B,UAAM,IAAI,GAAG,MAAS;AACtB,UAAM,IAAI,SAAS,GAAG,MAAS;AAC/B,UAAM,IAAI,SAAS,GAAG,IAAI;AAC1B,UAAM,IAAI,SAAS,GAAG,IAAI;AAC1B,UAAM,IAAI,SAAS,GAAG,KAAK;AAC3B;AAAA,EACJ;AACA,UAAQ,IAAI,yBAAyB,SAAS,MAAM;AAChD,UAAM,MAAM,OAAO,SAAU;AAC7B,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,uBAAuB,SAAS,MAAM;AAC9C,UAAM,MAAM;AACZ,UAAM,MAAM,OAAO,QAAS,YAAY,QAAQ;AAChD,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,0BAA0B,SAAS,MAAM;AACjD,UAAM,MAAM,SAAS;AACrB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,4BAA4B,SAAS,MAAM,MAAM;AACzD,UAAM,MAAM,QAAQ;AACpB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,oBAAoB,WAAW;AACvC,UAAM,MAAM,KAAK;AACjB,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,wBAAwB,SAAS,MAAM,MAAM;AACrD,UAAM,MAAM;AACZ,UAAM,MAAM,OAAO,QAAS,WAAW,MAAM;AAC7C,uBAAmB,EAAE,WAAW,OAAO,IAAI,GAAG,WAAW,GAAG,IAAI,IAAI,KAAK,IAAI;AAC7E,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,CAAC,WAAW,GAAG,GAAG,IAAI;AAAA,EACtE;AACA,UAAQ,IAAI,wBAAwB,SAAS,MAAM;AAC/C,UAAM,MAAM;AACZ,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,wBAAwB,SAAS,MAAM,MAAM;AACrD,UAAM,MAAM;AACZ,UAAM,MAAM,OAAO,QAAS,WAAW,MAAM;AAC7C,QAAI,OAAO,WAAW,GAAG,IAAI,IAAI,kBAAkB,KAAK,KAAK,mBAAmB,KAAK,kBAAkB;AACvG,QAAI,OAAO;AACX,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,MAAM,IAAI;AACtD,uBAAmB,EAAE,SAAS,OAAO,IAAI,GAAG,MAAM,IAAI;AAAA,EAC1D;AACA,UAAQ,IAAI,wBAAwB,SAAS,MAAM,MAAM;AACrD,UAAM,MAAM,mBAAmB,MAAM,IAAI;AACzC,WAAO;AAAA,EACX;AACA,UAAQ,IAAI,mBAAmB,SAAS,MAAM,MAAM;AAChD,UAAM,IAAI,MAAM,mBAAmB,MAAM,IAAI,CAAC;AAAA,EAClD;AAEA,SAAO;AACX;AAEA,SAAS,kBAAkB,SAAS,QAAQ;AAE5C;AAEA,SAAS,oBAAoB,UAAU,QAAQ;AAC3C,SAAO,SAAS;AAChB,aAAW,yBAAyB;AACpC,0BAAwB;AACxB,4BAA0B;AAG1B,OAAK,iBAAiB;AACtB,SAAO;AACX;AA2BA,eAAe,WAAW,gBAAgB;AACtC,MAAI,SAAS,OAAW,QAAO;AAG/B,MAAI,OAAO,mBAAmB,aAAa;AACvC,QAAI,OAAO,eAAe,cAAc,MAAM,OAAO,WAAW;AAC5D,OAAC,EAAC,eAAc,IAAI;AAAA,IACxB,OAAO;AACH,cAAQ,KAAK,2FAA2F;AAAA,IAC5G;AAAA,EACJ;AAEA,MAAI,OAAO,mBAAmB,aAAa;AACvC,qBAAiB,IAAI,IAAI,uBAAuB,YAAY,GAAG;AAAA,EACnE;AACA,QAAM,UAAU,kBAAkB;AAElC,MAAI,OAAO,mBAAmB,YAAa,OAAO,YAAY,cAAc,0BAA0B,WAAa,OAAO,QAAQ,cAAc,0BAA0B,KAAM;AAC5K,qBAAiB,MAAM,cAAc;AAAA,EACzC;AAEA,oBAAkB,OAAO;AAEzB,QAAM,EAAE,UAAU,OAAO,IAAI,MAAM,WAAW,MAAM,gBAAgB,OAAO;AAE3E,SAAO,oBAAoB,UAAU,MAAM;AAC/C;AAGA,IAAO,sBAAQ;;;AC1kBf,eAAsB,gBAAgB,KAAc;AACnD,QAAM,oBAAK,EAAE,gBAAgB,IAAI,CAAC;AAElC,WAAS,WACR,SACA,OACA,eAA6B,OACf;AACd,UAAM,UAAU,IAAI,YAAY,OAAO;AAEvC,QAAI,iBAAiB,OAAO;AAC3B,YAAM,IAAI,MAAM,8BAA8B,YAAY,EAAE;IAC7D;AAEA,UAAM,CAAC,aAAa,UAAU,QAAQ,IAAI,QAAQ,qBAAqB,KAAK;AAE5E,WAAO;MACN;MACA,QAAQ,gBAAgB,IAAI,WAAW,SAAS,OAAO,CAAC;MACxD,UAAU,SAAS;MACnB,UAAU,IAAI,WAAW,SAAS,MAAM;IACzC;EACD;AAEA,WAAS,kBACR,eACA,eAC6B;AAC7B,UAAM,YAAY;MACjB,cAAc,IAAI,CAAC,iBAAiB,WAAW,aAAa,SAAS,CAAC;IACvE;AAEA,WAAO;MACN,SAAS;MACT,mBAAmB,WAAW,cAAc,CAAC,EAAE,iBAAiB;MAChE;IACD;EACD;AAEA,WAAS,qBACR,QACA,SACA,MACA,SACA,eAA6B,OAChB;AACb,UAAM,UAAU,IAAI,YAAY,OAAO;AAEvC,QAAI,iBAAiB,OAAO;AAC3B,YAAM,IAAI,MAAM,8BAA8B,YAAY,EAAE;IAC7D;AAEA,UAAM,CAAC,KAAK,IAAI,QAAQ;MACvB,OAAO,UAAU,MAAM,EAAE,QAAQ;MACjC,OAAO,IAAI;MACX,QAAQ,IAAI,CAAC,YAAY;QACxB,GAAG;QACH,cAAc;MACf,EAAE;IACH;AAEA,WAAO,IAAI,WAAW,KAAK;EAC5B;AAEA,WAAS,qBAAqB;AAC7B,WAAO,CAAC,cAAmC,cAC1C;MACC,WAAW,aAAa,SAAS;MACjC;MACA,WAAW,aAAa,iBAAiB;IAC1C;EACF;AAEA,WAAS,gBACR,SACA,OACA,eAA6B,OACsD;AACnF,UAAM,UAAU,IAAI,YAAY,OAAO;AACvC,UAAM,CAAC,UAAU,QAAQ,IAAI,QAAQ,iBAAiB,KAAK;AAE3D,QAAI,iBAAiB,OAAO;AAC3B,YAAM,IAAI,MAAM,8BAA8B,YAAY,EAAE;IAC7D;AAEA,WAAO;MACN,GAAG;MACH,QAAQ,gBAAgB,IAAI,WAAW,SAAS,OAAO,CAAC;MACxD,UAAU,IAAI,WAAW,SAAS,MAAM;IACzC;EACD;AAEA,SAAO;IACN;IACA;IACA;IACA;IACA;EACD;AACD;;;;;;;;;;;ACzHA,IAAAC;AAAA,IAAAC;AAAA,IAAAC;AAAA,IAAA;AAAA,IAAAC;AAwDO,IAAM,oBAAN,MAAwB;EAK9B,YAAY,EAAE,MAAM,OAAO,iBAAiB,SAAS,QAAQ,GAA6B;AALpF,IAAAC,cAAA,MAAA,4BAAA;AAEN,IAAAA,cAAA,MAAAJ,OAAA;AACA,IAAAI,cAAA,MAAAH,SAAA;AACA,IAAAG,cAAA,MAAAF,SAAA;AAEC,SAAK,OAAO;AACZ,IAAAG,cAAA,MAAKL,SAAS,mBAAmB,WAAW,KAAA;AAC5C,IAAAK,cAAA,MAAKJ,WAAW,WAAW,GAAA;AAC3B,IAAAI,cAAA,MAAKH,WAAW,OAAA;EACjB;EAEA,MAAM,YAAkD;AACvD,UAAM,WAAW,MAAMI,iBAAA,MAAK,8BAAAH,WAAA,EAAL,KAAA,MAAc;MACpC,QAAQ;MACR,MAAM;IACP,CAAA;AAEA,UAAM,OAAQ,MAAM,SAAS,KAAK;AAkBlC,QAAI,OAAO,SAAS,UAAU;AAC7B,aAAO;IACR;AAEA,QAAI,WAAW,KAAK,SAAS,MAAM;AAClC,aAAO;QACN,SAAS,KAAK,SAAS;QACvB,MAAM;UACL,OAAO,KAAK,SAAS,KAAK;QAC3B;MACD;IACD;AAEA,WAAO;MACN,SAAS,KAAK,SAAS;MACvB,MAAM;QACL,QAAQ;UACP,MAAM,KAAK,SAAS,KAAK,OAAO;UAChC,eAAe,KAAK,SAAS,KAAK,OAAO;QAC1C;MACD;IACD;EACD;EAEA,MAAM,UAAU;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,GAAG;EACJ,GAGG;AACF,UAAM,QAAQ,IAAI,gBAAgB;MACjC,SAAS;IACV,CAAC;AAED,QAAI,aAAa;AAChB,YAAM,IAAI,SAAS,cAAc,KAAK,CAAC;AACvC,YAAM,IAAI,SAAS,QAAQ;IAC5B;AAEA,QAAI,WAAW;AACd,YAAM,IAAI,yBAAyB,YAAY;IAChD;AAEA,QAAI,cAAc;AACjB,YAAM,IAAI,iBAAiB,YAAY;IACxC;AAEA,UAAM,WAAW,MAAMG,iBAAA,MAAK,8BAAAH,WAAA,EAAL,KAAA,MAAc;MACpC,QAAQ;MACR,MAAM,yBAAyB,MAAM,SAAS,CAAC;MAC/C,MAAM;MACN,GAAG;IACJ,CAAA;AAEA,UAAM,OAOF,MAAM,SAAS,KAAK;AAExB,WAAO;MACN;MACA,aAAa;QACZ,SAAS,KAAK,yBAAyB;QACvC,mBAAmB,IAAI,WAAW,KAAK,yBAAyB,kBAAkB;QAClF,WAAW,kBAAkB,KAAK,yBAAyB,SAAS;MACrE;IACD;EACD;AA8CD;AA/JCH,UAAA,oBAAA,QAAA;AACAC,YAAA,oBAAA,QAAA;AACAC,YAAA,oBAAA,QAAA;AAJM,+BAAA,oBAAA,QAAA;AAqHAC,cAAQ,eAAC,SAAyB;AA7KzC,MAAA,IAAA,IAAA;AA8KE,QAAM,EAAE,QAAQ,SAAS,GAAG,KAAK,IAAI;AAErC,MAAI,iCAAQ,SAAS;AACpB,UAAM,IAAI,eAAe;EAC1B;AAEA,QAAM,gBAAgB,YAAY,QAAQ,WAAWI,cAAA,MAAKN,SAAA,CAAQ;AAElE,MAAI;AAEJ,MAAI;AACH,UAAMO,SAAQD,cAAA,MAAKP,OAAA;AACnB,eAAW,MAAMQ,OAAM,GAAG,KAAK,IAAI,GAAG,QAAQ,IAAI,IAAI;MACrD,GAAG;MACH,QAAQ,SAAS,YAAY,IAAI,CAAC,eAAe,MAAM,CAAC,IAAI;IAC7D,CAAC;EACF,SAAS,OAAO;AACf,QAAI,iCAAQ,SAAS;AACpB,YAAM,IAAI,eAAe;IAC1B;AAEA,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AAC1D,YAAMC,SAAQ,IAAI,uBAAuB;AACzC,OAAA,KAAAF,cAAA,MAAKL,SAAA,MAAL,OAAA,SAAA,GAAA,KAAA,MAAgBO,MAAAA;AAChB,YAAMA;IACP;AAEA,KAAA,KAAAF,cAAA,MAAKL,SAAA,MAAL,OAAA,SAAA,GAAA,KAAA,MAAgB,KAAA;AAEhB,UAAM;EACP;AAEA,MAAI,CAAC,SAAS,IAAI;AACjB,UAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,CAAC,WAAW,MAAM;AAChE,UAAM,YAAYQ,eAAc,SAAS;AACzC,UAAM,eAAe,YAAY,SAAY;AAC7C,UAAM,QAAQ,oBAAoB,SAAS,SAAS,QAAQ,WAAW,YAAY;AACnF,KAAA,KAAAH,cAAA,MAAKL,SAAA,MAAL,OAAA,SAAA,GAAA,KAAA,MAAgB,KAAA;AAChB,UAAM;EACP;AAEA,SAAO;AACR;AAGD,SAASQ,eAAc,OAAe;AACrC,MAAI;AACH,WAAO,KAAK,MAAM,KAAK;EACxB,QAAQ;AACP,WAAO;EACR;AACD;;;AClNO,IAAM,gCAAgC;AACtC,IAAM,6BAA6B;AACnC,IAAM,0BAA0B,6BAA6B;AAC7D,IAAM,+BAA+B,IAAI,IAAI;AAE7C,IAAM,oCAAoC;AAC1C,IAAM,yBAAyB;AAC/B,IAAM,oCAAoC,KAAM,IAAI,qCAAsC;AAC1F,IAAM,kCAAkC;AAExC,IAAM,gBAAgB,KAAK;AAqB3B,SAAS,kBACf,YACA,UACA,OACA,4BACA,eAA6B,OACpB;AACT,MAAI,WAAW,SAAS,UAAU;AACjC,UAAM,IAAI,MAAM,6EAA6E;EAC9F;AAEA,MAAI,WAAW,WAAW,GAAG;AAC5B,UAAM,IAAI,MAAM,mBAAmB;EACpC;AAEA,MAAI,SAAS,KAAK;IACjB,WAAW,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC,KAAK,WAAW;IAC9D,WAAW,CAAC,KAAK,QAAQ;IACzB,KAAK,KAAK,0BAA0B,KAAK;EAC1C;AAEA,MAAI,SAAS,KAAK,KAAM,KAAK,IAAI,GAAG,UAAU,KAAK,WAAW,WAAW,UAAW,KAAK;AAEzF,SAAO,SAAS,QAAQ;AACvB,UAAM,OAAO,SAAS,UAAU;AAChC,QAAI,sBAAsB,YAAY,UAAU,MAAM,KAAK,GAAG;AAC7D,eAAS;IACV,OAAO;AACN,eAAS,MAAM;IAChB;EACD;AAEA,QAAM,aACL,KAAK,KAAK,SAAS,oCAAoC,YAAY,CAAC,IACpE,oCAAoC,YAAY;AAEjD,MAAI,CAAC,sBAAsB,YAAY,UAAU,aAAa,KAAK,GAAG;AACrE,UAAM,IAAI,MAAM,gBAAgB;EACjC;AAEA,MAAI,aAAa,iCAAiC,YAAY,GAAG;AAChE,UAAM,IAAI;MACT,6CAA6C,UAAU,2CAA2C,iCAAiC,YAAY,CAAC;IACjJ;EACD;AAEA,SAAO;AACR;AAEA,SAAS,sBACR,YACA,UACA,YACU;AACV,SAAO,WAAW,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,KAAK,OAAO,UAAU,GAAG,CAAC,KAAK;AACnF;AAEO,SAAS,kBAAkB,IAAY;AAC7C,SAAO,aAAa,MAAM,kBAAkB,EAAE,CAAC;AAChD;AAEO,SAAS,mBAAmB,IAAqC;AACvE,SAAO,cAAc,aAAa,UAAU,EAAE,EAAE,QAAQ,CAAC;AAC1D;AAEO,SAAS,cAAc,IAAY;AACzC,QAAM,QAAQ,kBAAkB,EAAE;AAElC,MAAI,MAAM,WAAW,IAAI;AACxB,WAAO;MACN,MAAM;MACN;IACD;EACD;AAEA,SAAO;IACN,MAAM;IACN,IAAI,kBAAkB,EAAE;EACzB;AACD;AAYO,SAAS,YAAY,EAAE,OAAO,WAAW,aAAa,GAAuB;AACnF,QAAM,EAAE,gBAAgB,OAAO,kBAAkB,MAAM,IAAI;IAC1D;IACA;EACD;AAEA,QAAM,cAAc,MAAM,KAAK,CAAC,GAAG,MAAO,EAAE,aAAa,EAAE,aAAa,KAAK,CAAE;AAC/E,QAAM,cAAc,oBAAI,IAAY;AACpC,QAAM,QAAQ;IACb,SAAS,CAAC;EACX;AACA,QAAM,OAAO,YAAY;IAAI,CAAC,SAC7B,KAAK,QAAQ,OAAO,KAAK,KAAK,IAAI,EAAE,SAAS,IAC1C,eAAe,UAAU,KAAK,IAAI,EAAE,QAAQ,IAC5C;EACJ;AAEA,aAAW,QAAQ,aAAa;AAC/B,QAAI,YAAY,IAAI,KAAK,UAAU,GAAG;AACrC,YAAM,IAAI,MAAM,8BAA8B,KAAK,UAAU,EAAE;IAChE;AACA,gBAAY,IAAI,KAAK,UAAU;AAC/B,UAAM,QAAQ,KAAK;MAClB,YAAY;MACZ,UAAU;MACV,YAAY,KAAK;MACjB,MAAM,KAAK,QAAQ,CAAC;IACrB,CAAC;EACF;AAEA,QAAM,YAAY,0BAA0B,aAAa,UAAU,KAAK,EAAE,QAAQ,EAAE;AACpF,QAAM,eAAe,YAAY,IAAI,CAAC,MAAM,MAAM;AACjD,UAAM,kBAAkB,IAAI,OAAO,EAAE,UAAU,KAAK,UAAU,EAAE,QAAQ;AACxE,QAAI,eACH,+BAA+B,oCAAoC,gBAAgB;AAEpF,QAAI,OAAO;AACX,QAAI,SAAS;AAEb,QAAI,KAAK,CAAC,GAAG;AACZ,sBAAgB,yBAAyB,KAAK,CAAC,EAAE;AACjD,cAAQ,iBAAiB;IAC1B;AAEA,UAAM,WAAW,IAAI,WAAW,YAAY;AAC5C,UAAM,eAAe,IAAI,SAAS,SAAS,MAAM;AAEjD,UAAM,SAAS,qBAAqB,UAAU;MAC7C,SAAS;MACT,QAAQ,eAAe,+BAA+B,KAAK,SAAS;MACpE;IACD,CAAC,EAAE,QAAQ;AAEX,aAAS,IAAI,QAAQ,MAAM;AAC3B,cAAU,OAAO;AAEjB,iBAAa,UAAU,QAAQ,gBAAgB,QAAQ,IAAI;AAC3D,cAAU;AACV,aAAS,IAAI,iBAAiB,MAAM;AACpC,cAAU,gBAAgB;AAE1B,QAAI,KAAK,CAAC,GAAG;AACZ,mBAAa,UAAU,QAAQ,KAAK,CAAC,EAAE,QAAQ,IAAI;AACnD,gBAAU;AACV,eAAS,IAAI,KAAK,CAAC,GAAG,MAAM;AAC5B,gBAAU,KAAK,CAAC,EAAE;IACnB;AAEA,WAAO;EACR,CAAC;AAED,QAAM,YAAY;IACjB;IACA,GAAG,YAAY,IAAI,CAAC,MAAM,MAAM;AAC/B,UAAI,KAAK,WAAW,SAAS,kCAAkC;AAC9D,cAAM,IAAI,MAAM,6BAA6B,KAAK,UAAU,EAAE;MAC/D;AAEA,aAAO,aAAa,CAAC,EAAE,SAAS,KAAK,SAAS;IAC/C,CAAC;EACF;AAEA,QAAM,aAAa;IAClB;IACA;IACA;IACA;IACA;EACD;AAEA,QAAM,UAAU,aAAa;AAC7B,QAAM,aAAa,aAAa;AAChC,QAAM,qBAAqB,KAAK,KAAK,YAAY,UAAU;AAE3D,MAAI,qBAAqB,iCAAiC;AACzD,UAAM,IAAI,MAAM,iBAAiB;EAClC;AAEA,QAAM,QAAQ,IAAI,WAAW,UAAU,KAAK;AAC5C,MAAI,gBAAgB;AAEpB,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC5C,UAAM,OAAO,YAAY,CAAC;AAC1B,UAAM,QAAQ,CAAC,EAAE,aAAa;AAC9B,qBAAiB;MAChB;MACA,KAAK;MACL;MACA;MACA;MACA;MACA,aAAa,CAAC;IACf;AACA,UAAM,QAAQ,CAAC,EAAE,WAAW;EAC7B;AAEA,QAAM,aAAa,aAAa,UAAU,KAAK,EAAE,QAAQ;AACzD,QAAM,aAAa,IAAI,WAAW,0BAA0B,WAAW,MAAM;AAC7E,QAAM,OAAO,IAAI,SAAS,WAAW,MAAM;AAC3C,OAAK,SAAS,GAAG,CAAC;AAClB,OAAK,UAAU,GAAG,WAAW,QAAQ,IAAI;AACzC,aAAW,IAAI,YAAY,uBAAuB;AAElD,mBAAiB,OAAO,YAAY,SAAS,YAAY,YAAY,CAAC;AAEtE,SAAO,EAAE,OAAO,MAAM;AACvB;AAEA,SAAS,iBACR,OACA,MACA,SACA,YACA,YACA,aACA,QACC;AACD,QAAM,QAAQ,aAAa;AAC3B,MAAI,eAAe;AAEnB,MAAI,UAAU,eAAe,GAAG;AAC/B,UAAM,IAAI,MAAM,2CAA2C;EAC5D;AAEA,MAAI,aAAa,eAAe,GAAG;AAClC,UAAM,IAAI,MAAM,8CAA8C;EAC/D;AAEA,MAAI,QAAQ;AACX,eAAW,MAAM;EAClB;AAEA,aAAW,IAAI;AAEf,SAAO,KAAK,KAAK,eAAe,UAAU;AAE1C,WAAS,WAAW,OAAmB;AACtC,UAAM,SAAS;AACf,UAAM,gBAAgB,KAAK,MAAM,SAAS,UAAU;AACpD,QAAI,kBAAkB,SAAS;AAC/B,QAAI,aAAa,cAAc,KAAK,MAAM,gBAAgB,KAAK;AAC/D,QAAI,aAAa,gBAAgB;AAEjC,QAAI,QAAQ;AACZ,WAAO,QAAQ,MAAM,QAAQ;AAC5B,YAAM,YAAY,aAAa,UAAU,aAAa;AACtD,YAAM,aAAa,YAAY;AAC/B,YAAM,MAAM,KAAK,IAAI,aAAa,iBAAiB,MAAM,SAAS,KAAK;AAEvE,eAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC7B,cAAM,aAAa,CAAC,IAAI,MAAM,QAAQ,CAAC;MACxC;AACA,eAAS;AACT,wBAAkB;AAClB,oBAAc,aAAa,KAAK;AAChC,UAAI,eAAe,GAAG;AACrB;MACD;IACD;AAEA,oBAAgB,MAAM;EACvB;AACD;;;;;;;;;;AC/TA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAcO,IAAM,kBAAN,MAA4C;EAMlD,YAAY;IACX;IACA;IACA;IACA;EACD,GAKG;AAfH,IAAAC,cAAA,MAAA,MAAA;AACA,IAAAA,cAAA,MAAA,YAAA;AACA,IAAAA,cAAA,MAAA,WAAA;AACA,IAAAA,cAAA,MAAA,KAAA;AAaC,IAAAC,cAAA,MAAK,QAAS,KAAA;AACd,IAAAA,cAAA,MAAK,cAAe,WAAA;AACpB,IAAAA,cAAA,MAAK,aAAc,cAAc,IAAA;AACjC,IAAAA,cAAA,MAAK,OAAQ,IAAA;EACd;EAEA,MAAM,WAAgC;AACrC,UAAM,EAAE,cAAc,YAAY,KAAK,IAAI,MAAMC,cAAA,MAAK,MAAA,EAAO,SAASA,cAAA,MAAK,YAAA,CAAY;AACvF,IAAAD,cAAA,MAAK,aAAc,UAAA;AACnB,IAAAA,cAAA,MAAK,OAAQ,QAAQ,CAAC,CAAA;AACtB,WAAO;EACR;EAEA,MAAM,gBAAgB;AACrB,QAAIC,cAAA,MAAK,WAAA,MAAgB,MAAM;AAC9B,aAAOA,cAAA,MAAK,WAAA;IACb;AAEA,UAAM,SAAS,MAAMA,cAAA,MAAK,MAAA,EAAO,cAAcA,cAAA,MAAK,YAAA,CAAY;AAEhE,IAAAD,cAAA,MAAK,aAAc,OAAO,UAAA;AAC1B,WAAOC,cAAA,MAAK,WAAA;EACb;EAEA,MAAM,UAAU;AACf,QAAIA,cAAA,MAAK,KAAA,MAAU,QAAW;AAC7B,aAAOA,cAAA,MAAK,KAAA;IACb;AAEA,UAAM,SAAS,MAAMA,cAAA,MAAK,MAAA,EAAO,cAAcA,cAAA,MAAK,YAAA,CAAY;AAChE,IAAAD,cAAA,MAAK,OAAQ,OAAO,QAAQ,CAAC,CAAA;AAC7B,WAAOC,cAAA,MAAK,KAAA;EACb;AACD;AAjDC,SAAA,oBAAA,QAAA;AACA,eAAA,oBAAA,QAAA;AACA,cAAA,oBAAA,QAAA;AACA,QAAA,oBAAA,QAAA;;;;;;;;;;;AClBD,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAqBO,IAAM,cAAN,MAAkB;EAIxB,YAAY,EAAE,KAAK,GAAuB;AAJpC,IAAAC,cAAA,MAAA,sBAAA;AACN,IAAAA,cAAA,MAAA,KAAA;AACA,IAAAA,cAAA,MAAA,QAAS,IAAI,YAAY,CAAA;AAGxB,IAAAC,cAAA,MAAK,OAAQ,IAAA;EACd;EAgHA,MAAM,cAAc,aAAqB;AACxC,WAAOC,cAAA,MAAK,MAAA,EAAO,KAAK,CAAC,iBAAiB,YAAY,SAAS,CAAC,GAAG,YAAY;AAC9E,YAAM,aAAa,qBAAqB;QACvC,MAAMC,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,aAAa,4BAAA;MACpC;AAEA,UAAI,SAAS;AACb,UAAI,WAAW,WAAW;AAE1B,YAAM,mBAAmB,IAAI;SAC3B,MAAMA,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,aAAa,GAAG,MAAA,GAAS;MACjD,EAAE,UAAU,GAAG,IAAI;AACnB,kBAAY,IAAI;AAChB,gBAAU;AAEV,YAAM,aAAa,IACjB,OAAO,EACP,MAAM,MAAMA,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,aAAa,kBAAkB,MAAA,CAAO;AAEpE,gBAAU;AAEV,UAAI,OAAsC;AAC1C,UAAI,WAAW,OAAO,eAAe;AACpC,cAAM,WAAW,IAAI;WACnB,MAAMA,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,aAAa,GAAG,MAAA,GAAS;QACjD,EAAE,UAAU,GAAG,IAAI;AACnB,kBAAU;AAEV,eAAO,eAAe,MAAM,MAAMA,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,aAAa,UAAU,MAAA,CAAO;AAChF,oBAAY,WAAW;AACvB,kBAAU;MACX;AAEA,aAAO;QACN;QACA;QACA;QACA,eAAe;MAChB;IACD,CAAC;EACF;EAEA,MAAM,SAAS,aAAqB;AACnC,UAAM,EAAE,YAAY,MAAM,UAAU,cAAc,IAAI,MAAM,KAAK,cAAc,WAAW;AAE1F,UAAM,eAAe,MAAMA,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,aAAa,UAAU,aAAA;AAElE,WAAO;MACN;MACA;MACA;IACD;EACD;EAEA,iBAAiB,IAAY;AAC5B,UAAM,EAAE,SAAS,QAAQ,IAAI,kBAAkB,EAAE;AAEjD,QAAI,YAAYD,cAAA,MAAK,KAAA,EAAM,QAAQ;AAClC,YAAM,IAAI;QACT,uBAAuB,OAAO,6BAA6BA,cAAA,MAAK,KAAA,EAAM,MAAM;MAC7E;IACD;AAEA,WAAO,IAAI,gBAAgB,EAAE,OAAO,MAAM,aAAa,QAAQ,WAAW,CAAC;EAC5E;EAEA,MAAM,YAAY;AACjB,UAAM,SAAS,IAAI,UAAU,MAAMC,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,GAAG,CAAA,GAAI,MAAM;AAEhE,UAAM,UAAU,OAAO,SAAS,CAAC;AAEjC,QAAI,YAAY,GAAG;AAClB,YAAM,IAAI,MAAM,6BAA6B,OAAO,EAAE;IACvD;AAEA,UAAM,YAAY,OAAO,UAAU,GAAG,IAAI;AAC1C,UAAM,aAAa,MAAMA,iBAAA,MAAK,wBAAA,YAAA,EAAL,KAAA,MAAgB,GAAG,WAAW,CAAA;AACvD,UAAM,aAAa,MAAMD,cAAA,MAAK,KAAA,EAAM,cAAc;AAClD,UAAM,eAAe,KAAK,KAAK,YAAY,UAAU;AACrD,UAAM,QAAQ,aAAa,MAAM,UAAU;AAE3C,WAAO,MAAM,QAAQ,IAAI,CAAC,OAAO,MAAM;AACtC,YAAM,aAAa,MAAM,IAAI,eAAe,MAAM,QAAQ,IAAI,CAAC,EAAE;AACjE,YAAM,SAAS,IAAI,gBAAgB;QAClC,OAAO;QACP,aAAa;QACb,YAAY,MAAM;QAClB,MAAM,MAAM;MACb,CAAC;AAED,aAAO;QACN,YAAY,MAAM;QAClB,SAAS;UACR,aAAa,UAAU;YACtB,SAASA,cAAA,MAAK,KAAA,EAAM;YACpB,SAAS;cACR,SAAS;cACT;cACA,UAAU,MAAM;YACjB;UACD,CAAC,EAAE,QAAQ;QACZ;QACA,MAAM,MAAM;QACZ;MACD;IACD,CAAC;EACF;AACD;AAhOC,QAAA,oBAAA,QAAA;AACA,SAAA,oBAAA,QAAA;AAFM,yBAAA,oBAAA,QAAA;AAQA,0BAAqB,eAAC,QAAgB,QAAgB,SAAS,GAAG,YAAqB;AAC5F,MAAI,CAAC,QAAQ;AACZ,WAAO,IAAI,WAAW,CAAC;EACxB;AAGA,EAAAA,cAAA,MAAK,KAAA,EAAM,mBAAmB,EAAE,aAAa,OAAO,CAAC,EAAE,MAAM,MAAM;EAAC,CAAC;AAErE,eAAa,cAAe,MAAMA,cAAA,MAAK,KAAA,EAAM,cAAc;AAC3D,QAAM,eAAe,KAAK,MAAM,SAAS,UAAU;AACnD,MAAI,kBAAkB,SAAS;AAC/B,QAAM,QAAQ,IAAI,WAAW,MAAM;AAEnC,MAAI,YAAY;AAEhB,QAAM,WAAW,KAAK,KAAK,SAAS,UAAU;AAC9C,QAAM,UAAU,IAAI,MAAM,QAAQ,EAChC,KAAK,CAAC,EACN,IAAI,CAAC,GAAG,MAAMA,cAAA,MAAK,KAAA,EAAM,mBAAmB,EAAE,aAAa,SAAS,eAAe,EAAE,CAAC,CAAC;AAGzF,UAAQ,QAAQ,CAAC,MAAM,EAAE,MAAM,MAAM;EAAC,CAAC,CAAC;AAExC,aAAW,iBAAiB,SAAS;AACpC,UAAME,UAAS,MAAM;AACrB,QAAIC,SAAQ,kBAAkB,IAAID,QAAO,SAAS,eAAe,IAAIA;AACrE,uBAAmBC,OAAM;AACzB,QAAIA,OAAM,SAAS,SAAS,WAAW;AACtC,MAAAA,SAAQA,OAAM,SAAS,GAAG,SAAS,SAAS;IAC7C;AAEA,UAAM,IAAIA,QAAO,SAAS;AAC1B,iBAAaA,OAAM;AAEnB,QAAI,aAAa,QAAQ;AACxB;IACD;EACD;AAEA,SAAO;AACR;AAEM,uBAAkB,eAAC,aAAqB,QAAgB,SAAS,GAAG;AACzE,QAAM,SAAS,IAAI,WAAW,MAAM;AAEpC,MAAI,CAAC,QAAQ;AACZ,WAAO;EACR;AACA,QAAM,OAAO,MAAMH,cAAA,MAAK,KAAA,EAAM,SAAS;AAEvC,QAAM,CAAC,SAAS,UAAU,IAAI,MAAM,QAAQ,IAAI;IAC/CA,cAAA,MAAK,KAAA,EAAM,WAAW;IACtBA,cAAA,MAAK,KAAA,EAAM,cAAc;EAC1B,CAAC;AAED,QAAM,QAAQ,KAAK,SAAS;AAC5B,QAAM,gBAAgB,KAAK,MAAM,SAAS,UAAU;AACpD,MAAI,kBAAkB,SAAS;AAC/B,MAAI,aAAa,cAAc,KAAK,MAAM,gBAAgB,KAAK;AAC/D,MAAI,aAAa,gBAAgB;AAEjC,MAAI,YAAY;AAEhB,SAAO,YAAY,QAAQ;AAC1B,UAAM,YAAY,aAAa,UAAU,aAAa;AACtD,UAAM,aAAa,YAAY;AAC/B,UAAM,WAAW,KAAK;MACrB,YAAY;MACZ,aAAa,SAAS;MACtB,KAAK;IACN;AAEA,QAAI,cAAc,KAAK,QAAQ;AAC9B,YAAM,IAAI,MAAM,qBAAqB;IACtC;AAEA,UAAM,OAAO,WAAW;AAExB,aAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC9B,aAAO,YAAY,CAAC,IAAI,KAAK,aAAa,CAAC;IAC5C;AAEA,iBAAa;AAEb,sBAAkB;AAElB,kBAAc,aAAa,KAAK;AAChC,QAAI,eAAe,GAAG;AACrB,oBAAc;IACf;EACD;AAEA,SAAO;AACR;AAEM,eAAU,eAAC,QAAgB,QAAgB,SAAS,GAAG,YAAqB;AACjF,MAAIA,cAAA,MAAK,KAAA,EAAM,2BAA2B;AACzC,WAAOC,iBAAA,MAAK,wBAAA,oBAAA,EAAL,KAAA,MAAwB,QAAQ,QAAQ,MAAA;EAChD;AAEA,MAAI;AACH,UAAM,QAAQ,MAAMA,iBAAA,MAAK,wBAAA,uBAAA,EAAL,KAAA,MAA2B,QAAQ,QAAQ,QAAQ,UAAA;AAEvE,WAAO;EACR,QAAQ;AAEP,WAAOA,iBAAA,MAAK,wBAAA,oBAAA,EAAL,KAAA,MAAwB,QAAQ,QAAQ,MAAA;EAChD;AACD;;;;;;;;;;ACzID,IAAAG;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAcO,IAAM,aAAN,MAAuC;EAU7C,YAAY,EAAE,QAAQ,QAAQ,UAAU,GAAsB;AAP9D,IAAAC,cAAA,MAAAD,SAAS,IAAI,YAAY,CAAA;AAEzB,IAAAC,cAAA,MAAA,OAAA;AACA,IAAAA,cAAA,MAAA,mBAAoB,oBAAI,IAA8C,CAAA;AACtE,SAAA,4BAA4B;AAC5B,IAAAA,cAAA,MAAA,UAAA;AAGC,IAAAC,cAAA,MAAK,SAAU,MAAA;AACf,SAAK,SAAS;AACd,IAAAA,cAAA,MAAK,YAAa,SAAA;EACnB;EAEA,MAAM,gBAAgB;AACrB,WAAO;EACR;EAEA,MAAM,UAAU;AACf,WAAO,CAAC;EACT;EAEA,iBAAiB;AAChB,WAAO,IAAI,YAAY,EAAE,MAAM,KAAK,CAAC;EACtC;EAEA,MAAM,WAAW;AAChB,WAAOC,cAAA,MAAKH,OAAA,EAAO,KAAK,CAAC,UAAU,GAAG,YAAY;AACjD,WAAK,4BAA4B;AACjC,UAAI;AACH,cAAM,OAAO,MAAMG,cAAA,MAAK,OAAA,EAAQ,SAAS,EAAE,QAAQ,KAAK,OAAO,CAAC;AAChE,eAAO;MACR,SAAS,OAAO;AACf,aAAK,4BAA4B;AACjC,cAAM;MACP;IACD,CAAC;EACF;EAEA,cAAc;AACb,WAAOA,cAAA,MAAKH,OAAA,EAAO;MAAK,CAAC,aAAa;MAAG,MACxCG,cAAA,MAAK,OAAA,EAAQ,gBAAgB,EAAE,QAAQ,KAAK,OAAO,CAAC;IACrD;EACD;EAEA,MAAM,gBAAgB;AACrB,WAAOA,cAAA,MAAKH,OAAA,EAAO,KAAK,CAAC,eAAe,GAAG,YAAY;AACtD,YAAM,iBAAiB,CAAC,GAAGG,cAAA,MAAK,iBAAA,EAAkB,OAAO,CAAC;AAE1D,UAAI,eAAe,SAAS,GAAG;AAC9B,cAAM,SAAS,MAAM,QAAQ,IAAI,cAAc,EAAE,MAAM,MAAM,IAAI;AAEjE,YAAI,QAAQ;AACX,iBAAO,OAAO;QACf;MACD;AAEA,UAAI,KAAK,2BAA2B;AACnC,cAAM,OAAO,MAAM,KAAK,SAAS;AACjC,cAAM,EAAE,YAAAC,YAAW,IAAI,SAAS,KAAK,QAAQD,cAAA,MAAK,UAAA,CAAU;AAC5D,eAAOC;MACR;AAEA,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,YAAM,EAAE,WAAW,IAAI;QACtB,OAAO,SAAS,SAAS,GAAG,gBAAgB;QAC5CD,cAAA,MAAK,UAAA;MACN;AAEA,aAAO;IACR,CAAC;EACF;EAEA,MAAM,gBAAgB;AACrB,UAAM,aAAa,MAAM,KAAK,cAAc;AAC5C,UAAM,EAAE,eAAe,IAAI,iBAAiBA,cAAA,MAAK,UAAA,CAAU;AAE3D,QAAI,aAAa,mBAAmB,GAAG;AACtC,YAAM,IAAI,MAAM,oDAAoD;IACrE;AAEA,WAAO,aAAa;EACrB;EAEA,MAAM,aAAa;AAClB,UAAM,aAAa,MAAM,KAAK,cAAc;AAC5C,UAAM,EAAE,iBAAiB,IAAI,iBAAiBA,cAAA,MAAK,UAAA,CAAU;AAC7D,WAAO,aAAa;EACrB;EAEA,MAAM,mBAAmB,EAAE,aAAa,OAAO,GAAkD;AAChG,QAAIA,cAAA,MAAK,iBAAA,EAAkB,IAAI,WAAW,GAAG;AAC5C,aAAOA,cAAA,MAAK,iBAAA,EAAkB,IAAI,WAAW;IAC9C;AAEA,UAAM,gBAAgBA,cAAA,MAAK,OAAA,EACzB,mBAAmB;MACnB,QAAQ,KAAK;MACb,OAAO;MACP;IACD,CAAC,EACA,KAAK,CAAC,WAAW,IAAI,WAAW,OAAO,QAAQ,IAAI,CAAC;AAEtD,IAAAA,cAAA,MAAK,iBAAA,EAAkB,IAAI,aAAa,aAAa;AAErD,QAAI;AACH,YAAM,SAAS,MAAM;AACrB,MAAAA,cAAA,MAAK,iBAAA,EAAkB,IAAI,aAAa,MAAM;AAC9C,aAAO;IACR,SAAS,OAAO;AACf,MAAAA,cAAA,MAAK,iBAAA,EAAkB,OAAO,WAAW;AACzC,YAAM;IACP;EACD;AACD;AAjHCH,UAAA,oBAAA,QAAA;AAEA,UAAA,oBAAA,QAAA;AACA,oBAAA,oBAAA,QAAA;AAEA,aAAA,oBAAA,QAAA;;;;;;;;;;ACtBD,IAAA;AAAA,IAAAK;AAAA,IAAAC;AAKO,IAAM,cAAN,MAAwC;EAK9C,YAAY;IACX;IACA;IACA;EACD,GAIG;AAZH,IAAAC,cAAA,MAAA,SAAA;AACA,IAAAA,cAAA,MAAAF,YAAA;AACA,IAAAE,cAAA,MAAAD,MAAA;AAWC,IAAAE,cAAA,MAAK,WAAY,QAAA;AACjB,IAAAA,cAAA,MAAKH,cAAc,cAAc,IAAA;AACjC,IAAAG,cAAA,MAAKF,QAAQ,QAAQ,CAAC,CAAA;EACvB;EAEA,MAAM,WAAW;AAChB,QAAI,iBAAiBG,cAAA,MAAK,SAAA,GAAW;AACpC,aAAO,IAAI,WAAW,MAAMA,cAAA,MAAK,SAAA,EAAU,YAAY,CAAC;IACzD;AAEA,WAAOA,cAAA,MAAK,SAAA;EACb;EAEA,MAAM,gBAAgB;AACrB,WAAOA,cAAA,MAAKJ,YAAA;EACb;EAEA,MAAM,UAAU;AACf,WAAOI,cAAA,MAAKH,MAAA;EACb;AACD;AAjCC,YAAA,oBAAA,QAAA;AACAD,eAAA,oBAAA,QAAA;AACAC,SAAA,oBAAA,QAAA;;;;;;;;;;ACRD,IAAA;AAWO,IAAM,cAAN,MAAMI,aAAW;EAavB,YAAY,EAAE,OAAO,GAA2B;AAZhD,IAAAC,cAAA,MAAA,OAAA;AAaC,IAAAC,cAAA,MAAK,SAAU,MAAA;EAChB;EAZA,OAAO,KAAK,SAIT;AACF,WAAO,IAAIF,aAAW;MACrB,QAAQ,IAAI,YAAY,OAAO;IAChC,CAAC;EACF;EAMA,gBAAgB;AACf,WAAOG,cAAA,MAAK,OAAA,EAAQ,cAAc;EACnC;EACA,UAAU;AACT,WAAOA,cAAA,MAAK,OAAA,EAAQ,QAAQ;EAC7B;EAEA,QAAQ;AACP,WAAOA,cAAA,MAAK,OAAA,EAAQ,SAAS;EAC9B;EAEA,MAAM,OAAO;AACZ,UAAM,QAAQ,MAAM,KAAK,MAAM;AAE/B,WAAO,IAAI,YAAY,EAAE,OAAO,KAAK;EACtC;EAEA,MAAM,OAAO;AACZ,WAAO,KAAK,MAAM,MAAM,KAAK,KAAK,CAAC;EACpC;AACD;AApCC,UAAA,oBAAA,QAAA;AADM,IAAM,aAAN;;;;;;;;;;;ACXP,IAAAC;AAAA,IAAAC;AAAA,IAAAC;AAAA,IAAA;AAAA,IAAA;AAQO,IAAM,aAAN,MAAiB;EAKvB,YAAY,EAAE,QAAQ,OAAO,GAAiD;AALxE,IAAAC,eAAA,MAAA,qBAAA;AACN,IAAAA,eAAA,MAAAH,QAAA;AACA,IAAAG,eAAA,MAAAF,QAAA;AACA,IAAAE,eAAA,MAAAD,SAAS,IAAI,YAAY,CAAA;AAGxB,IAAAE,cAAA,MAAKJ,UAAU,MAAA;AACf,IAAAI,cAAA,MAAKH,UAAU,MAAA;EAChB;;EAGA,SAAS;AACR,WAAO,IAAI,WAAW,EAAE,QAAQI,cAAA,MAAKL,QAAA,EAAQ,CAAC;EAC/C;EAEA,MAAM,SAAiC;AACtC,WAAOK,cAAA,MAAKL,QAAA,EAAQ;EACrB;;EAGA,MAAM,MACL,UAII,CAAC,GACJ;AACD,UAAM,cAAc,MAAMK,cAAA,MAAKL,QAAA,EAAQ,eAAe;AACtD,UAAM,QAAQ,MAAM,YAAY,UAAU;AAE1C,UAAM,QAAQ,CAAC;AAEf,eAAW,SAAS,OAAO;AAC1B,UAAI,QAAQ,OAAO,CAAC,QAAQ,IAAI,SAAS,MAAM,OAAO,GAAG;AACxD;MACD;AAEA,UAAI,QAAQ,eAAe,CAAC,QAAQ,YAAY,SAAS,MAAM,UAAU,GAAG;AAC3E;MACD;AAEA,UACC,QAAQ,QACR,CAAC,QAAQ,KAAK;QAAK,CAAC,SACnB,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,SAAS,QAAQ,MAAM,MAAM,KAAK,OAAO,MAAM,QAAQ;MACrF,GACC;AACD;MACD;AAEA,YAAM,KAAK,IAAI,WAAW,EAAE,QAAQ,YAAY,iBAAiB,MAAM,OAAO,EAAE,CAAC,CAAC;IACnF;AAEA,WAAO;EACR;EAQA,MAAM,SAAS;AACd,UAAM,SAAS,MAAMM,iBAAA,MAAK,uBAAA,aAAA,EAAL,KAAA,IAAA;AACrB,WAAO,OAAO,SAAS,eAAe,OAAO,SAAS;EACvD;EAEA,MAAM,cAAc;AACnB,UAAM,SAAS,MAAMA,iBAAA,MAAK,uBAAA,aAAA,EAAL,KAAA,IAAA;AAErB,QAAI,OAAO,SAAS,aAAa;AAChC,aAAO,OAAO;IACf;AAEA,WAAO;EACR;AACD;AA3ECN,WAAA,oBAAA,QAAA;AACAC,WAAA,oBAAA,QAAA;AACAC,UAAA,oBAAA,QAAA;AAHM,wBAAA,oBAAA,QAAA;AAwDA,gBAAW,iBAAG;AACnB,SAAOG,cAAA,MAAKH,OAAA,EAAO;IAAK,CAAC,cAAcG,cAAA,MAAKL,QAAA,EAAQ,MAAM;IAAG,MAC5DK,cAAA,MAAKJ,QAAA,EAAQ,sBAAsB,EAAE,QAAQI,cAAA,MAAKL,QAAA,EAAQ,OAAO,CAAC;EACnE;AACD;;;ACjED,eAAsB,MACrB,IACA,SAMa;AACb,MAAI,YAAY,QAAQ,SAAS;AAEjC,SAAO,YAAY,GAAG;AACrB,QAAI;AACH,mBAAa;AACb,aAAO,MAAM,GAAG;IACjB,SAAS,OAAO;AACf,UAAI,aAAa,KAAM,QAAQ,aAAa,CAAC,QAAQ,UAAU,KAAc,GAAI;AAChF,cAAM;MACP;AAEA,UAAI,QAAQ,OAAO;AAClB,cAAM,IAAI;UAAQ,CAAC,YAClB;YACC;aACC,QAAQ,SAAS,QAAS,QAAQ,SAAS,KAAK,OAAO,IAAI,QAAQ,SAAS;UAC9E;QACD;MACD;IACD;EACD;AAGA,QAAM,IAAI,MAAM,sBAAsB;AACvC;;;;;;;;;;;ACpCA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAAO;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAgIO,SAAS,OAA8B;EAC7C;EACA;EACA,OAAO;EACP,GAAG;AACJ,IAAyB,CAAC,GAAG;AAC5B,SAAO;IACN;IACA,UAAU,CAAC,WAA8B;AACxC,YAAM,gBAAgB,WAAW,OAAO;AAExC,UAAI,kBAAkB,aAAa,kBAAkB,WAAW;AAC/D,cAAM,IAAI,kBAAkB,iDAAiD;MAC9E;AAEA,aAAO,IAAI;QACV,gBACG;UACA;UACA,WAAW;UACX,GAAG;QACJ,IACC;UACA,SAAS;UACT,WAAW;UACX,GAAG;QACJ;MACH;IACD;EACD;AACD;AAEO,IAAM,gBAAN,MAAMC,eAAa;EAgBzB,YAAY,QAA4B;AAhBlC,IAAAC,eAAA,MAAA,uBAAA;AACN,IAAAA,eAAA,MAAA,kBAAA;AACA,IAAAA,eAAA,MAAA,QAAA;AAEA,IAAAA,eAAA,MAAA,cAAA;AACA,IAAAA,eAAA,MAAA,UAAA;AACA,IAAAA,eAAA,MAAA,aAAA;AAEA,IAAAA,eAAA,MAAA,+BAAgC,EAAA;AAChC,IAAAA,eAAA,MAAA,cAAA;AAEA,IAAAA,eAAA,MAAAF,OAAA;AAEA,IAAAE,eAAA,MAAA,oBAA+C,IAAA;AAC/C,IAAAA,eAAA,MAAA,oBAA+C,IAAA;AAsJ/C,SAAA,WAAWC,iBAAA,MAAK,yBAAA,6BAAA,EAAL,KAAA,MAAiCA,iBAAA,MAAK,yBAAA,mBAAA,CAAA;AAiJjD,SAAA,qBAAqBA,iBAAA,MAAK,yBAAA,6BAAA,EAAL,KAAA,MAAiC,KAAK,0BAAA;AApS1D,QAAI,OAAO,WAAW,CAAC,OAAO,eAAe;AAC5C,YAAM,UAAU,OAAO;AACvB,cAAQ,SAAS;QAChB,KAAK;AACJ,UAAAC,cAAA,MAAK,gBAAiB,6BAAA;AACtB;QACD,KAAK;AACJ,UAAAA,cAAA,MAAK,gBAAiB,6BAAA;AACtB;QACD;AACC,gBAAM,IAAI,kBAAkB,wBAAwB,OAAO,EAAE;MAC/D;IACD,OAAO;AACN,MAAAA,cAAA,MAAK,gBAAiB,OAAO,aAAA;IAC9B;AAEA,IAAAA,cAAA,MAAK,UAAW,OAAO,OAAA;AACvB,IAAAA,cAAA,MAAK,oBAAqB,OAAO,eAAe,IAAA;AAChD,QAAIC,eAAA,MAAK,kBAAA,GAAoB;AAC5B,MAAAD,cAAA,MAAK,oBAAqB,IAAI,kBAAkBC,eAAA,MAAK,kBAAA,CAAkB,CAAA;IACxE;AAEA,IAAAD,cAAA,MAAK,YACJ,OAAO,aACP,IAAI,iBAAU;MACb,KAAK,OAAO;IACb,CAAC,CAAA;AAEF,IAAAA,cAAA,MAAK,oBAAqB,IAAI,kBAAkB,OAAO,wBAAwB,CAAA;AAC/E,IAAAA,cAAA,MAAK,eAAgB,IAAI,oBAAoBC,eAAA,MAAK,UAAA,CAAU,CAAA;AAC5D,IAAAD,cAAA,MAAKJ,SAASK,eAAA,MAAK,UAAA,EAAW,MAAM,MAAM,gBAAgB,CAAA;EAC3D;;EAGA,OAAO,+BAA+B;IACrC;IACA;IACA,GAAG;EACJ,IAAkC,CAAC,GAAG;AACrC,WAAO;MACN,MAAM;MACN,UAAU,CAAC,WAA8B;AACxC,cAAM,gBAAgB,WAAW,OAAO;AAExC,YAAI,kBAAkB,aAAa,kBAAkB,WAAW;AAC/D,gBAAM,IAAI,kBAAkB,iDAAiD;QAC9E;AAEA,eAAO,IAAIJ;UACV,gBACG;YACA;YACA,WAAW;YACX,GAAG;UACJ,IACC;YACA,SAAS;YACT,WAAW;YACX,GAAG;UACJ;QACH;MACD;IACD;EACD;;EA+BA,cAAc;AACb,WAAOI,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,aAAa,GAAG,YAAY;AACpD,aAAO,GAAG,MAAMG,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,IAAA,CAAoB;IACrC,CAAC;EACF;;EAgBA,eAAe;AACd,WAAOE,eAAA,MAAK,aAAA,EAAc,KAAKA,eAAA,MAAK,cAAA,EAAe,gBAAgB,MAAM;EAC1E;;EAGA,gBAAgB;AACf,WAAOA,eAAA,MAAK,aAAA,EAAc,KAAKA,eAAA,MAAK,cAAA,EAAe,eAAe,OAAO;EAC1E;;EAGA,MAAM,cAAc;AACnB,UAAM,cAAc,MAAMA,eAAA,MAAK,aAAA,EAAc;MAC5CA,eAAA,MAAK,cAAA,EAAe;MACpB,EAAE,MAAM,OAAO,QAAQ,MAAM,KAAK,aAAa,GAAG,QAAQ;MAC1D;IACD;AAEA,WAAO;EACR;;EAGA,MAAM,eAAe;AACpB,WAAOA,eAAA,MAAK,aAAA,EAAc;MACzBA,eAAA,MAAK,cAAA,EAAe;MACpB;QACC,MAAM;QACN,QAAQ,MAAM,KAAK,cAAc,GAAG;MACrC;MACA;IACD;EACD;EAkCA,MAAM,oBAAoB,EAAE,OAAO,UAAU,GAA+B;AAC3E,QAAI;AACJ,QAAI,OAAO,cAAc,UAAU;AAClC,mBAAa;IACd,OAAO;AACN,YAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,mBAAa,YAAY,UAAU;IACpC;AAEA,UAAM,WAAW,MAAMF,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,IAAA;AACvB,UAAM,EAAE,QAAQ,UAAAG,WAAU,SAAS,IAAI,SAAS,gBAAgB,YAAY,KAAK;AACjF,QAAI;AACJ,UAAM,QAAQ,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC;AAEvD,WAAO;MACN;MACA;MACA,UAAU;QACT,cAAcA,UAAS,GAAG;QAC1B,QAAQ,MAAM,KAAKA,UAAS,GAAG,MAAM,EAAE,IAAI,CAAC,YAAY;UACvD,aAAa,OAAO;UACpB,eAAe,OAAO;QACvB,EAAE;QACF,iBAAiBA,UAAS,GAAG;MAC9B;MACA;MACA,YAAY,MAAM;AACjB,YAAI,CAAC,YAAY;AAChB,uBAAa,OAAO,OAClB,OAAO,WAAW,KAAqB,EACvC,KAAK,CAAC,SAAS,IAAI,WAAW,IAAI,CAAC;QACtC;AAEA,eAAO;MACR;IACD;EACD;EAEA,MAAM,gBAAgB,EAAE,QAAQ,OAAO,GAA2B;AACjE,UAAM,YAAY,MAAMH,iBAAA,MAAK,yBAAA,mBAAA,EAAL,KAAA,MAAuB,EAAE,QAAQ,OAAO,CAAA;AAChE,UAAM,kBAAkB,QAAQ,UAAU,KAAK;AAE/C,UAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,UAAM,YAAY,aAAa;AAE/B,QAAI,oBAAoB;AACxB,QAAI,mBAAmB;AACvB,QAAI,kBAAkB;AACtB,UAAM,aAAa,IAAI,gBAAgB;AAEvC,UAAM,oBAAoB,gBAAgB,IAAI,CAAC,SAAS,YAAY;AACnE,UAAI;AACH,eAAO,MAAME,eAAA,MAAK,kBAAA,EAAmB;UACpC,EAAE,OAAO;UACT;YACC,SAAS,KAAK;YACd,QAAQ,SAAS,YAAY,IAAI,CAAC,WAAW,QAAQ,MAAM,CAAC,IAAI,WAAW;UAC5E;QACD;MACD,SAAS,OAAO;AACf,YAAI,iBAAiB,eAAe;AACnC,+BAAqB,KAAK,aAAa;QACxC,WAAW,iBAAiB,yBAAyB;AACpD,8BAAoB,KAAK,aAAa;QACvC;AAEA,2BAAmB;AACnB,cAAM;MACP;IACD,CAAC;AAED,QAAI;AACH,YAAM,qBAAqB,kBAAkB,MAAM;AACnD,aAAO,MAAM,mBAAmB;IACjC,QAAQ;AACP,YAAM,YAAY,KAAK,MAAM,kBAAkB,SAASA,eAAA,MAAK,6BAAA,CAA6B;AAC1F,YAAM,mBAAmB,MAAM,mBAAmB,SAAS;AAE3D,aAAO,MAAM,IAAI,QAA4B,CAAC,SAAS,WAAW;AACjE,yBAAiB,QAAQ,OAAO,cAAc;AAC7C,qBAAW,YAAY,WAAW;AACjC,gBAAI;AACH,oBAAM,SAAS,MAAM,SAAS;AAC9B,yBAAW,MAAM,uCAAuC;AACxD,sBAAQ,MAAM;YACf,SAAS,OAAO;AACf,kBAAI,iBAAiB,gBAAgB;AACpC,uBAAO,KAAK;AACZ;cACD,WAAW,SAAS,mBAAmB,mBAAmB,SAAS,GAAG;AACrE,sBAAM,aACL,oBAAoB,mBACjB,IAAI,sBAAsB,sBAAsB,MAAM,oBAAoB,IAC1E,IAAI,iBAAiB,sBAAsB,MAAM,cAAc;AAEnE,2BAAW,MAAM,UAAU;AAC3B,uBAAO,UAAU;AACjB;cACD;AAEA,kBAAI,oBAAoB,kBAAkB,QAAQ;AACjD;kBACC,IAAI;oBACH;kBACD;gBACD;cACD;YACD;UACD;QACD,CAAC;MACF,CAAC;IACF;EACD;EAIA,MAAM,2BAA2B,EAAE,QAAQ,OAAO,OAAO,GAA8B;AACtF,UAAM,YAAY,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AACxB,UAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,UAAM,YAAY,aAAa;AAC/B,UAAM,kBAAkB,wCAAwC,OAAO,SAAS;AAChF,UAAM,aAAa,aAAa,iBAAiB,QAAQ,SAAS;AAClE,UAAM,OAAO,MAAMA,iBAAA,MAAK,yBAAA,sBAAA,EAAL,KAAA,MAA0B,WAAW,UAAA;AAExD,QAAI,CAAC,MAAM;AACV,YAAM,IAAI,MAAM,iCAAiC,UAAU,EAAE;IAC9D;AAEA,UAAM,SAAS,MAAME,eAAA,MAAK,kBAAA,EAAmB;MAC5C,EAAE,QAAQ,iBAAiB,YAAY,YAAY;MACnD;QACC,SAAS,KAAK;QACd;MACD;IACD;AAEA,WAAO;EACR;EAEA,MAAM,WAAW,EAAE,QAAQ,OAAO,GAAsB;AACvD,UAAM,YAAY,MAAMF,iBAAA,MAAK,yBAAA,mBAAA,EAAL,KAAA,MAAuB,EAAE,QAAQ,OAAO,CAAA;AAChE,UAAM,kBAAkB;MACvB,UAAU,MAAM,IAAI,CAAC,UAAU;QAC9B,OAAO;QACP,QAAQ,KAAK,aAAa;MAC3B,EAAE;IACH;AAEA,UAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,UAAM,YAAY,aAAa;AAC/B,UAAM,EAAE,gBAAgB,WAAW,IAAI,iBAAiB,SAAS;AAEjE,UAAM,oBAAoB,gBAAgB;MAAQ,CAAC,SAClD,KAAK,aAAa,IAAI,CAAC,gBAAgB;QACtC,KAAK,KAAK;QACV,iBAAiB,YAAY,YAAY,QAAQ,SAAS;MAC3D,EAAE;IACH;AAEA,UAAM,aAAa,IAAI,gBAAgB;AACvC,UAAM,2BAA2B,MAAM,mBAAmB,UAAU;AACpE,UAAM,UAA+B,CAAC;AACtC,UAAM,cAAc,oBAAI,IAAY;AACpC,QAAI,oBAAoB;AACxB,QAAI,mBAAmB;AACvB,QAAI,kBAAkB;AAEtB,WAAO,IAAI,QAA6B,CAAC,SAAS,WAAW;AAC5D,+BAAyB,CAAC,EAAE,QAAQ,OAAO,GAAG,aAAa;;AAC1D,iBAAS,WAAW,GAAG,WAAW,yBAAyB,QAAQ,YAAY,GAAG;AACjF,gBAAM,SAAQ,8BAAyB,GAAG,QAAQ,MAApC,mBAAuC,GAAG;AACxD,cAAI,CAAC,MAAO;AAEZ,gBAAM,EAAE,KAAK,gBAAgB,IAAI;AAEjC,cAAI;AACH,gBAAI,YAAY,IAAI,GAAG,GAAG;AACzB,oBAAM,IAAI,MAAM,oBAAoB,GAAG,2BAA2B;YACnE;AAEA,kBAAM,SAAS,MAAME,eAAA,MAAK,kBAAA,EAAmB;cAC5C,EAAE,QAAQ,iBAAiB,YAAY,UAAU;cACjD;gBACC,SAAS;gBACT,QAAQ,SAAS,YAAY,IAAI,CAAC,WAAW,QAAQ,MAAM,CAAC,IAAI,WAAW;cAC5E;YACD;AAEA,gBAAI,QAAQ,WAAW,YAAY;AAClC,yBAAW,MAAM,wCAAwC;AACzD,sBAAQ,OAAO;AACf;YACD;AAEA,oBAAQ,KAAK,MAAM;UACpB,SAAS,OAAO;AACf,gBAAI,iBAAiB,eAAe;AACnC,mCAAqB;YACtB,WAAW,iBAAiB,yBAAyB;AACpD,kCAAoB;YACrB,WAAW,iBAAiB,gBAAgB;AAC3C,qBAAO,KAAK;AACZ;YACD;AAEA,gBAAI,SAAS,mBAAmB,mBAAmB,SAAS,GAAG;AAC9D,oBAAM,aACL,oBAAoB,mBACjB,IAAI,sBAAsB,sBAAsB,MAAM,oBAAoB,IAC1E,IAAI,iBAAiB,sBAAsB,MAAM,cAAc;AAEnE,yBAAW,MAAM,UAAU;AAC3B,qBAAO,UAAU;AACjB;YACD;AAEA,wBAAY,IAAI,GAAG;AACnB,+BAAmB;AAEnB,kBAAM,iBAAiB,kBAAkB,UAAU,QAAQ,SAAS;AACpE,kBAAM,kBAAkB,QAAQ,SAAS,iBAAiB;AAE1D,gBAAI,iBAAiB;AACpB,oBAAM,aAAa,IAAI;gBACtB,oDAAoD,MAAM;cAC3D;AACA,yBAAW,MAAM,UAAU;AAC3B,qBAAO,UAAU;YAClB;UACD;QACD;MACD,CAAC;IACF,CAAC;EACF;;;;EAKA,MAAM,sBAAsB,EAAE,QAAQ,OAAO,GAAiC;AAG7E,UAAM,YAAY,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AACxB,UAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,UAAM,YAAY,aAAa;AAC/B,UAAM,aAAa,IAAI,gBAAgB;AAEvC,UAAM,WAAW,MAAM,IAAI;MAC1B,CAAC,SAAS,WAAW;AACpB,cAAM,UAAoD,CAAC;AAC3D,YAAI,gBAAgB;AACpB,YAAI,oBAAoB;AACxB,YAAI,eAAe;AAEnB,kBAAU,MAAM,QAAQ,OAAO,SAAS;AACvC,gBAAM,SAAS,KAAK,aAAa;AAEjC,cAAI;AACH,kBAAM,SAAS,MAAME,eAAA,MAAK,kBAAA,EAAmB;cAC5C,EAAE,OAAO;cACT;gBACC,SAAS,KAAK;gBACd,QAAQ,SAAS,YAAY,IAAI,CAAC,WAAW,QAAQ,MAAM,CAAC,IAAI,WAAW;cAC5E;YACD;AAEA,gBAAI,SAAS,eAAe,SAAS,GAAG;AACvC,yBAAW,MAAM,iDAAiD;AAClE,sBAAQ,OAAO;YAChB,OAAO;AACN,+BAAiB;AACjB,sBAAQ,KAAK,EAAE,QAAQ,OAAO,CAAC;YAChC;UACD,SAAS,OAAO;AACf,gBAAI,iBAAiB,eAAe;AACnC,mCAAqB;YACtB,WAAW,iBAAiB,gBAAgB;AAC3C,qBAAO,KAAK;YACb;AAEA,gBAAI,SAAS,mBAAmB,SAAS,GAAG;AAC3C,oBAAM,aAAa,IAAI,sBAAsB,0BAA0B;AACvE,yBAAW,MAAM,UAAU;AAC3B,qBAAO,UAAU;YAClB;UACD,UAAA;AACC,4BAAgB;AAChB,gBAAI,iBAAiB,UAAU,MAAM,QAAQ;AAC5C;gBACC,IAAI;kBACH;gBACD;cACD;YACD;UACD;QACD,CAAC;MACF;IACD;AAEA,UAAM,qBAAqB,SAAS,OAAO,CAAC,aAAa,UAAU;AAClE,YAAM,EAAE,QAAQ,OAAO,IAAI;AAC3B,YAAM,MAAM,KAAK,UAAU,MAAM;AAEjC,YAAM,WAAW,YAAY,IAAI,GAAG;AACpC,UAAI,UAAU;AACb,iBAAS,eAAe;MACzB,OAAO;AACN,oBAAY,IAAI,KAAK,EAAE,QAAQ,aAAa,OAAO,CAAC;MACrD;AAEA,aAAO;IACR,GAAG,oBAAI,IAAyD,CAAC;AAEjE,UAAM,iBAAiB,CAAC,GAAG,mBAAmB,OAAO,CAAC;AACtD,UAAM,iBAAiB,eAAe;MACrC,CAAC,GAAG,MAAM,oBAAoB,EAAE,OAAO,IAAI,IAAI,oBAAoB,EAAE,OAAO,IAAI;IACjF;AAEA,eAAW,SAAS,gBAAgB;AAEnC,UAAI,gBAAgB,MAAM,aAAa,SAAS,GAAG;AAClD,eAAO,MAAM;MACd;IACD;AAEA,UAAM,IAAI;MACT,kDAAkD,MAAM;IACzD;EACD;;;;EAyDA,MAAM,YAAY,MAAc,QAAgB;AAC/C,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,cAAc,kBAAkB,MAAM,YAAY,UAAU,QAAQ;AAC1E,UAAM,eAAe,qBAAqB,WAAW;AACrD,UAAM,cACL,OAAO,YAAY,IAAI,OAAO,YAAY,2BAA2B,IAAI,OAAO,MAAM;AACvF,WAAO,MAAM;AAEb,UAAM,YAAY,OAAO,YAAY,IAAI,OAAO,YAAY,yBAAyB;AAErF,WAAO,EAAE,aAAa,WAAW,WAAW,cAAc,UAAU;EACrE;;;;;;;;;EAUA,cAAc,EAAE,MAAM,QAAQ,QAAQ,GAA2B;AAChE,WAAO,OAAO,OAAoB;AACjC,YAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,YAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,YAAM,cAAc,kBAAkB,MAAM,YAAY,UAAU,QAAQ;AAC1E,YAAM,CAAC,EAAE,YAAY,GAAG,eAAe,IAAI,MAAM,QAAQ,IAAI;QAC5D,KAAK,YAAY,MAAM,MAAM;QAC7BF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;MACD,CAAC;AAED,aAAO,GAAG;QACTA,iBAAA,MAAK,yBAAA,UAAA,EAAL,KAAA,MAAc,aAAa,WAAW,MAAM,CAAC,MAAMI,QAAO;AACzD,iBAAOA,IAAG;YACT,aAAa;cACZ,SAAS;cACT,WAAW;gBACV,MAAM,aAAa,GAAG;gBACtB,eAAe;gBACf,aAAa;gBACb,SAAS;cACV;YACD,CAAC;UACF;QACD,CAAA;MACD;IACD;EACD;;;;;;;;;EAsCA,yBAAyB;IACxB,cAAc,IAAI,YAAY;IAC9B;IACA;IACA;EACD,GAIG;AACF,gBAAY,gBAAgB,CAAC,KAAK,cAAc,EAAE,MAAM,OAAO,CAAC,CAAC,GAAG,KAAK;AAEzE,WAAO;EACR;;;;;;;;;EAUA,MAAM,gCAAgC;IACrC;IACA,GAAG;EACJ,GAA2E;;AAC1E,UAAM,cAAc,KAAK,yBAAyB;MACjD,GAAG;MACH,SAAO,aAAQ,gBAAR,mBAAqB,UAAU,WAAU,OAAO,aAAa;IACrE,CAAC;AACD,UAAM,WAAW,MAAM,KAAK,YAAY;AAExC,UAAM,EAAE,QAAQ,QAAQ,IAAI,MAAMJ,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,MACjC,aACA,QACA,gBAAA;AAGD,UAAM,mBAAmB,mCAAS,eAChC,OAAO,CAAC,WAAW,OAAO,gBAAgB,WAC1C,IAAI,CAAC,WAAW,OAAO;AAEzB,UAAM,iBAAiB,MAAME,eAAA,MAAK,UAAA,EAAW,KAAK,WAAW;MAC5D,WAAW;IACZ,CAAC;AAED,UAAM,gBAAgB,eAAe,QAAQ;MAC5C,CAAC,WAAW,EAAE,kBAAkB,UAAU,OAAO,SAAS;IAC3D;AAEA,QAAI,yBAAyB,SAAS,CAAC,eAAe;AACrD,YAAM,IAAI;QACT,oEAAoE,MAAM;MAC3E;IACD;AAEA,WAAO;MACN;MACA,SAAS,QAAQ,MAAM,MAAM,cAAc,OAAO;IACnD;EACD;;;;;;;;;EAUA,aAAa;IACZ;IACA;IACA;IACA;IACA;IACA;IACA;EACD,GAAwB;AACvB,WAAO,OAAO,OAAoB;AACjC,YAAM,EAAE,UAAU,IAAI,MAAM,KAAK,YAAY,MAAM,MAAM;AACzD,YAAM,kBAAkB,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAE9B,aAAO,GAAG;QACTA,iBAAA,MAAK,yBAAA,UAAA,EAAL,KAAA,MAAc,WAAW,WAAW,MAAM,OAAO,WAAWI,QAAO;AAClE,gBAAM,OAAOA,IAAG;YACf,aAAa;cACZ,SAAS;cACT,WAAW;gBACV,MAAMA,IAAG,OAAOF,eAAA,MAAK,cAAA,EAAe,cAAc;gBAClD,SAAS,KAAK,cAAc,EAAE,MAAM,QAAQ,QAAQ,CAAC;gBACrD,QAAQ,YAAY,MAAM;gBAC1B,UAAU,OAAO,IAAI,KAAK,EAAE,MAAM,QAAQ,CAAC;gBAC3C;gBACA,cAAc;gBACd;gBACA,cAAc;cACf;YACD,CAAC;UACF;AAEA,cAAI,YAAY;AACfE,gBAAG;cACFJ,iBAAA,MAAK,yBAAA,4BAAA,EAAL,KAAA,MAAgC;gBAC/B;gBACA,oBAAoB;gBACpB;cACD,CAAA;YACD;UACD;AAEA,iBAAO;QACR,CAAA;MACD;IACD;EACD;EAEA,eAAe;IACd;IACA;IACA;EACD,GAIG;AACF,WAAO,OAAO,gBAA6B;AAC1C,YAAM,cAAc,MAAM,OAAO,OAAO,OAAO,WAAW,KAAqB;AAC/E,YAAM,cAAc,IAAI,IAAI,EAAE,UAAU,IAAI,EAAE,QAAQ;AACtD,YAAM,SAAS,OAAO,eAAe,aAAa,MAAM,WAAW,IAAI;AACvE,YAAM,cAAc,IAAI;QACvB,YAAY,aAAa,OAAO,aAAa,YAAY;MAC1D;AAEA,kBAAY,IAAI,QAAQ,CAAC;AACzB,kBAAY,IAAI,IAAI,WAAW,WAAW,GAAG,OAAO,UAAU;AAC9D,kBAAY,IAAI,aAAa,YAAY,aAAa,OAAO,UAAU;AACvE,kBAAY,KAAK,WAAW;IAC7B;EACD;EAyBA,MAAM,wBAAwB,SAA2B;AACxD,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,cAAc,kBAAkB,QAAQ,MAAM,YAAY,UAAU,QAAQ;AAClF,UAAM,YAAY,MAAMA,iBAAA,MAAK,yBAAA,gBAAA,EAAL,KAAA,IAAA;AAExB,QAAI,CAAC,WAAW;AACf,aAAO;IACR;AAEA,UAAM,EAAE,KAAK,KAAK,IAAI;AAEtB,UAAM,SACL,WAAW,OACR,KAAK,QACL,OAAO,KAAK,OAAO,IAAI,IACxB,OAAO,KAAK,OAAO,aAAa,MAAM,OAAO,WAAW,IAAI,SAAS;AAExE,QAAI,OAAO,QAAQ,SAAS,KAAK;AAChC,YAAM,IAAI;QACT,eAAe,MAAM,sCAAsC,GAAG;MAC/D;IACD;AAEA,WAAO;EACR;EAEA,mBAAmB;IAClB;IACA;IACA;EACD,GAIG;AACF,WAAO,OAAO,gBAA6B;AAC1C,YAAM,YAAY,MAAMA,iBAAA,MAAK,yBAAA,gBAAA,EAAL,KAAA,IAAA;AAExB,UAAI,WAAW;AACd,oBAAY,IAAI,KAAK,eAAe,EAAE,MAAM,YAAY,MAAM,CAAC,CAAC;AAChE,cAAM,SAAS,MAAM,KAAK,wBAAwB,EAAE,KAAK,CAAC;AAC1D,cAAM,EAAE,QAAQ,IAAI;AACpB,oBAAY;UACX;YACC,gBAAgB;cACf,SAAS;YACV,CAAC;UACF;UACA;QACD;MACD;IACD;EACD;;;;;;;;;EAUA,wBAAwB;IACvB,cAAc,IAAI,YAAY;IAC9B,GAAG;EACJ,GAIG;AACF,UAAM,eAAe,YAAY,IAAI,KAAK,aAAa,OAAO,CAAC;AAE/D,gBAAY,gBAAgB,CAAC,YAAY,GAAG,QAAQ,KAAK;AAEzD,WAAO;EACR;;;;;;;;;EAUA,MAAM,+BAA+B;IACpC;IACA,GAAG;EACJ,GAQG;;AACF,UAAM,cAAc,KAAK,wBAAwB;MAChD,GAAG;MACH,OAAO,QAAQ,WAAS,aAAQ,gBAAR,mBAAqB,UAAU,WAAU,OAAO,aAAa;IACtF,CAAC;AACD,UAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAM,EAAE,QAAQ,QAAQ,IAAI,MAAMA,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,MACjC,aACA,QACA,eAAA;AAGD,UAAM,mBAAmB,mCAAS,eAChC,OAAO,CAAC,WAAW,OAAO,gBAAgB,WAC1C,IAAI,CAAC,WAAW,OAAO;AAEzB,UAAM,iBAAiB,MAAME,eAAA,MAAK,UAAA,EAAW,KAAK,WAAW;MAC5D,WAAW;IACZ,CAAC;AAED,UAAM,gBAAgB,eAAe,QAAQ;MAC5C,CAAC,WAAW,EAAE,kBAAkB,UAAU,OAAO,SAAS;IAC3D;AAEA,QAAI,yBAAyB,SAAS,CAAC,eAAe;AACrD,YAAM,IAAI;QACT,iEAAiE,MAAM;MACxE;IACD;AAEA,WAAO;MACN;MACA,MAAM,KAAK,MAAM,MAAM,cAAc,OAAO;IAC7C;EACD;EA+BA,MAAM,6BAA6B;IAClC;IACA;IACA;IACA;EACD,GAGwC;AACvC,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,YAAY,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAExB,QAAI,cAAc,WAAW,YAAY,UAAU,QAAQ,QAAQ;AAClE,YAAM,IAAI;QACT;MACD;IACD;AAEA,UAAM,sBAAsB,oBAAoB,UAAU;MACzD,QAAQ,WAAW;MACnB,OAAO,YAAY,UAAU;MAC7B,iBAAiB;QAChB;QACA,UAAU,YACP;UACA,WAAW;YACV,UAAU;UACX;QACD,IACC;UACA,WAAW;QACZ;MACH;IACD,CAAC,EAAE,SAAS;AAEZ,UAAM,WAAW,MAAMA,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,IAAA;AACvB,UAAM,kBAAkB,SAAS,mBAAmB;AAEpD,UAAM,wBAAwB,cAC5B,IAAI,CAAC,cAAc,UAAU;AAC7B,YAAM,WACL,6CAAc,uBAAsB,uBACpC;QACC;QACA,IAAI,WAAW,UAAU,MAAM,KAAK,EAAE,KAAK,WAAW,KAAK;MAC5D;AAED,aAAO,UACJ;QACA;QACA,GAAG;MACJ,IACC;IACJ,CAAC,EACA,OAAO,CAAC,iBAAiB,iBAAiB,IAAI;AAEhD,QAAI,CAAC,SAAS,sBAAsB,QAAQ,YAAY,UAAU,QAAQ,MAAM,GAAG;AAClF,YAAM,IAAI;QACT,qDAAqD,sBAAsB,MAAM,OAAO,YAAY,UAAU,QAAQ,MAAM;MAC7H;IACD;AAEA,WAAO,SAAS;MACf;MACA,sBAAsB,IAAI,CAAC,EAAE,MAAM,MAAM,KAAK;IAC/C;EACD;;;;;;;;;EAUA,YAAY,EAAE,QAAQ,cAAc,eAAe,aAAa,UAAU,GAAuB;AAChG,WAAO,OAAO,OAAoB;AACjC,YAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,YAAM,oBACL,eACC,MAAM,KAAK,6BAA6B;QACxC;QACA;QACA;QACA;MACD,CAAC;AAEF,YAAM,kBAAkB,MAAMA,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAE9B,SAAG;QACF,YAAY;UACX,SAAS;UACT,WAAW;YACV,MAAME,eAAA,MAAK,cAAA,EAAe;YAC1B,MAAM;YACN,WAAW,GAAG,KAAK,OAAO,MAAM,kBAAkB,SAAS;YAC3D,eAAe,GAAG,KAAK;cACtB;cACA,gBAAgB,kBAAkB,SAAS,YAAY,UAAU,QAAQ,MAAM;YAChF;YACA,SAAS,GAAG,KAAK,OAAO,MAAM,kBAAkB,iBAAiB;UAClE;QACD,CAAC;MACF;IACD;EACD;;;;;;;;;EAUA,uBAAuB;IACtB,cAAc,IAAI,YAAY;IAC9B,GAAG;EACJ,GAEG;AACF,gBAAY,IAAI,KAAK,YAAY,OAAO,CAAC;AAEzC,WAAO;EACR;;;;;;;;;EAUA,MAAM,8BAA8B;IACnC;IACA,GAAG;EACJ,GAGG;AACF,UAAM,cAAc,KAAK,uBAAuB,OAAO;AAEvD,UAAM,EAAE,OAAO,IAAI,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,MAAyB,aAAa,QAAQ,cAAA;AAEvE,WAAO,EAAE,OAAO;EACjB;;;;;;;;;;EAWA,WAAW,EAAE,aAAa,GAAsB;AAC/C,WAAO,OAAO,OAAoB;AACjC,YAAM,kBAAkB,MAAMA,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAC9B,YAAM,UAAU,GAAG;QAClB,WAAW;UACV,SAAS;UACT,WAAW;YACV,MAAME,eAAA,MAAK,cAAA,EAAe;YAC1B,MAAM;UACP;QACD,CAAC;MACF;AAEA,aAAO;IACR;EACD;;;;;;;;;EAUA,sBAAsB;IACrB;IACA;IACA,cAAc,IAAI,YAAY;EAC/B,GAIG;AACF,UAAM,UAAU,YAAY,IAAI,KAAK,WAAW,EAAE,aAAa,CAAC,CAAC;AACjE,gBAAY,gBAAgB,CAAC,OAAO,GAAG,KAAK;AAE5C,WAAO;EACR;;;;;;;;;EAUA,MAAM,6BAA6B;IAClC;IACA,cAAc,IAAI,YAAY;IAC9B;EACD,GAAsE;AACrE,UAAM,EAAE,OAAO,IAAI,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,MACxB,KAAK,sBAAsB;MAC1B;MACA;MACA,OAAO,YAAY,QAAQ,EAAE,UAAU,OAAO,aAAa;IAC5D,CAAC,GACD,QACA,aAAA;AAGD,WAAO,EAAE,OAAO;EACjB;;;;;;;;;EAUA,WAAW,EAAE,cAAc,QAAQ,UAAU,QAAQ,GAAsB;AAC1E,WAAO,OAAO,OAAoB;AACjC,YAAM,OAAO,MAAME,eAAA,MAAK,aAAA,EAAc,KAAK,cAAc,IAAI;AAC7D,YAAM,YAAY,OAAO,WAAW,WAAW,SAAS,WAAW,KAAK,QAAQ;AAEhF,UAAI,aAAa,GAAG;AACnB;MACD;AAEA,YAAM,EAAE,YAAY,IAAI,MAAM,KAAK,YAAY,OAAO,KAAK,QAAQ,YAAY,GAAG,SAAS;AAC3F,YAAM,kBAAkB,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAE9B,aAAO,GAAG;QACTA,iBAAA,MAAK,yBAAA,UAAA,EAAL,KAAA,MAAc,aAAa,WAAW,MAAM,OAAO,MAAMI,QAAO;AAC/DA,cAAG;YACF,WAAW;cACV,SAAS;cACT,WAAW;gBACV,MAAMF,eAAA,MAAK,cAAA,EAAe;gBAC1B,MAAM;gBACN,gBAAgB;gBAChB,SAAS;cACV;YACD,CAAC;UACF;QACD,CAAA;MACD;IACD;EACD;;;;;;;;;EAUA,MAAM,sBAAsB;IAC3B,cAAc,IAAI,YAAY;IAC9B,GAAG;EACJ,GAAsD;AACrD,gBAAY,IAAI,KAAK,WAAW,OAAO,CAAC;AAExC,WAAO;EACR;;;;;;;;;EAUA,MAAM,6BAA6B;IAClC;IACA,GAAG;EACJ,GAAsE;AACrE,UAAM,EAAE,OAAO,IAAI,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,MACxB,MAAM,KAAK,sBAAsB,OAAO,GACxC,QACA,aAAA;AAGD,WAAO,EAAE,OAAO;EACjB;EAEA,MAAM,mBAAmB;IACxB;EACD,GAE2C;AAC1C,UAAM,WAAW,MAAME,eAAA,MAAK,UAAA,EAAW,KAAK,gBAAgB;MAC3D,UAAU;MACV,MAAM;QACL,MAAM;QACN,KAAK,IAAI,OAAO,EAAE,UAAU,UAAU,EAAE,QAAQ;MACjD;IACD,CAAC;AAED,UAAM,iBAA0B,SAAS,MAAM,SAAS,aAAa,MAAM,GAAG;AAE9E,WAAO,OAAO;MACb,eAAe,SAAS,SAAS,IAAI,CAAC,EAAE,KAAK,MAAM,MAAM,CAAC,KAAK,KAAK,CAAC;IACtE;EACD;;;;;;;;;;;;EAsEA,oBAAoB,EAAE,YAAY,cAAc,WAAW,GAA+B;AACzF,WAAO,OAAO,OAAoB;AACjC,YAAM,qBAAqB,eACxB,MAAM,KAAK,mBAAmB,EAAE,aAAa,CAAC,IAC9C;AACH,YAAM,OAAO,cAAc,GAAG,OAAO,YAAY;AAEjD,SAAG;QACFF,iBAAA,MAAK,yBAAA,4BAAA,EAAL,KAAA,MAAgC;UAC/B;UACA;UACA;QACD,CAAA;MACD;IACD;EACD;;;;;;;;;;;;EAaA,MAAM,+BAA+B;IACpC,cAAc,IAAI,YAAY;IAC9B,GAAG;EACJ,GAA+D;AAC9D,gBAAY,IAAI,MAAM,KAAK,oBAAoB,OAAO,CAAC;AACvD,WAAO;EACR;;;;;;;;;;;;EAaA,MAAM,sCAAsC;IAC3C;IACA,GAAG;EACJ,GAA+E;AAC9E,UAAM,EAAE,OAAO,IAAI,MAAMA,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,MACxB,MAAM,KAAK,+BAA+B,OAAO,GACjD,QACA,uBAAA;AAED,WAAO,EAAE,OAAO;EACjB;;;;;;;;;EAUA,MAAM,YAAY,EAAE,QAAQ,iBAAiB,YAAY,QAAQ,OAAO,GAAuB;AAC9F,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,YAAY,MAAMA,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAExB,UAAM,aAAa,aAAa,iBAAiB,QAAQ,YAAY,UAAU,QAAQ;AACvF,UAAM,OAAO,MAAMA,iBAAA,MAAK,yBAAA,sBAAA,EAAL,KAAA,MAA0B,WAAW,UAAA;AAExD,WAAOE,eAAA,MAAK,kBAAA,EAAmB;MAC9B,EAAE,QAAQ,iBAAiB,YAAY,OAAO;MAC9C,EAAE,SAAS,KAAK,YAAY,OAAO;IACpC;EACD;;;;;;;;;EAUA,MAAM,oBAAoB,EAAE,WAAW,QAAQ,UAAAC,WAAU,OAAO,GAAyB;AACxF,UAAM,YAAY,MAAMH,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AACxB,UAAM,OAAO,UAAU,MAAM,SAAS;AAEtC,WAAO;MACN,MACCE,eAAA,MAAK,kBAAA,EAAmB;QACvB,EAAE,QAAQ,UAAAC,UAAS;QACnB,EAAE,SAAS,KAAK,YAAY,OAAO;MACpC;MACD;QACC,OAAO;QACP,OAAO;QACP,WAAW,CAAC,UAAU,iBAAiB;MACxC;IACD;EACD;;;;;;;;;EAUA,MAAM,+BAA+B;IACpC;IACA;IACA;IACA;IACA;EACD,GAAkC;;AACjC,UAAM,YAAY,MAAMH,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AACxB,UAAM,OAAO,UAAU,MAAM,SAAS;AAEtC,UAAM,SAAS,YACZ,MAAME,eAAA,MAAK,kBAAA,EAAmB;MAC9B,EAAE,QAAQ,SAAS;MACnB,EAAE,SAAS,KAAK,YAAY,OAAO;IACpC,IACC,MAAMA,eAAA,MAAK,kBAAA,EAAmB;MAC9B,EAAE,OAAO;MACT,EAAE,SAAS,KAAK,YAAY,OAAO;IACpC;AAEF,aAAO,4CAAQ,YAAR,mBAAiB,SAAjB,mBAAuB,WAAU;EACzC;;;;;;;;;EAUA,MAAM,WAAW,MAAkB;AAClC,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,YAAY,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAExB,UAAM,YAAY,YAAY,UAAU;AACxC,UAAM,WAAW,MAAMA,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,IAAA;AACvB,UAAM,EAAE,QAAQ,UAAAG,WAAU,aAAa,SAAS,IAAI,SAAS,WAAW,WAAW,IAAI;AAEvF,UAAM,mBAAmB,oBAAI,IAA4B;AAEzD,WAAO,YAAY,SAAS,GAAG;AAE9B,YAAM,EAAE,SAAS,UAAU,IAAI,YAAY,IAAI;AAC/C,YAAM,kBAAkB,QAAQ;AAEhC,YAAM,aAAa,aAAa,iBAAiB,QAAQ,SAAS;AAClE,YAAM,OAAO,MAAMH,iBAAA,MAAK,yBAAA,sBAAA,EAAL,KAAA,MAA0B,WAAW,UAAA;AAExD,UAAI,CAAC,iBAAiB,IAAI,KAAK,SAAS,GAAG;AAC1C,yBAAiB,IAAI,KAAK,WAAW,EAAE,SAAS,CAAC,GAAG,WAAW,CAAC,EAAE,CAAC;MACpE;AAEA,uBAAiB,IAAI,KAAK,SAAS,EAAG,QAAQ,KAAK;QAClD,aAAa,QAAQ;QACrB;QACA;QACA,QAAQ,WAAW,UAAU,OAAO,EAAE,QAAQ;MAC/C,CAAC;AAED,uBAAiB,IAAI,KAAK,SAAS,EAAG,UAAU,KAAK;QACpD,aAAa,UAAU;QACvB;QACA;QACA,QAAQ,WAAW,UAAU,SAAS,EAAE,QAAQ;MACjD,CAAC;IACF;AAEA,UAAM,gBAAgB,IAAI,MAAsB;AAEhD,aAAS,IAAI,GAAG,IAAI,YAAY,UAAU,QAAQ,QAAQ,KAAK;AAC9D,oBAAc,KAAK,iBAAiB,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,WAAW,CAAC,EAAE,CAAC;IAC7E;AAEA,WAAO,EAAE,QAAQ,UAAAG,WAAU,UAAU,cAAc;EACpD;;;;;;;;;EAUA,MAAM,mBAAmB,EAAE,QAAQ,SAAS,OAAO,GAA8B;AAChF,UAAM,aAAa,IAAI,gBAAgB;AACvC,UAAM,iBAAiB,SACpB,YAAY,IAAI,CAAC,WAAW,QAAQ,MAAM,CAAC,IAC3C,WAAW;AAEd,UAAM,sBAAsB,QAAQ,QAAQ,IAAI,CAAC,EAAE,iBAAiB,OAAO,MAAM;AAChF,aAAO,KAAK,YAAY;QACvB;QACA;QACA,YAAY;QACZ;QACA,QAAQ;MACT,CAAC;IACF,CAAC;AAED,UAAM,wBAAwB,QAAQ,UAAU,IAAI,CAAC,EAAE,iBAAiB,OAAO,MAAM;AACpF,aAAO,KAAK,YAAY;QACvB;QACA;QACA,YAAY;QACZ;QACA,QAAQ;MACT,CAAC;IACF,CAAC;AAED,UAAM,QAAQ,IAAI,CAAC,GAAG,qBAAqB,GAAG,qBAAqB,CAAC,EAAE,MAAM,CAAC,UAAU;AACtF,iBAAW,MAAM,KAAK;AACtB,YAAM;IACP,CAAC;EACF;;;;;;;;;EAUA,MAAM,wBAAwB;IAC7B;IACA,UAAAA;IACA;IACA;IACA,GAAG;EACJ,GAAmC;AAClC,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,YAAY,MAAMH,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAExB,UAAM,aAAa,IAAI,gBAAgB;AACvC,QAAI,WAAW;AAEf,UAAM,gBAAgB,MAAM,QAAQ;MACnC,cAAc,IAAI,CAAC,SAAS,cAAc;AACzC,eAAO,KAAK,uBAAuB;UAClC;UACA;UACA,UAAAG;UACA;UACA,QAAQ,SAAS,YAAY,IAAI,CAAC,WAAW,QAAQ,MAAM,CAAC,IAAI,WAAW;UAC3E,GAAG;QACJ,CAAC,EAAE,MAAM,MAAM;AACd,sBAAY,UAAU,MAAM,SAAS,EAAE,aAAa;AAEpD,cAAI,gBAAgB,UAAU,YAAY,UAAU,QAAQ,GAAG;AAC9D,kBAAM,QAAQ,IAAI;cACjB,wCAAwC,MAAM;YAC/C;AACA,uBAAW,MAAM,KAAK;AACtB,kBAAM;UACP;AAEA,iBAAO;QACR,CAAC;MACF,CAAC;IACF;AAEA,WAAO;EACR;;;;;;;;;EAUA,MAAM,uBAAuB,SAG1B;;AACF,QAAI,CAACD,eAAA,MAAK,kBAAA,GAAoB;AAC7B,YAAM,IAAI,kBAAkB,6BAA6B;IAC1D;AAEA,WAAOA,eAAA,MAAK,kBAAA,EAAmB,UAAU;MACxC,GAAG;MACH,aAAa,CAAC,GAAC,KAAAA,eAAA,MAAK,kBAAA,MAAL,mBAAyB;IACzC,CAAC;EACF;;;;;;;;;EAUA,MAAM,uBAAuB;IAC5B;IACA;IACA,UAAAC;IACA;IACA;IACA,GAAG;EACJ,GAA4B;AAC3B,UAAM,KAAK,oBAAoB;MAC9B;MACA;MACA,UAAAA;MACA;IACD,CAAC;AAED,UAAM,KAAK,mBAAmB,EAAE,QAAQ,SAAS,QAAQ,UAAU,CAAC;AAEpE,WAAO,KAAK,+BAA+B;MAC1C;MACA;MACA,GAAG;IACJ,CAAC;EACF;;;;;;;;;EAUA,MAAM,UAAU;IACf;IACA;IACA;IACA;IACA;IACA;IACA;EACD,GAAqB;AACpB,QAAI,CAACD,eAAA,MAAK,kBAAA,GAAoB;AAC7B,YAAM,UAAU,MAAM,KAAK,WAAW,IAAI;AAC1C,YAAM,SAAS,QAAQ;AACvB,YAAM,EAAE,eAAe,UAAAC,WAAU,SAAS,IAAI;AAE9C,YAAM,gBAAgB,MAAM,KAAK,+BAA+B;QAC/D;QACA,MAAM,KAAK;QACX;QACA;QACA;QACA;QACA,OAAO,SAAS,OAAO,aAAa;QACpC;MACD,CAAC;AAED,YAAM,eAAe,cAAc,KAAK,GAAG;AAE3C,YAAM,gBAAgB,MAAM,KAAK,wBAAwB;QACxD;QACA,UAAAA;QACA;QACA;QACA,UAAU;QACV;MACD,CAAC;AAED,YAAM,KAAK,8BAA8B;QACxC;QACA;QACA;QACA;QACA;MACD,CAAC;AAED,aAAO;QACN;QACA,YAAY,MAAMD,eAAA,MAAK,aAAA,EAAc,KAAK,cAAc,IAAI;MAC7D;IACD,OAAO;AACN,YAAMC,YAAW,MAAM,KAAK,oBAAoB;QAC/C,OAAO;MACR,CAAC;AACD,YAAM,SAASA,UAAS;AAExB,YAAM,cAAc,IAAI,YAAY;AAEpC,kBAAY;QACX,KAAK,mBAAmB;UACvB,MAAM,KAAK;UACX,YAAYA,UAAS;UACrB,OAAOA,UAAS;QACjB,CAAC;MACF;AAEA,YAAM,iBAAiB,MAAM,KAAK,+BAA+B;QAChE;QACA;QACA,MAAM,KAAK;QACX;QACA,QAAQA,UAAS;QACjB,UAAUA,UAAS;QACnB;QACA,OAAO,SAAS,OAAO,aAAa;QACpC;MACD,CAAC;AAED,YAAMD,eAAA,MAAK,UAAA,EAAW,KAAK,mBAAmB;QAC7C,QAAQ,eAAe;MACxB,CAAC;AAED,YAAM,SAAS,MAAM,KAAK,uBAAuB;QAChD;QACA;QACA,OAAOC,UAAS;QAChB,UAAU,eAAe;QACzB;QACA;QACA,cAAc,eAAe,KAAK,GAAG;QACrC,cAAcA,UAAS,SAAS;MACjC,CAAC;AAED,YAAM,cAAc,OAAO;AAC3B,YAAM,eAAe,eAAe,KAAK,GAAG;AAE5C,YAAM,KAAK,8BAA8B;QACxC;QACA;QACA;QACA;QACA;MACD,CAAC;AAED,aAAO;QACN;QACA,YAAY,MAAMD,eAAA,MAAK,aAAA,EAAc,KAAK,cAAc,IAAI;MAC7D;IACD;EACD;EAEA,MAAM,WAAW,EAAE,OAAO,GAAG,QAAQ,GAAsB;AAC1D,UAAM,UAAU,MAAM,KAAK,YAAY,EAAE,MAAM,CAAC;AAChD,UAAM,SAAS,MAAM,KAAK,UAAU;MACnC,GAAG;MACH,MAAM,QAAQ;MACd,YAAY;QACX,iBAAiB;QACjB,GAAG,QAAQ;MACZ;IACD,CAAC;AAED,WAAO;MACN,GAAG;MACH,OAAO;QACN,GAAG,QAAQ;QACX,SAAS,QAAQ,MAAM,QAAQ,IAAI,CAAC,WAAW;UAC9C,GAAG;UACH,SAAS,mBAAmB;YAC3B,SAAS,OAAO;YAChB,SAAS;cACR,SAAS;cACT,YAAY,MAAM;cAClB,UAAU,MAAM;YACjB;UACD,CAAC;QACF,EAAE;MACH;IACD;EACD;EAEA,MAAM,YAAY;IACjB;EACD,GAMG;AACF,UAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,UAAM,UAAU,YAAY;MAC3B;MACA,WAAW,YAAY,UAAU;IAClC,CAAC;AAED,WAAO;EACR;;;;;;;;;EA6EA,QAAQ;AACP,IAAAA,eAAA,MAAK,aAAA,EAAc,SAAS;AAC5B,IAAAA,eAAA,MAAKL,OAAA,EAAO,MAAM;EACnB;EAgBA,MAAM,QAAQ,EAAE,OAAO,GAAuB;AAC7C,WAAO,IAAI,WAAW;MACrB,QAAQ,IAAI,WAAW;QACtB,QAAQ;QACR;QACA,YAAY,MAAM,KAAK,YAAY,GAAG,UAAU;MACjD,CAAC;MACD,QAAQ;IACT,CAAC;EACF;EAEA,MAAM,SAAS,EAAE,IAAI,GAAsB;AAC1C,UAAM,kBAAkB,oBAAI,IAAwB;AACpD,UAAM,uBAAuB,oBAAI,IAAyB;AAC1D,UAAM,YAAY,IAAI,IAAI,CAAC,OAAO,cAAc,EAAE,CAAC;AACnD,UAAM,aAAa,MAAM,KAAK,YAAY,GAAG,UAAU;AAEvD,eAAW,MAAM,WAAW;AAC3B,YAAM,SAAS,GAAG,SAAS,SAAS,GAAG,KAAK,GAAG,GAAG;AAClD,UAAI,CAAC,gBAAgB,IAAI,MAAM,GAAG;AACjC,wBAAgB;UACf;UACA,IAAI,WAAW;YACd,QAAQ;YACR;YACA;UACD,CAAC;QACF;MACD;AAEA,UAAI,GAAG,SAAS,cAAc;AAC7B,YAAI,CAAC,qBAAqB,IAAI,MAAM,GAAG;AACtC,+BAAqB;YACpB;YACA,IAAI,YAAY;cACf,MAAM,gBAAgB,IAAI,MAAM;YACjC,CAAC;UACF;QACD;MACD;IACD;AAEA,WAAO,UAAU,IAAI,CAAC,OAAO;AAC5B,UAAI,GAAG,SAAS,QAAQ;AACvB,eAAO,IAAI,WAAW;UACrB,QAAQ,gBAAgB,IAAI,GAAG,EAAE;QAClC,CAAC;MACF;AAEA,aAAO,IAAI,WAAW;QACrB,QAAQ,IAAI,gBAAgB;UAC3B,OAAO,qBAAqB,IAAI,GAAG,GAAG,OAAO;UAC7C,aAAa,GAAG,GAAG,QAAQ;QAC5B,CAAC;MACF,CAAC;IACF,CAAC;EACF;EAEA,MAAM,WAAW,EAAE,OAAO,GAAG,QAAQ,GAAsB;AAC1D,UAAM,EAAE,QAAQ,OAAO,WAAW,IAAI,MAAM,KAAK,WAAW;MAC3D,GAAG;MACH,OAAO,MAAM,QAAQ;QACpB,MAAM,IAAI,OAAO,MAAM,OAAO;UAC7B,UAAU,MAAM,KAAK,MAAM;UAC3B,YAAa,MAAM,KAAK,cAAc,KAAM,QAAQ,CAAC;UACrD,MAAO,MAAM,KAAK,QAAQ,KAAM,CAAC;QAClC,EAAE;MACH;IACD,CAAC;AAED,WAAO,MAAM,QAAQ,IAAI,CAAC,WAAW;MACpC,IAAI,MAAM;MACV;MACA;IACD,EAAE;EACH;EAEA,eAAe,EAAE,MAAM,GAA0C;AAChE,UAAM,SAAS,YAAY;AAC1B,YAAM,EAAE,OAAO,MAAM,IAAI,MAAM,KAAK,YAAY;QAC/C,OAAO,MAAM,QAAQ;UACpB,MAAM,IAAI,OAAO,MAAM,OAAO;YAC7B,UAAU,MAAM,KAAK,MAAM;YAC3B,YAAa,MAAM,KAAK,cAAc,KAAM,QAAQ,CAAC;YACrD,MAAO,MAAM,KAAK,QAAQ,KAAM,CAAC;UAClC,EAAE;QACH;MACD,CAAC;AACD,YAAMM,YAAWD,eAAA,MAAK,kBAAA,IACnB,MAAM,KAAK,oBAAoB;QAC/B,OAAO;MACR,CAAC,IACA,MAAM,KAAK,WAAW,KAAK;AAE9B,aAAO;QACN,UAAAC;QACA,MAAM,MAAM;QACZ,MAAMD,eAAA,MAAK,kBAAA,IAAqB,QAAQ;QACxC;MACD;IACD;AAEA,UAAM,WAAW,CAChB,EAAE,MAAM,UAAAC,WAAU,OAAO,KAAK,GAC9B,EAAE,QAAQ,WAAW,OAAO,WAAW,MACnC;AACJ,YAAM,cAAc,IAAI,YAAY;AACpC,kBAAY,kBAAkB,KAAK;AAEnC,UAAID,eAAA,MAAK,kBAAA,GAAoB;AAC5B,cAAM,OAAOC;AACb,oBAAY;UACX,KAAK,mBAAmB;YACvB;YACA,YAAY,KAAK;YACjB,OAAO,KAAK;UACb,CAAC;QACF;MACD;AAEA,kBAAY;QACX;UACC,KAAK,aAAa;YACjB;YACA;YACA,QAAQA,UAAS;YACjB,UAAUA,UAAS;YACnB;YACA,YAAY;cACX,iBAAiB;cACjB,GAAG;YACJ;UACD,CAAC;QACF;QACA;MACD;AAEA,aAAO;QACN,qBAAqB;QACrB;QACA;QACA,UAAAA;QACA;MACD;IACD;AAEA,UAAM,SAAS,OACd,EAAE,OAAO,MAAM,UAAAA,WAAU,UAAU,GACnC,EAAE,OAAO,MACL;AACJ,YAAM,aAAa,MAAMH,iBAAA,MAAK,yBAAA,iBAAA,EAAL,KAAA,MAAqB,MAAA;AAE9C,UAAIE,eAAA,MAAK,kBAAA,GAAoB;AAC5B,cAAMG,QAAOF;AACb,eAAO;UACN;UACA;UACA,UAAAA;UACA;UACA,cACC,MAAM,KAAK,uBAAuB;YACjC,QAAQA,UAAS;YACjB,MAAM;YACN,OAAOE,MAAK;YACZ,UAAU;YACV,cAAc,WAAW,GAAG;YAC5B;YACA,cAAcA,MAAK,SAAS;UAC7B,CAAC,GACA;QACH;MACD;AAEA,YAAM,OAAOF;AAEb,aAAO;QACN;QACA;QACA,UAAAA;QACA;QACA,eAAe,MAAM,KAAK,wBAAwB;UACjD,QAAQA,UAAS;UACjB,UAAU,WAAW,GAAG;UACxB,UAAU,KAAK;UACf,eAAe,KAAK;UACpB;QACD,CAAC;MACF;IACD;AAEA,UAAM,UAAU,CAAC;MAChB;MACA,UAAAA;MACA;MACA;MACA;MACA;IACD,MAA0C;AACzC,aAAO;QACN;QACA;QACA,UAAAA;QACA,aAAa,gBACV,KAAK,uBAAuB;UAC5B,QAAQA,UAAS;UACjB,cAAc,WAAW,GAAG;UAC5B;UACA;QACD,CAAC,IACA,KAAK,uBAAuB;UAC5B;UACA,QAAQA,UAAS;UACjB,cAAc,WAAW,GAAG;UAC5B;QACD,CAAC;MACJ;IACD;AAEA,mBAAe,UAAU,EAAE,OAAO,YAAY,UAAAA,UAAS,GAAwC;AAC9F,aAAO,MAAM,QAAQ,IAAI,CAAC,WAAW;QACpC,IAAI,mBAAmB;UACtB,SAASA,UAAS;UAClB,SAAS;YACR,SAAS;YACT,YAAY,MAAM;YAClB,UAAU,MAAM;UACjB;QACD,CAAC;QACD,QAAQA,UAAS;QACjB;MACD,EAAE;IACH;AAEA,UAAM,cAMF,CAAC;AAEL,aAAS,WACR,MACA,SACuC;AACvC,UAAI,CAAC,YAAY,IAAI,GAAG;AACvB,cAAM,IAAI,MAAM,GAAG,IAAI,oCAAoC,OAAO,EAAE;MACrE;AACA,aAAO,YAAY,IAAI;IACxB;AAEA,WAAO;MACN,QAAQ,YAAY;AACnB,YAAI,CAAC,YAAY,QAAQ;AACxB,sBAAY,SAAS,MAAM,OAAO;QACnC;MACD;MACA,UAAU,CAAC,YAA2C;AACrD,oBAAY,WAAW,SAAS,WAAW,UAAU,UAAU,GAAG,OAAO;AACzE,eAAO,YAAY,SAAS;MAC7B;MACA,QAAQ,OAAO,YAAyC;AACvD,oBAAY,SAAS,MAAM,OAAO,WAAW,YAAY,QAAQ,GAAG,OAAO;MAC5E;MACA,SAAS,MAAM;AACd,oBAAY,UAAU,QAAQ,WAAW,UAAU,SAAS,CAAC;AAC7D,eAAO,YAAY,QAAQ;MAC5B;MACA,WAAW,YAAY;AACtB,eAAO,UAAU,WAAW,WAAW,WAAW,CAAC;MACpD;IACD;EACD;EAEA,cAAc,EAAE,KAAK,GAAwC;AAC5D,UAAM,SAAS,YAAY;AAC1B,YAAMA,YAAWD,eAAA,MAAK,kBAAA,IACnB,MAAM,KAAK,oBAAoB;QAC/B,OAAO;MACR,CAAC,IACA,MAAM,KAAK,WAAW,IAAI;AAE7B,aAAO;QACN,UAAAC;QACA,MAAM,KAAK;QACX,MAAMD,eAAA,MAAK,kBAAA,IAAqB,OAAO;MACxC;IACD;AAEA,UAAM,WAAW,CAChB,EAAE,MAAM,UAAAC,WAAU,KAAK,GACvB,EAAE,QAAQ,WAAW,OAAO,WAAW,MACnC;AACJ,YAAM,cAAc,IAAI,YAAY;AACpC,kBAAY,kBAAkB,KAAK;AAEnC,UAAID,eAAA,MAAK,kBAAA,GAAoB;AAC5B,cAAM,OAAOC;AACb,oBAAY;UACX,KAAK,mBAAmB;YACvB;YACA,YAAY,KAAK;YACjB,OAAO,KAAK;UACb,CAAC;QACF;MACD;AAEA,kBAAY;QACX;UACC,KAAK,aAAa;YACjB;YACA;YACA,QAAQA,UAAS;YACjB,UAAUA,UAAS;YACnB;YACA;UACD,CAAC;QACF;QACA;MACD;AAEA,aAAO;QACN,qBAAqB;QACrB;QACA,UAAAA;QACA;MACD;IACD;AAEA,UAAM,SAAS,OACd,EAAE,MAAM,UAAAA,WAAU,UAAU,GAC5B,EAAE,OAAO,MACL;AACJ,YAAM,aAAa,MAAMH,iBAAA,MAAK,yBAAA,iBAAA,EAAL,KAAA,MAAqB,MAAA;AAE9C,UAAIE,eAAA,MAAK,kBAAA,GAAoB;AAC5B,cAAMG,QAAOF;AACb,eAAO;UACN;UACA,UAAAA;UACA;UACA,cACC,MAAM,KAAK,uBAAuB;YACjC,QAAQA,UAAS;YACjB,MAAM;YACN,OAAOE,MAAK;YACZ,UAAU;YACV,cAAc,WAAW,GAAG;YAC5B;YACA,cAAcA,MAAK,SAAS;UAC7B,CAAC,GACA;QACH;MACD;AAEA,YAAM,OAAOF;AAEb,aAAO;QACN;QACA,UAAAA;QACA;QACA,eAAe,MAAM,KAAK,wBAAwB;UACjD,QAAQA,UAAS;UACjB,UAAU,WAAW,GAAG;UACxB,UAAU,KAAK;UACf,eAAe,KAAK;UACpB;QACD,CAAC;MACF;IACD;AAEA,UAAM,UAAU,CAAC;MAChB,UAAAA;MACA;MACA;MACA;MACA;IACD,MAA0C;AACzC,aAAO;QACN;QACA,UAAAA;QACA,aAAa,gBACV,KAAK,uBAAuB;UAC5B,QAAQA,UAAS;UACjB,cAAc,WAAW,GAAG;UAC5B;UACA;QACD,CAAC,IACA,KAAK,uBAAuB;UAC5B;UACA,QAAQA,UAAS;UACjB,cAAc,WAAW,GAAG;UAC5B;QACD,CAAC;MACJ;IACD;AAEA,mBAAe,QAAQ,EAAE,YAAY,UAAAA,UAAS,GAAwC;AACrF,aAAO;QACN,QAAQA,UAAS;QACjB;MACD;IACD;AAEA,UAAM,cAMF,CAAC;AAEL,aAAS,WACR,MACA,SACuC;AACvC,UAAI,CAAC,YAAY,IAAI,GAAG;AACvB,cAAM,IAAI,MAAM,GAAG,IAAI,oCAAoC,OAAO,EAAE;MACrE;AACA,aAAO,YAAY,IAAI;IACxB;AAEA,WAAO;MACN,QAAQ,YAAY;AACnB,YAAI,CAAC,YAAY,QAAQ;AACxB,sBAAY,SAAS,MAAM,OAAO;QACnC;MACD;MACA,UAAU,CAAC,YAA0C;AACpD,oBAAY,WAAW,SAAS,WAAW,UAAU,UAAU,GAAG,OAAO;AACzE,eAAO,YAAY,SAAS;MAC7B;MACA,QAAQ,OAAO,YAAwC;AACtD,oBAAY,SAAS,MAAM,OAAO,WAAW,YAAY,QAAQ,GAAG,OAAO;MAC5E;MACA,SAAS,MAAM;AACd,oBAAY,UAAU,QAAQ,WAAW,UAAU,SAAS,CAAC;AAC7D,eAAO,YAAY,QAAQ;MAC5B;MACA,SAAS,YAAY;AACpB,eAAO,QAAQ,WAAW,WAAW,SAAS,CAAC;MAChD;IACD;EACD;AACD;AA92EC,qBAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AAEA,iBAAA,oBAAA,QAAA;AACA,aAAA,oBAAA,QAAA;AACA,gBAAA,oBAAA,QAAA;AAEA,gCAAA,oBAAA,QAAA;AACA,iBAAA,oBAAA,QAAA;AAEAN,UAAA,oBAAA,QAAA;AAEA,qBAAA,oBAAA,QAAA;AACA,qBAAA,oBAAA,QAAA;AAdM,0BAAA,oBAAA,QAAA;AAkFN,aAAQ,WAAG;AACV,SAAOK,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,SAAS,GAAG,YAAY;;AAChD,UAAM,gBAAgB,MAAMK,eAAA,MAAK,UAAA,EAAW,KAAK,gBAAgB;MAChE,WAAW,MAAMF,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,IAAA;MACjB,YAAY;MACZ,MAAM;IACP,CAAC;AAED,UAAM,UAAU,cAAc,SAAS,WAAW,CAAC;AACnD,UAAM,cAAc,QAAQ,KAAK,UAAU,aAAa,QAAQ,KAAK,WAAW;AAChF,UAAM,oBACL,gDAAa,eAAe,OAA5B,mBAAgC,WAAU,aAAa,YAAY,eAAe,CAAC,IAAI;AAExF,SAAI,mDAAiB,WAAU,YAAY;AAC1C,YAAM,IAAI,kBAAkB,oBAAoB;IACjD;AAEA,WAAO,mBAAmB,gBAAgB,SAAS,QAAQ;EAC5D,CAAC;AACF;AAEA,kBAAa,WAAG;AACf,SAAOE,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,cAAc,GAAG,YAAY;AACrD,UAAM,SAAS,MAAMK,eAAA,MAAK,aAAA,EAAc,KAAKA,eAAA,MAAK,cAAA,EAAe,cAAc;AAC/E,WAAO,eAAe,OAAO,IAAK,EAAE;EACrC,CAAC;AACF;AASA,wBAAmB,WAAG;AACrB,SAAOA,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,oBAAoB,GAAG,YAAY;AAC3D,UAAM,EAAE,WAAW,IAAI,MAAM,KAAK,aAAa;AAC/C,WAAO;EACR,CAAC;AACF;AAEA,kBAAa,WAAG;AACf,SAAOK,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,cAAc,GAAG,YAAY;AACrD,WAAO,gBAAgBK,eAAA,MAAK,QAAA,CAAQ;EACrC,CAAC;AACF;AAsCM,sBAAiB,eAAC,EAAE,QAAQ,OAAO,GAAoB;AAC5D,QAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,QAAM,YAAY,YAAY,UAAU;AAExC,QAAM,eAAe,MAAM,KAAK,gBAAgB,EAAE,QAAQ,OAAO,CAAC;AAElE,QAAM,UAAU,MAAM,KAAK,WAAW,EAAE,QAAQ,OAAO,CAAC;AAExD,QAAM,WAAW,MAAMF,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,IAAA;AAEvB,QAAM,YAAY,SAAS;IAC1B;IACA;IACA,aAAa,SAAS,GAAG;IACzB;EACD;AAEA,QAAM,4BAA4B,SAAS;IAC1C,YAAY,UAAU;IACtB;EACD;AAEA,MAAI,0BAA0B,WAAW,QAAQ;AAChD,UAAM,IAAI,sBAAsB,6CAA6C;EAC9E;AAEA,SAAO;AACR;AA2UM,2BAAsB,eAAC,EAAE,QAAQ,OAAO,GAAiC;AAC9E,QAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,QAAM,eAAe,aAAa;AAElC,MAAI,aAAa,YAAY,UAAU,mBAAmB;AACzD,UAAM,SAAS,MAAM,KAAK,sBAAsB,EAAE,QAAQ,OAAO,CAAC;AAClE,QAAI,OAAO,SAAS,iBAAiB,OAAO,SAAS,WAAW;AAC/D,YAAM,IAAI,sBAAsB,sBAAsB,MAAM,OAAO,OAAO,IAAI,GAAG;IAClF;AAEA,QAAI,OAAO,OAAO,0BAA0B,UAAU;AACrD,YAAM,IAAI,sBAAsB,sBAAsB,MAAM,oBAAoB;IACjF;AAEA,QAAI,OAAO,wBAAwB,cAAc;AAChD,YAAM,IAAI;QACT,0BAA0B,YAAY,oDAAoD,OAAO,qBAAqB;MACvH;IACD;AAEA,WAAO,OAAO;EACf;AAEA,SAAO;AACR;AAUM,sBAAiB,eAAC,SAA0B;AACjD,MAAI,CAACE,eAAA,MAAK,cAAA,GAAgB;AACzB,IAAAD,cAAA,MAAK,gBAAiBD,iBAAA,MAAK,yBAAA,wBAAA,EAAL,KAAA,MAA4B,OAAA,CAAA;EACnD;AACA,SAAOE,eAAA,MAAK,cAAA;AACb;AAEM,2BAAsB,eAAC,EAAE,QAAQ,OAAO,GAAoB;AACjE,QAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,QAAM,kBAAkB,aAAa,YAAY,UAAU;AAC3D,QAAM,qBAAqB,MAAMF,iBAAA,MAAK,yBAAA,wBAAA,EAAL,KAAA,MAA4B,EAAE,QAAQ,OAAO,CAAA;AAE9E,MAAI,mBAAmB,qBAAqB,aAAa,OAAO;AAC/D,WAAO,MAAMA,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,MAAmB,aAAa,kBAAA;EAC9C;AACA,SAAO,MAAMA,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AACd;AAsDA,aAA4C,SAC3C,QACA,QACA,IACC;AACD,SAAO,OAAO,OAAgC;AAC7C,UAAM,UAAU,MAAMA,iBAAA,MAAK,yBAAA,UAAA,EAAL,KAAA,IAAA;AACtB,UAAM,OAAO,SACV,GAAG,WAAW,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,IACjC,GAAG;MACH,gBAAgB;QACf,SAAS;QACT,MAAM;MACP,CAAC;IACF;AAEF,UAAM,SAAS,MAAM,GAAG,MAAM,EAAE;AAEhC,OAAG,SAAS;MACX,QAAQ;MACR,eAAe,CAAC,OAAO;MACvB,WAAW,CAAC,IAAI;IACjB,CAAC;AAED,WAAO;EACR;AACD;AAwJA,mBAAc,WAAG;AAChB,SAAOE,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,yBAAyB,GAAG,YAAY;;AAChE,QAAI,GAAC,KAAAK,eAAA,MAAK,kBAAA,MAAL,mBAAyB,YAAW,CAACA,eAAA,MAAK,kBAAA,GAAoB;AAClE,aAAO;IACR;AAEA,QAAI,UAAUA,eAAA,MAAK,kBAAA,EAAmB,SAAS;AAC9C,aAAOA,eAAA,MAAK,kBAAA,EAAmB;IAChC;AAEA,UAAM,YAAY,MAAMA,eAAA,MAAK,kBAAA,EAAmB,UAAU;AAE1D,QAAI,CAAC,WAAW;AACf,aAAO;IACR;AAEA,WAAO;MACN,GAAG;MACH,KAAKA,eAAA,MAAK,kBAAA,EAAmB,QAAQ;IACtC;EACD,CAAC;AACF;AAsIM,oBAAe,eAAC,QAAgB;AACrC,QAAM,WAAW,MAAM,KAAK,YAAY;AACxC,QAAM;IACL,aAAa,EAAE,QAAQ;EACxB,IAAI,MAAMA,eAAA,MAAK,UAAA,EAAW,KAAK,mBAAmB;IACjD;EACD,CAAC;AAED,QAAM,mBAAmB,mCAAS,eAChC,OAAO,CAAC,WAAW,OAAO,gBAAgB,WAC1C,IAAI,CAAC,WAAW,OAAO;AAEzB,QAAM,iBAAiB,MAAMA,eAAA,MAAK,UAAA,EAAW,KAAK,WAAW;IAC5D,WAAW;EACZ,CAAC;AAED,QAAM,gBAAgB,eAAe,QAAQ;IAC5C,CAAC,WAAW,EAAE,kBAAkB,UAAU,OAAO,SAAS;EAC3D;AAEA,MAAI,yBAAyB,SAAS,CAAC,eAAe;AACrD,UAAM,IAAI;MACT,iEAAiE,MAAM;IACxE;EACD;AAEA,SAAO,KAAK,MAAM,MAAM,cAAc,OAAO;AAC9C;AAkUA,+BAA0B,SAAC;EAC1B;EACA;EACA;AACD,GAIG;AACF,SAAO,OAAO,OAAoB;AACjC,UAAM,kBAAkB,MAAMF,iBAAA,MAAK,yBAAA,qBAAA,EAAL,KAAA,IAAA;AAE9B,QAAI,CAAC,oBAAoB;AACxB,SAAG;QACF,YAAY;UACX,SAAS;UACT,WAAW;YACV,MAAM;YACN,UAAmB,KAAK;cACvB,SAAS;YACV,CAAC;UACF;QACD,CAAC;MACF;IACD;AAEA,WAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACxC,YAAM,QAAQ,WAAW,GAAG;AAE5B,UAAI,UAAU,MAAM;AACnB,YAAI,sBAAsB,OAAO,oBAAoB;AACpD,aAAG;YACF,mBAAmB;cAClB,SAAS;cACT,WAAW;gBACV,MAAM;gBACN;cACD;YACD,CAAC;UACF;QACD;MACD,OAAO;AACN,WAAG;UACF,2BAA2B;YAC1B,SAAS;YACT,WAAW;cACV,MAAM;cACN;cACA;YACD;UACD,CAAC;QACF;MACD;IACD,CAAC;EACF;AACD;AAggBM,wBAAmB,eAAC,aAA0B,QAAgB,QAAgB;AACnF,cAAY,kBAAkB,OAAO,aAAa,CAAC;AAEnD,QAAM,EAAE,QAAQ,QAAQ,IAAI,MAAM,OAAO,0BAA0B;IAClE;IACA,QAAQE,eAAA,MAAK,UAAA;EACd,CAAC;AAED,MAAI,mCAAS,OAAO,OAAO;AAC1B,UAAM,IAAI,kBAAkB,aAAa,MAAM,KAAK,MAAM,MAAM,mCAAS,OAAO,KAAK,EAAE;EACxF;AAEA,QAAMA,eAAA,MAAK,UAAA,EAAW,KAAK,mBAAmB;IAC7C;EACD,CAAC;AAED,SAAO,EAAE,QAAQ,QAAQ;AAC1B;AAEM,kBAAa,eAAC,WAA2C;AAC9D,QAAM,cAAc,MAAMF,iBAAA,MAAK,yBAAA,cAAA,EAAL,KAAA,MAAkB,SAAA;AAC5C,QAAM,uBAAuB,wBAAwB,SAAS;AAE9D,QAAM,eAAe,oBAAI,IAAyB;AAClD,QAAM,QAAQ,YAAY,IAAI,CAAC,EAAE,UAAU,GAAG,cAAc;AAC3D,UAAM,eAAe,qBAAqB,IAAI,UAAU,OAAO,KAAK,CAAC;AACrE,UAAM,OAAoB;MACzB,IAAI,UAAU;MACd,MAAM;MACN,YAAY,WAAW,UAAU,eAAe;MAChD;MACA;IACD;AAEA,eAAW,cAAc,cAAc;AACtC,mBAAa,IAAI,YAAY,IAAI;IAClC;AAEA,WAAO;EACR,CAAC;AAED,SAAO;IACN;IACA;EACD;AACD;AAEA,wBAAmB,WAAG;AACrB,SAAOE,eAAA,MAAKL,OAAA,EAAO,KAAK,CAAC,oBAAoB,GAAG,YAAY;AAC3D,UAAM,eAAe,MAAM,KAAK,aAAa;AAC7C,WAAOG,iBAAA,MAAK,yBAAA,eAAA,EAAL,KAAA,MAAmB,aAAa,SAAA;EACxC,CAAC;AACF;AAEM,iBAAY,eAAC,WAA2C;AAC7D,QAAM,UAAU,UAAU,CAAC,EAAE,SAAS,IAAI,CAAC,SAAS,KAAK,GAAG;AAC5D,SAAOE,eAAA,MAAK,aAAA,EAAc,gBAAgB,SAAS,WAAW;AAC/D;AAEM,yBAAoB,eAAC,eAA8B,OAAe;AACvE,QAAM,OAAO,cAAc,aAAa,IAAI,KAAK;AACjD,MAAI,CAAC,MAAM;AACV,UAAM,IAAI,kBAAkB,wBAAwB,KAAK,YAAY;EACtE;AACA,SAAO;AACR;AAeA,gCAAuE,SAAC,IAAU;AACjF,UAAQ,UAAU,SAAwB;AACzC,QAAI;AACH,aAAO,MAAM,GAAG,MAAM,MAAM,IAAI;IACjC,SAAS,OAAO;AACf,UAAI,iBAAiB,4BAA4B;AAChD,aAAK,MAAM;AACX,eAAO,MAAM,GAAG,MAAM,MAAM,IAAI;MACjC;AACA,YAAM;IACP;EACD;AACD;AAj7DM,IAAM,eAAN;",
  "names": ["DataLoader", "val", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "IntentType", "_StorageNodeAPIError", "error", "__privateAdd", "__privateMethod", "fetch", "error", "DataLoader", "__privateAdd", "__privateGet", "ptr", "_fetch", "_timeout", "_onError", "request_fn", "__privateAdd", "__privateSet", "__privateMethod", "__privateGet", "fetch", "error", "safeParseJSON", "__privateAdd", "__privateSet", "__privateGet", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "sliver", "chunk", "_cache", "__privateAdd", "__privateSet", "__privateGet", "columnSize", "_identifier", "_tags", "__privateAdd", "__privateSet", "__privateGet", "_WalrusFile", "__privateAdd", "__privateSet", "__privateGet", "_reader", "_client", "_cache", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "_cache", "_WalrusClient", "__privateAdd", "__privateMethod", "__privateSet", "__privateGet", "metadata", "tx", "meta"]
}
