{
  "version": 3,
  "sources": ["../../@mysten/seal/src/bcs.ts", "../../@noble/curves/src/abstract/bls.ts", "../../@noble/curves/src/abstract/tower.ts", "../../@noble/curves/src/bls12-381.ts", "../../@mysten/seal/src/bls12381.ts", "../../@noble/hashes/src/sha3.ts", "../../@mysten/seal/src/error.ts", "../../@mysten/seal/src/utils.ts", "../../@mysten/seal/src/dem.ts", "../../@mysten/seal/src/kdf.ts", "../../@mysten/seal/src/ibe.ts", "../../@mysten/seal/src/shamir.ts", "../../@mysten/seal/src/decrypt.ts", "../../@mysten/seal/src/encrypt.ts", "../../@mysten/seal/src/version.ts", "../../@mysten/seal/src/elgamal.ts", "../../@mysten/seal/src/key-server.ts", "../../@mysten/seal/src/client.ts", "../../@noble/curves/src/secp256k1.ts", "../../@mysten/sui/src/keypairs/secp256k1/publickey.ts", "../../@mysten/sui/src/keypairs/secp256r1/publickey.ts", "../../@mysten/sui/src/multisig/signer.ts", "../../@mysten/sui/src/multisig/publickey.ts", "../../@mysten/sui/src/verify/verify.ts", "../../@mysten/seal/src/session-key.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex, toHex } from '@mysten/bcs';\nimport { bcs } from '@mysten/sui/bcs';\n\nexport const IBEEncryptions = bcs.enum('IBEEncryptions', {\n\tBonehFranklinBLS12381: bcs.struct('BonehFranklinBLS12381', {\n\t\tnonce: bcs.bytes(96),\n\t\tencryptedShares: bcs.vector(bcs.bytes(32)),\n\t\tencryptedRandomness: bcs.bytes(32),\n\t}),\n});\n\nexport const Ciphertext = bcs.enum('Ciphertext', {\n\tAes256Gcm: bcs.struct('Aes256Gcm', {\n\t\tblob: bcs.byteVector(),\n\t\taad: bcs.option(bcs.byteVector()),\n\t}),\n\tHmac256Ctr: bcs.struct('Hmac256Ctr', {\n\t\tblob: bcs.byteVector(),\n\t\taad: bcs.option(bcs.byteVector()),\n\t\tmac: bcs.bytes(32),\n\t}),\n\tPlain: bcs.struct('Plain', {}),\n});\n\n/**\n * The encrypted object format. Should be aligned with the Rust implementation.\n */\nexport const EncryptedObject = bcs.struct('EncryptedObject', {\n\tversion: bcs.u8(),\n\tpackageId: bcs.Address,\n\tid: bcs.byteVector().transform({\n\t\toutput: (val) => toHex(val),\n\t\tinput: (val: string) => fromHex(val),\n\t}),\n\tservices: bcs.vector(bcs.tuple([bcs.Address, bcs.u8()])),\n\tthreshold: bcs.u8(),\n\tencryptedShares: IBEEncryptions,\n\tciphertext: Ciphertext,\n});\n\n/**\n * The Move struct for the KeyServerV1 object.\n */\nexport const KeyServerMoveV1 = bcs.struct('KeyServerV1', {\n\tname: bcs.string(),\n\turl: bcs.string(),\n\tkeyType: bcs.u8(),\n\tpk: bcs.byteVector(),\n});\n\n/**\n * The Move struct for the parent object.\n */\nexport const KeyServerMove = bcs.struct('KeyServer', {\n\tid: bcs.Address,\n\tfirstVersion: bcs.u64(), // latest version\n\tlastVersion: bcs.u64(), // oldest version\n});\n", "/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two modes of operation:\n * - Long signatures:  X-byte keys + 2X-byte sigs (G1 keys + G2 sigs).\n * - Short signatures: 2X-byte keys + X-byte sigs (G2 keys + G1 sigs).\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  ensureBytes,\n  memoized,\n  randomBytes,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport { normalizeZ } from './curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CHashOpts,\n  type H2COpts,\n  type H2CPointConstructor,\n  type htfBasicOpts,\n  type MapToCurve,\n} from './hash-to-curve.ts';\nimport { getMinHashLength, mapHashToField, type IField } from './modular.ts';\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6Bls } from './tower.ts';\nimport {\n  _normFnElement,\n  weierstrassPoints,\n  type CurvePointsRes,\n  type CurvePointsType,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './weierstrass.ts';\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n};\n\nexport type BlsFields = {\n  Fp: IField<Fp>;\n  Fr: IField<bigint>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n};\n\nexport type PostPrecomputePointAddFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\nexport type PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => void;\nexport type BlsPairing = {\n  Fp12: Fp12Bls;\n  calcPairingPrecomputes: (p: WeierstrassPoint<Fp2>) => Precompute;\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: WeierstrassPoint<Fp>, Q: WeierstrassPoint<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: WeierstrassPoint<Fp>; g2: WeierstrassPoint<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n};\n// TODO: replace CurveType with this? It doesn't contain r however and has postPrecompute\nexport type BlsPairingParams = {\n  // NOTE: MSB is always ignored and used as marker for length,\n  // otherwise leading zeros will be lost.\n  // Can be different from 'X' (seed) param!\n  ateLoopSize: bigint;\n  xNegative: boolean;\n  twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\nexport type CurveType = {\n  G1: CurvePointsType<Fp> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: H2COpts;\n  };\n  G2: CurvePointsType<Fp2> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: H2COpts;\n  };\n  fields: BlsFields;\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: BlsPairingParams['ateLoopSize'];\n    xNegative: BlsPairingParams['xNegative'];\n    r: bigint; // TODO: remove\n    twistType: BlsPairingParams['twistType']; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: H2COpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\n/**\n * BLS consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n */\nexport interface BLSCurvePair {\n  longSignatures: BLSSigs<bigint, Fp2>;\n  shortSignatures: BLSSigs<Fp2, bigint>;\n  millerLoopBatch: BlsPairing['millerLoopBatch'];\n  pairing: BlsPairing['pairing'];\n  pairingBatch: BlsPairing['pairingBatch'];\n  G1: { Point: WeierstrassPointCons<bigint> } & H2CHasher<Fp>;\n  G2: { Point: WeierstrassPointCons<Fp2> } & H2CHasher<Fp2>;\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: Fp6Bls;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomSecretKey: () => Uint8Array;\n    /** @deprecated use randomSecretKey */\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: BlsPairing['calcPairingPrecomputes'];\n  };\n}\n\nexport type CurveFn = BLSCurvePair & {\n  /** @deprecated use `longSignatures.getPublicKey` */\n  getPublicKey: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `shortSignatures.getPublicKey` */\n  getPublicKeyForShortSignatures: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `longSignatures.sign` */\n  sign: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp2>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.sign` */\n  signShortSignature: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.verify` */\n  verify: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    message: Hex | WeierstrassPoint<Fp2>,\n    publicKey: Hex | WeierstrassPoint<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `shortSignatures.verify` */\n  verifyShortSignature: (\n    signature: Hex | WeierstrassPoint<Fp>,\n    message: Hex | WeierstrassPoint<Fp>,\n    publicKey: Hex | WeierstrassPoint<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    messages: (Hex | WeierstrassPoint<Fp2>)[],\n    publicKeys: (Hex | WeierstrassPoint<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `longSignatures.aggregatePublicKeys` */\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.aggregateSignatures` */\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp2>[]): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.aggregateSignatures` */\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  G1: CurvePointsRes<Fp> & H2CHasher<Fp>;\n  G2: CurvePointsRes<Fp2> & H2CHasher<Fp2>;\n  /** @deprecated use `longSignatures.Signature` */\n  Signature: SignatureCoder<Fp2>;\n  /** @deprecated use `shortSignatures.Signature` */\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    twistType: TwistType;\n    /** @deprecated */\n    G1b: bigint;\n    /** @deprecated */\n    G2b: Fp2;\n  };\n};\n\ntype BLSInput = Hex | Uint8Array;\nexport interface BLSSigs<P, S> {\n  getPublicKey(secretKey: PrivKey): WeierstrassPoint<P>;\n  sign(hashedMessage: WeierstrassPoint<S>, secretKey: PrivKey): WeierstrassPoint<S>;\n  verify(\n    signature: WeierstrassPoint<S> | BLSInput,\n    message: WeierstrassPoint<S>,\n    publicKey: WeierstrassPoint<P> | BLSInput\n  ): boolean;\n  verifyBatch: (\n    signature: WeierstrassPoint<S> | BLSInput,\n    messages: WeierstrassPoint<S>[],\n    publicKeys: (WeierstrassPoint<P> | BLSInput)[]\n  ) => boolean;\n  aggregatePublicKeys(publicKeys: (WeierstrassPoint<P> | BLSInput)[]): WeierstrassPoint<P>;\n  aggregateSignatures(signatures: (WeierstrassPoint<S> | BLSInput)[]): WeierstrassPoint<S>;\n  hash(message: Uint8Array, DST?: string | Uint8Array, hashOpts?: H2CHashOpts): WeierstrassPoint<S>;\n  Signature: SignatureCoder<S>;\n}\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nfunction aNonEmpty(arr: any[]) {\n  if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n}\n\n// This should be enough for bn254, no need to export full stuff?\nfunction createBlsPairing(\n  fields: BlsFields,\n  G1: WeierstrassPointCons<Fp>,\n  G2: WeierstrassPointCons<Fp2>,\n  params: BlsPairingParams\n): BlsPairing {\n  const { Fp2, Fp12 } = fields;\n  const { twistType, ateLoopSize, xNegative, postPrecompute } = params;\n  type G1 = typeof G1.BASE;\n  type G2 = typeof G2.BASE;\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (twistType === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (twistType === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (postPrecompute) {\n      const last = ell[ell.length - 1];\n      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (xNegative) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // Cache precomputed toAffine for all points\n    normalizeZ(\n      G1,\n      pairs.map(({ g1 }) => g1)\n    );\n    normalizeZ(\n      G2,\n      pairs.map(({ g2 }) => g2)\n    );\n    for (const { g1, g2 } of pairs) {\n      if (g1.is0() || g2.is0()) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n  return {\n    Fp12, // NOTE: we re-export Fp12 here because pairing results are Fp12!\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    calcPairingPrecomputes,\n  };\n}\n\nfunction createBlsSig<P, S>(\n  blsPairing: BlsPairing,\n  PubCurve: CurvePointsRes<P> & H2CHasher<P>,\n  SigCurve: CurvePointsRes<S> & H2CHasher<S>,\n  SignatureCoder: SignatureCoder<S>,\n  isSigG1: boolean\n): BLSSigs<P, S> {\n  const { Fp12, pairingBatch } = blsPairing;\n  type PubPoint = WeierstrassPoint<P>;\n  type SigPoint = WeierstrassPoint<S>;\n  function normPub(point: PubPoint | BLSInput): PubPoint {\n    return point instanceof PubCurve.Point ? (point as PubPoint) : PubCurve.Point.fromHex(point);\n  }\n  function normSig(point: SigPoint | BLSInput): SigPoint {\n    return point instanceof SigCurve.Point ? (point as SigPoint) : SigCurve.Point.fromHex(point);\n  }\n  function amsg(m: unknown): SigPoint {\n    if (!(m instanceof SigCurve.Point))\n      throw new Error(`expected valid message hashed to ${!isSigG1 ? 'G2' : 'G1'} curve`);\n    return m as SigPoint;\n  }\n\n  type G1 = CurvePointsRes<Fp>['Point']['BASE'];\n  type G2 = CurvePointsRes<Fp2>['Point']['BASE'];\n  type PairingInput = { g1: G1; g2: G2 };\n  // What matters here is what point pairing API accepts as G1 or G2, not actual size or names\n  const pair: (a: PubPoint, b: SigPoint) => PairingInput = !isSigG1\n    ? (a: PubPoint, b: SigPoint) => ({ g1: a, g2: b }) as PairingInput\n    : (a: PubPoint, b: SigPoint) => ({ g1: b, g2: a }) as PairingInput;\n  return {\n    // P = pk x G\n    getPublicKey(secretKey: PrivKey): PubPoint {\n      // TODO: replace with\n      // const sec = PubCurve.Point.Fn.fromBytes(secretKey);\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      return PubCurve.Point.BASE.multiply(sec);\n    },\n    // S = pk x H(m)\n    sign(message: SigPoint, secretKey: PrivKey, unusedArg?: any): SigPoint {\n      if (unusedArg != null) throw new Error('sign() expects 2 arguments');\n      // TODO: replace with\n      // PubCurve.Point.Fn.fromBytes(secretKey)\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      amsg(message).assertValidity();\n      return message.multiply(sec);\n    },\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    // e(S, G) == e(H(m), P)\n    verify(\n      signature: SigPoint | BLSInput,\n      message: SigPoint,\n      publicKey: PubPoint | BLSInput,\n      unusedArg?: any\n    ): boolean {\n      if (unusedArg != null) throw new Error('verify() expects 3 arguments');\n      signature = normSig(signature);\n      publicKey = normPub(publicKey);\n      const P = publicKey.negate();\n      const G = PubCurve.Point.BASE;\n      const Hm = amsg(message);\n      const S = signature;\n      // This code was changed in 1.9.x:\n      // Before it was G.negate() in G2, now it's always pubKey.negate\n      // e(P, -Q)===e(-P, Q)==e(P, Q)^-1. Negate can be done anywhere (as long it is done once per pair).\n      // We just moving sign, but since pairing is multiplicative, we doing X * X^-1 = 1\n      const exp = pairingBatch([pair(P, Hm), pair(G, S)]);\n      return Fp12.eql(exp, Fp12.ONE);\n    },\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    verifyBatch(\n      signature: SigPoint | BLSInput,\n      messages: SigPoint[],\n      publicKeys: (PubPoint | BLSInput)[]\n    ): boolean {\n      aNonEmpty(messages);\n      if (publicKeys.length !== messages.length)\n        throw new Error('amount of public keys and messages should be equal');\n      const sig = normSig(signature);\n      const nMessages = messages;\n      const nPublicKeys = publicKeys.map(normPub);\n      // NOTE: this works only for exact same object\n      const messagePubKeyMap = new Map<SigPoint, PubPoint[]>();\n      for (let i = 0; i < nPublicKeys.length; i++) {\n        const pub = nPublicKeys[i];\n        const msg = nMessages[i];\n        let keys = messagePubKeyMap.get(msg);\n        if (keys === undefined) {\n          keys = [];\n          messagePubKeyMap.set(msg, keys);\n        }\n        keys.push(pub);\n      }\n      const paired = [];\n      const G = PubCurve.Point.BASE;\n      try {\n        for (const [msg, keys] of messagePubKeyMap) {\n          const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n          paired.push(pair(groupPublicKey, msg));\n        }\n        paired.push(pair(G.negate(), sig));\n        return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n      } catch {\n        return false;\n      }\n    },\n    // Adds a bunch of public key points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregatePublicKeys(publicKeys: (PubPoint | BLSInput)[]): PubPoint {\n      aNonEmpty(publicKeys);\n      publicKeys = publicKeys.map((pub) => normPub(pub));\n      const agg = (publicKeys as PubPoint[]).reduce((sum, p) => sum.add(p), PubCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    // Adds a bunch of signature points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregateSignatures(signatures: (SigPoint | BLSInput)[]): SigPoint {\n      aNonEmpty(signatures);\n      signatures = signatures.map((sig) => normSig(sig));\n      const agg = (signatures as SigPoint[]).reduce((sum, s) => sum.add(s), SigCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    hash(messageBytes: Uint8Array, DST?: string | Uint8Array): SigPoint {\n      abytes(messageBytes);\n      const opts = DST ? { DST } : undefined;\n      return SigCurve.hashToCurve(messageBytes, opts) as SigPoint;\n    },\n    Signature: SignatureCoder,\n  };\n}\n\n// G1_Point: ProjConstructor<bigint>, G2_Point: ProjConstructor<Fp2>,\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints(CURVE.G1);\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.Point, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints(CURVE.G2);\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.Point as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.Point.BASE;\n  type G2 = typeof G2.Point.BASE;\n\n  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {\n    ...CURVE.params,\n    postPrecompute: CURVE.postPrecompute,\n  });\n\n  const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;\n  const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);\n  const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);\n\n  const rand = CURVE.randomBytes || randomBytes;\n  const randomSecretKey = (): Uint8Array => {\n    const length = getMinHashLength(Fr.ORDER);\n    return mapHashToField(rand(length), Fr.ORDER);\n  };\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n    calcPairingPrecomputes,\n  };\n\n  // LEGACY code\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.Point\n      ? point\n      : shortSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.Point\n      ? point\n      : longSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return longSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return shortSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const Hm = normP2Hash(message, htfOpts);\n    const S = longSignatures.sign(Hm, privateKey);\n    return message instanceof G2.Point ? S : Signature.toBytes(S);\n  }\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const Hm = normP1Hash(message, htfOpts);\n    const S = shortSignatures.sign(Hm, privateKey);\n    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);\n  }\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP2Hash(message, htfOpts);\n    return longSignatures.verify(signature, Hm, publicKey);\n  }\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP1Hash(message, htfOpts);\n    return shortSignatures.verify(signature, Hm, publicKey);\n  }\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    const agg = longSignatures.aggregatePublicKeys(publicKeys);\n    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);\n  }\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    const agg = longSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);\n  }\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    const agg = shortSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);\n  }\n  function verifyBatch(\n    signature: G2Hex,\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = messages.map((m) => normP2Hash(m, htfOpts));\n    return longSignatures.verifyBatch(signature, Hm, publicKeys);\n  }\n\n  G1.Point.BASE.precompute(4);\n\n  return {\n    longSignatures,\n    shortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    verifyBatch,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      twistType: CURVE.params.twistType,\n      // deprecated\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n\n    // deprecated\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n  };\n}\n", "/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, concatBytes, notImplemented } from '../utils.ts';\nimport * as mod from './modular.ts';\nimport type { WeierstrassPoint, WeierstrassPointCons } from './weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\n// Fp₂ over complex plane\nexport type BigintTuple = [bigint, bigint];\nexport type Fp = bigint;\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u² - β) where β = -1\nexport type Fp2 = { c0: bigint; c1: bigint };\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\n// prettier-ignore\nexport type BigintTwelve = [\n  bigint, bigint, bigint, bigint, bigint, bigint,\n  bigint, bigint, bigint, bigint, bigint, bigint\n];\n\nexport type Fp2Bls = mod.IField<Fp2> & {\n  frobeniusMap(num: Fp2, power: number): Fp2;\n  fromBigTuple(num: [bigint, bigint]): Fp2;\n  mulByB: (num: Fp2) => Fp2;\n  mulByNonresidue: (num: Fp2) => Fp2;\n  reim: (num: Fp2) => { re: Fp; im: Fp };\n  NONRESIDUE: Fp2;\n};\n\nexport type Fp6Bls = mod.IField<Fp6> & {\n  frobeniusMap(num: Fp6, power: number): Fp6;\n  fromBigSix: (tuple: BigintSix) => Fp6;\n  mul1(num: Fp6, b1: Fp2): Fp6;\n  mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n  mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  mulByNonresidue: (num: Fp6) => Fp6;\n};\n\nexport type Fp12Bls = mod.IField<Fp12> & {\n  frobeniusMap(num: Fp12, power: number): Fp12;\n  fromBigTwelve: (t: BigintTwelve) => Fp12;\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n  mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n  conjugate(num: Fp12): Fp12;\n  finalExponentiate(num: Fp12): Fp12;\n  _cyclotomicSquare(num: Fp12): Fp12;\n  _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n};\n\nfunction calcFrobeniusCoefficients<T>(\n  Fp: mod.IField<T>,\n  nonResidue: T,\n  modulus: bigint,\n  degree: number,\n  num: number = 1,\n  divisor?: number\n) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus: any = modulus ** BigInt(degree);\n  const res: T[][] = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers: T[] = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(\n  Fp: mod.IField<Fp>,\n  Fp2: Fp2Bls,\n  base: Fp2\n): {\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  G2psi: (c: WeierstrassPointCons<Fp2>, P: WeierstrassPoint<Fp2>) => WeierstrassPoint<Fp2>;\n  G2psi2: (c: WeierstrassPointCons<Fp2>, P: WeierstrassPoint<Fp2>) => WeierstrassPoint<Fp2>;\n  PSI_X: Fp2;\n  PSI_Y: Fp2;\n  PSI2_X: Fp2;\n  PSI2_Y: Fp2;\n} {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine =\n    <T>(fn: (x: T, y: T) => [T, T]) =>\n    (c: WeierstrassPointCons<T>, P: WeierstrassPoint<T>) => {\n      const affine = P.toAffine();\n      const p = fn(affine.x, affine.y);\n      return c.fromAffine({ x: p[0], y: p[1] });\n    };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\n\nexport type Tower12Opts = {\n  ORDER: bigint;\n  NONRESIDUE?: Fp;\n  // Fp2\n  FP2_NONRESIDUE: BigintTuple;\n  Fp2sqrt?: (num: Fp2) => Fp2;\n  Fp2mulByB: (num: Fp2) => Fp2;\n  // Fp12\n  Fp12cyclotomicSquare: (num: Fp12) => Fp12;\n  Fp12cyclotomicExp: (num: Fp12, n: bigint) => Fp12;\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\n};\n\nexport function tower12(opts: Tower12Opts): {\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\n} {\n  const { ORDER } = opts;\n  // Fp\n  const Fp = mod.Field(ORDER);\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n\n  // Fp2\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n  const Fp2Add = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1),\n  });\n  const Fp2Subtract = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1),\n  });\n  const Fp2Multiply = ({ c0, c1 }: Fp2, rhs: Fp2) => {\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  };\n  const Fp2Square = ({ c0, c1 }: Fp2) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n  };\n  const Fp2fromBigTuple = (tuple: BigintTuple | bigint[]) => {\n    if (tuple.length !== 2) throw new Error('invalid tuple');\n    const fps = tuple.map((n) => Fp.create(n)) as [Fp, Fp];\n    return { c0: fps[0], c1: fps[1] };\n  };\n\n  function isValidC(num: bigint, ORDER: bigint) {\n    return typeof num === 'bigint' && _0n <= num && num < ORDER;\n  }\n\n  const FP2_ORDER = ORDER * ORDER;\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n  const Fp2: Fp2Bls = {\n    ORDER: FP2_ORDER,\n    isLE: Fp.isLE,\n    NONRESIDUE: Fp2Nonresidue,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => isValidC(c0, FP2_ORDER) && isValidC(c1, FP2_ORDER),\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n    isValidNot0: (num) => !Fp2.is0(num) && Fp2.isValid(num),\n    eql: ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) =>\n      Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n      // We wish to find the multiplicative inverse of a nonzero\n      // element a + bu in Fp2. We leverage an identity\n      //\n      // (a + bu)(a - bu) = a² + b²\n      //\n      // which holds because u² = -1. This can be rewritten as\n      //\n      // (a + bu)(a - bu)/(a² + b²) = 1\n      //\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\n      // This gives that (a - bu)/(a² + b²) is the inverse\n      // of (a + bu). Importantly, this can be computing using\n      // only a single inversion in Fp.\n      const factor = Fp.inv(Fp.create(a * a + b * b));\n      return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n    },\n    sqrt: (num) => {\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\n      // This is generic for all quadratic extensions (Fp2)\n      const { c0, c1 } = num;\n      if (Fp.is0(c1)) {\n        // if c0 is quadratic residue\n        if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n        else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\n      }\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n      const legendre = mod.FpLegendre(Fp, d);\n      // -1, Quadratic non residue\n      if (legendre === -1) d = Fp.sub(d, a);\n      const a0 = Fp.sqrt(d);\n      const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n      const x1 = candidateSqrt;\n      const x2 = Fp2.neg(x1);\n      const { re: re1, im: im1 } = Fp2.reim(x1);\n      const { re: re2, im: im2 } = Fp2.reim(x2);\n      if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\n      return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: (x: Fp2) => {\n      const { re: x0, im: x1 } = Fp2.reim(x);\n      const sign_0 = x0 % _2n;\n      const zero_0 = x0 === _0n;\n      const sign_1 = x1 % _2n;\n      return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n    },\n    // Bytes util\n    fromBytes(b: Uint8Array): Fp2 {\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp.cmov(c0, r0, c),\n      c1: Fp.cmov(c1, r1, c),\n    }),\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\n    mulByB: opts.Fp2mulByB,\n    fromBigTuple: Fp2fromBigTuple,\n    frobeniusMap: ({ c0, c1 }, power: number): Fp2 => ({\n      c0,\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n    }),\n  };\n  // Fp6\n  const Fp6Add = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2),\n  });\n  const Fp6Subtract = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2),\n  });\n  const Fp6Multiply = ({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) => {\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(\n        t0,\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\n      ),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\n        Fp2.mulByNonresidue(t2)\n      ),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n  };\n  const Fp6Square = ({ c0, c1, c2 }: Fp6) => {\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n  };\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    6,\n    2,\n    3\n  );\n\n  const Fp6: Fp6Bls = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp2.isLE,\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: bitMask(3 * Fp2.BITS),\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    isValidNot0: (num) => !Fp6.is0(num) && Fp6.isValid(num),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) =>\n      Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: notImplemented,\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) =>\n      Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n\n    inv: ({ c0, c1, c2 }) => {\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n      let t4 = Fp2.inv(\n        Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\n      );\n      return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp6 => {\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1, c2 }): Uint8Array =>\n      concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c) => ({\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c),\n    }),\n    fromBigSix: (t: BigintSix): Fp6 => {\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n      return {\n        c0: Fp2.fromBigTuple(t.slice(0, 2) as BigintTuple),\n        c1: Fp2.fromBigTuple(t.slice(2, 4) as BigintTuple),\n        c2: Fp2.fromBigTuple(t.slice(4, 6) as BigintTuple),\n      };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power: number) => ({\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n    }),\n    mulByFp2: ({ c0, c1, c2 }, rhs: Fp2): Fp6 => ({\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs),\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    mul1: ({ c0, c1, c2 }, b1: Fp2): Fp6 => ({\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1),\n    }),\n    // Sparse multiplication\n    mul01({ c0, c1, c2 }, b0: Fp2, b1: Fp2): Fp6 {\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n      };\n    },\n  };\n\n  // Fp12\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    12,\n    1,\n    6\n  )[0];\n\n  const Fp12Add = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1),\n  });\n  const Fp12Subtract = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1),\n  });\n  const Fp12Multiply = ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n  };\n  const Fp12Square = ({ c0, c1 }: Fp12) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\n        Fp6.mulByNonresidue(ab)\n      ),\n      c1: Fp6.add(ab, ab),\n    }; // AB + AB\n  };\n  function Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n    };\n  }\n\n  const Fp12: Fp12Bls = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp6.isLE,\n    BITS: 2 * Fp6.BITS,\n    BYTES: 2 * Fp6.BYTES,\n    MASK: bitMask(2 * Fp6.BITS),\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n    isValidNot0: (num) => !Fp12.is0(num) && Fp12.isValid(num),\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: notImplemented,\n    inv: ({ c0, c1 }) => {\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n      return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) =>\n      Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp12 => {\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1 }): Uint8Array => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c),\n    }),\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t: BigintTwelve): Fp12 => ({\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power: number) {\n      const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: Fp6.frobeniusMap(lhs.c0, power),\n        c1: Fp6.create({\n          c0: Fp2.mul(c0, coeff),\n          c1: Fp2.mul(c1, coeff),\n          c2: Fp2.mul(c2, coeff),\n        }),\n      };\n    },\n    mulByFp2: ({ c0, c1 }, rhs: Fp2): Fp12 => ({\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs),\n    }),\n    conjugate: ({ c0, c1 }): Fp12 => ({ c0, c1: Fp6.neg(c1) }),\n    // Sparse multiplication\n    mul014: ({ c0, c1 }, o0: Fp2, o1: Fp2, o4: Fp2) => {\n      let t0 = Fp6.mul01(c0, o0, o1);\n      let t1 = Fp6.mul1(c1, o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n      };\n    },\n    mul034: ({ c0, c1 }, o0: Fp2, o3: Fp2, o4: Fp2) => {\n      const a = Fp6.create({\n        c0: Fp2.mul(c0.c0, o0),\n        c1: Fp2.mul(c0.c1, o0),\n        c2: Fp2.mul(c0.c2, o0),\n      });\n      const b = Fp6.mul01(c1, o3, o4);\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n        c1: Fp6.sub(e, Fp6.add(a, b)),\n      };\n    },\n\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: opts.Fp12finalExponentiate,\n  };\n\n  return { Fp, Fp2, Fp6, Fp12, Fp4Square };\n}\n", "/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n\n* Construct zk-SNARKs at the ~120-bit security, as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n* Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\nthe Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n\nBLS can mean 2 different things:\n\n* Barreto-Lynn-Scott: BLS12, a Pairing Friendly Elliptic Curve\n* Boneh-Lynn-Shacham: A Signature Scheme.\n\n### Summary\n\n1. BLS Relies on expensive bilinear pairing\n2. Secret Keys: 32 bytes\n3. Public Keys: 48 OR 96 bytes - big-endian x coordinate of point on G1 OR G2 curve\n4. Signatures: 96 OR 48 bytes - big-endian x coordinate of point on G2 OR G1 curve\n5. The 12 stands for the Embedding degree.\n\nModes of operation:\n\n* Long signatures:  48-byte keys + 96-byte sigs (G1 keys + G2 sigs).\n* Short signatures: 96-byte keys + 48-byte sigs (G2 keys + G1 sigs).\n\n### Formulas\n\n- `P = pk x G` - public keys\n- `S = pk x H(m)` - signing, uses hash-to-curve on m\n- `e(P, H(m)) == e(G, S)` - verification using pairings\n- `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n\n### Curves\n\nG1 is ordinary elliptic curve. G2 is extension field curve, think \"over complex numbers\".\n\n- G1: y² = x³ + 4\n- G2: y² = x³ + 4(u + 1) where u = √−1; r-order subgroup of E'(Fp²), M-type twist\n\n### Towers\n\nPairing G1 + G2 produces element in Fp₁₂, 12-degree polynomial.\nFp₁₂ is usually implemented using tower of lower-degree polynomials for speed.\n\n- Fp₁₂ = Fp₆² => Fp₂³\n- Fp(u) / (u² - β) where β = -1\n- Fp₂(v) / (v³ - ξ) where ξ = u + 1\n- Fp₆(w) / (w² - γ) where γ = v\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-1-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n### Params\n\n* Embedding degree (k): 12\n* Seed is sometimes named x or t\n* t = -15132376222941642752\n* p = (t-1)² * (t⁴-t²+1)/3 + t\n* r = t⁴-t²+1\n* Ate loop size: X\n\nTo verify curve parameters, see\n[pairing-friendly-curves spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11).\nBasic math is done over finite fields over p.\nMore complicated math is done over polynominal extension fields.\n\n### Compatibility and notes\n1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\nFilecoin uses little endian byte arrays for secret keys - make sure to reverse byte order.\n2. Make sure to correctly select mode: \"long signature\" or \"short signature\".\n3. Compatible with specs:\n   RFC 9380,\n   [cfrg-pairing-friendly-curves-11](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n   [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/).\n\n *\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { bls, type CurveFn } from './abstract/bls.ts';\nimport { Field, type IField } from './abstract/modular.ts';\nimport {\n  abytes,\n  bitGet,\n  bitLen,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  numberToBytesBE,\n  type Hex,\n} from './utils.ts';\n// Types\nimport { isogenyMap } from './abstract/hash-to-curve.ts';\nimport type { BigintTuple, Fp, Fp12, Fp2, Fp6 } from './abstract/tower.ts';\nimport { psiFrobenius, tower12 } from './abstract/tower.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type AffinePoint,\n  type WeierstrassOpts,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n// To verify math:\n// https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11\n\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\n// x = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nconst BLS_X = BigInt('0xd201000000010000');\n// t = x (called differently in different places)\n// const t = -BLS_X;\nconst BLS_X_LEN = bitLen(BLS_X);\n\n// a=0, b=4\n// P is characteristic of field Fp, in which curve calculations are done.\n// p = (t-1)² * (t⁴-t²+1)/3 + t\n// bls12_381_Fp = (t-1n)**2n * (t**4n - t**2n + 1n) / 3n + t\n// r*h is curve order, amount of points on curve,\n// where r is order of prime subgroup and h is cofactor.\n// r = t⁴-t²+1\n// r = (t**4n - t**2n + 1n)\n// cofactor h of G1: (t - 1)²/3\n// cofactorG1 = (t-1n)**2n/3n\n// x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n// y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\nconst bls12_381_CURVE_G1: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\n  ),\n  n: BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'),\n  h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n  a: _0n,\n  b: _4n,\n  Gx: BigInt(\n    '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\n  ),\n  Gy: BigInt(\n    '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\n  ),\n};\n\n// CURVE FIELDS\nexport const bls12_381_Fr: IField<bigint> = Field(bls12_381_CURVE_G1.n, { modOnDecode: true });\nconst { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({\n  // Order of Fp\n  ORDER: bls12_381_CURVE_G1.p,\n  // Finite extension field over irreducible polynominal.\n  // Fp(u) / (u² - β) where β = -1\n  FP2_NONRESIDUE: [_1n, _1n],\n  Fp2mulByB: ({ c0, c1 }) => {\n    const t0 = Fp.mul(c0, _4n); // 4 * c0\n    const t1 = Fp.mul(c1, _4n); // 4 * c1\n    // (T0-T1) + (T0+T1)*i\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n  },\n  // Fp12\n  // A cyclotomic group is a subgroup of Fp^n defined by\n  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n  // The result of any pairing is in a cyclotomic subgroup\n  // https://eprint.iacr.org/2009/565.pdf\n  Fp12cyclotomicSquare: ({ c0, c1 }): Fp12 => {\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n    const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n    return {\n      c0: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n      }), // 2 * (T7 - c0c2)  + T7\n      c1: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n      }),\n    }; // 2 * (T6 + c1c2) + T6\n  },\n  Fp12cyclotomicExp(num, n) {\n    let z = Fp12.ONE;\n    for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n      z = Fp12._cyclotomicSquare(z);\n      if (bitGet(n, i)) z = Fp12.mul(z, num);\n    }\n    return z;\n  },\n  // https://eprint.iacr.org/2010/354.pdf\n  // https://eprint.iacr.org/2009/565.pdf\n  Fp12finalExponentiate: (num) => {\n    const x = BLS_X;\n    // this^(q⁶) / this\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n    // t0^(q²) * t0\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n    // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n  },\n});\n\n// GLV endomorphism Ψ(P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n\n/**\n * Default hash_to_field / hash-to-curve for BLS.\n * m: 1 for G1, 2 for G2\n * k: target security level in bits\n * hash: any function, e.g. BBS+ uses BLAKE2: see [github](https://github.com/hyperledger/aries-framework-go/issues/2247).\n * Parameter values come from [section 8.8.2 of RFC 9380](https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2).\n */\nconst htfDefaults = Object.freeze({\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  p: Fp.ORDER,\n  m: 2,\n  k: 128,\n  expand: 'xmd',\n  hash: sha256,\n});\n\n// a=0, b=4\n// cofactor h of G2\n// (t^8 - 4t^7 + 5t^6 - 4t^4 + 6t^3 - 4t^2 - 4t + 13)/9\n// cofactorG2 = (t**8n - 4n*t**7n + 5n*t**6n - 4n*t**4n + 6n*t**3n - 4n*t**2n - 4n*t+13n)/9n\n// x = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758*u + 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n// y = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582*u + 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\nconst bls12_381_CURVE_G2 = {\n  p: Fp2.ORDER,\n  n: bls12_381_CURVE_G1.n,\n  h: BigInt(\n    '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\n  ),\n  a: Fp2.ZERO,\n  b: Fp2.fromBigTuple([_4n, _4n]),\n  Gx: Fp2.fromBigTuple([\n    BigInt(\n      '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\n    ),\n    BigInt(\n      '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\n    ),\n  ]),\n  Gy: Fp2.fromBigTuple([\n    BigInt(\n      '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\n    ),\n    BigInt(\n      '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\n    ),\n  ]),\n};\n\n// Encoding utils\n// Compressed point of infinity\n// Set compressed & point-at-infinity bits\nconst COMPZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true });\n\nfunction parseMask(bytes: Uint8Array) {\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n  bytes = bytes.slice();\n  const mask = bytes[0] & 0b1110_0000;\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\n  return { compressed, infinity, sort, value: bytes };\n}\n\nfunction setMask(\n  bytes: Uint8Array,\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\n) {\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\n  if (mask.sort) bytes[0] |= 0b0010_0000;\n  return bytes;\n}\n\nfunction pointG1ToBytes(\n  _c: WeierstrassPointCons<Fp>,\n  point: WeierstrassPoint<Fp>,\n  isComp: boolean\n) {\n  const { BYTES: L, ORDER: P } = Fp;\n  const is0 = point.is0();\n  const { x, y } = point.toAffine();\n  if (isComp) {\n    if (is0) return COMPZERO.slice();\n    const sort = Boolean((y * _2n) / P);\n    return setMask(numberToBytesBE(x, L), { compressed: true, sort });\n  } else {\n    if (is0) {\n      return concatBytes(Uint8Array.of(0x40), new Uint8Array(2 * L - 1));\n    } else {\n      return concatBytes(numberToBytesBE(x, L), numberToBytesBE(y, L));\n    }\n  }\n}\n\nfunction signatureG1ToBytes(point: WeierstrassPoint<Fp>) {\n  point.assertValidity();\n  const { BYTES: L, ORDER: P } = Fp;\n  const { x, y } = point.toAffine();\n  if (point.is0()) return COMPZERO.slice();\n  const sort = Boolean((y * _2n) / P);\n  return setMask(numberToBytesBE(x, L), { compressed: true, sort });\n}\n\nfunction pointG1FromBytes(bytes: Uint8Array): AffinePoint<Fp> {\n  const { compressed, infinity, sort, value } = parseMask(bytes);\n  const { BYTES: L, ORDER: P } = Fp;\n  if (value.length === 48 && compressed) {\n    const compressedValue = bytesToNumberBE(value);\n    // Zero\n    const x = Fp.create(compressedValue & Fp.MASK);\n    if (infinity) {\n      if (x !== _0n) throw new Error('invalid G1 point: non-empty, at infinity, with compression');\n      return { x: _0n, y: _0n };\n    }\n    const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n    let y = Fp.sqrt(right);\n    if (!y) throw new Error('invalid G1 point: compressed point');\n    if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\n    return { x: Fp.create(x), y: Fp.create(y) };\n  } else if (value.length === 96 && !compressed) {\n    // Check if the infinity flag is set\n    const x = bytesToNumberBE(value.subarray(0, L));\n    const y = bytesToNumberBE(value.subarray(L));\n    if (infinity) {\n      if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\n      return bls12_381.G1.Point.ZERO.toAffine();\n    }\n    return { x: Fp.create(x), y: Fp.create(y) };\n  } else {\n    throw new Error('invalid G1 point: expected 48/96 bytes');\n  }\n}\n\nfunction signatureG1FromBytes(hex: Hex): WeierstrassPoint<Fp> {\n  const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\n  const P = Fp.ORDER;\n  const Point = bls12_381.G1.Point;\n  const compressedValue = bytesToNumberBE(value);\n  // Zero\n  if (infinity) return Point.ZERO;\n  const x = Fp.create(compressedValue & Fp.MASK);\n  const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n  let y = Fp.sqrt(right);\n  if (!y) throw new Error('invalid G1 point: compressed');\n  const aflag = BigInt(sort);\n  if ((y * _2n) / P !== aflag) y = Fp.neg(y);\n  const point = Point.fromAffine({ x, y });\n  point.assertValidity();\n  return point;\n}\n\nfunction pointG2ToBytes(\n  _c: WeierstrassPointCons<Fp2>,\n  point: WeierstrassPoint<Fp2>,\n  isComp: boolean\n) {\n  const { BYTES: L, ORDER: P } = Fp;\n  const is0 = point.is0();\n  const { x, y } = point.toAffine();\n  if (isComp) {\n    if (is0) return concatBytes(COMPZERO, numberToBytesBE(_0n, L));\n    const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n    return concatBytes(\n      setMask(numberToBytesBE(x.c1, L), { compressed: true, sort: flag }),\n      numberToBytesBE(x.c0, L)\n    );\n  } else {\n    if (is0) return concatBytes(Uint8Array.of(0x40), new Uint8Array(4 * L - 1));\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    return concatBytes(\n      numberToBytesBE(x1, L),\n      numberToBytesBE(x0, L),\n      numberToBytesBE(y1, L),\n      numberToBytesBE(y0, L)\n    );\n  }\n}\n\nfunction signatureG2ToBytes(point: WeierstrassPoint<Fp2>) {\n  point.assertValidity();\n  const { BYTES: L } = Fp;\n  if (point.is0()) return concatBytes(COMPZERO, numberToBytesBE(_0n, L));\n  const { x, y } = point.toAffine();\n  const { re: x0, im: x1 } = Fp2.reim(x);\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\n  const z2 = x0;\n  return concatBytes(\n    setMask(numberToBytesBE(x1, L), { sort, compressed: true }),\n    numberToBytesBE(z2, L)\n  );\n}\n\nfunction pointG2FromBytes(bytes: Uint8Array): AffinePoint<Fp2> {\n  const { BYTES: L, ORDER: P } = Fp;\n  const { compressed, infinity, sort, value } = parseMask(bytes);\n  if (\n    (!compressed && !infinity && sort) || // 00100000\n    (!compressed && infinity && sort) || // 01100000\n    (sort && infinity && compressed) // 11100000\n  ) {\n    throw new Error('invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\n  }\n  const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\n  if (value.length === 96 && compressed) {\n    if (infinity) {\n      // check that all bytes are 0\n      if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n        throw new Error('invalid G2 point: compressed');\n      }\n      return { x: Fp2.ZERO, y: Fp2.ZERO };\n    }\n    const x_1 = slc(value, 0, L);\n    const x_0 = slc(value, L, 2 * L);\n    const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n    const right = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4 * (u+1) = x³ + b\n    let y = Fp2.sqrt(right);\n    const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n    y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n    return { x, y };\n  } else if (value.length === 192 && !compressed) {\n    if (infinity) {\n      if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n        throw new Error('invalid G2 point: uncompressed');\n      }\n      return { x: Fp2.ZERO, y: Fp2.ZERO };\n    }\n    const x1 = slc(value, 0 * L, 1 * L);\n    const x0 = slc(value, 1 * L, 2 * L);\n    const y1 = slc(value, 2 * L, 3 * L);\n    const y0 = slc(value, 3 * L, 4 * L);\n    return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n  } else {\n    throw new Error('invalid G2 point: expected 96/192 bytes');\n  }\n}\n\nfunction signatureG2FromBytes(hex: Hex) {\n  const { ORDER: P } = Fp;\n  // TODO: Optimize, it's very slow because of sqrt.\n  const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\n  const Point = bls12_381.G2.Point;\n  const half = value.length / 2;\n  if (half !== 48 && half !== 96)\n    throw new Error('invalid compressed signature length, expected 96/192 bytes');\n  const z1 = bytesToNumberBE(value.slice(0, half));\n  const z2 = bytesToNumberBE(value.slice(half));\n  // Indicates the infinity point\n  if (infinity) return Point.ZERO;\n  const x1 = Fp.create(z1 & Fp.MASK);\n  const x2 = Fp.create(z2);\n  const x = Fp2.create({ c0: x2, c1: x1 });\n  const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4\n  // The slow part\n  let y = Fp2.sqrt(y2);\n  if (!y) throw new Error('Failed to find a square root');\n\n  // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n  // If y1 happens to be zero, then use the bit of y0\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const aflag1 = BigInt(sort);\n  const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n  const is0 = y1 === _0n && (y0 * _2n) / P !== aflag1;\n  if (isGreater || is0) y = Fp2.neg(y);\n  const point = Point.fromAffine({ x, y });\n  point.assertValidity();\n  return point;\n}\n\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */\nexport const bls12_381: CurveFn = bls({\n  // Fields\n  fields: {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp12,\n    Fr: bls12_381_Fr,\n  },\n  // G1: y² = x³ + 4\n  G1: {\n    ...bls12_381_CURVE_G1,\n    Fp,\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    isTorsionFree: (c, point): boolean => {\n      // GLV endomorphism ψ(P)\n      const beta = BigInt(\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\n      );\n      const phi = new c(Fp.mul(point.X, beta), point.Y, point.Z);\n      // TODO: unroll\n      const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n      const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n      return u2P.equals(phi);\n    },\n    // Clear cofactor of G1\n    // https://eprint.iacr.org/2019/403\n    clearCofactor: (_c, point) => {\n      // return this.multiplyUnsafe(CURVE.h);\n      return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n    },\n    mapToCurve: mapToG1,\n    fromBytes: pointG1FromBytes,\n    toBytes: pointG1ToBytes,\n    ShortSignature: {\n      fromBytes(bytes: Uint8Array) {\n        abytes(bytes);\n        return signatureG1FromBytes(bytes);\n      },\n      fromHex(hex: Hex): WeierstrassPoint<Fp> {\n        return signatureG1FromBytes(hex);\n      },\n      toBytes(point: WeierstrassPoint<Fp>) {\n        return signatureG1ToBytes(point);\n      },\n      toRawBytes(point: WeierstrassPoint<Fp>) {\n        return signatureG1ToBytes(point);\n      },\n      toHex(point: WeierstrassPoint<Fp>) {\n        return bytesToHex(signatureG1ToBytes(point));\n      },\n    },\n  },\n  G2: {\n    ...bls12_381_CURVE_G2,\n    Fp: Fp2,\n    // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor\n    // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12\n    hEff: BigInt(\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\n    ),\n    htfDefaults: { ...htfDefaults },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: mapToG2,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    // Older version: https://eprint.iacr.org/2019/814.pdf\n    isTorsionFree: (c, P): boolean => {\n      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n    },\n    // Maps the point into the prime-order subgroup G2.\n    // clear_cofactor_bls12381_g2 from RFC 9380.\n    // https://eprint.iacr.org/2017/419.pdf\n    // prettier-ignore\n    clearCofactor: (c, P) => {\n      const x = BLS_X;\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\n      let t2 = G2psi(c, P);                   // Ψ(P)\n      let t3 = P.double();                    // 2P\n      t3 = G2psi2(c, t3);                     // Ψ²(2P)\n      t3 = t3.subtract(t2);                   // Ψ²(2P) - Ψ(P)\n      t2 = t1.add(t2);                        // [-x]P + Ψ(P)\n      t2 = t2.multiplyUnsafe(x).negate();     // [x²]P - [x]Ψ(P)\n      t3 = t3.add(t2);                        // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n      t3 = t3.subtract(t1);                   // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n      const Q = t3.subtract(P);               // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n      return Q;                               // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n    },\n    fromBytes: pointG2FromBytes,\n    toBytes: pointG2ToBytes,\n    Signature: {\n      fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp2> {\n        abytes(bytes);\n        return signatureG2FromBytes(bytes);\n      },\n      fromHex(hex: Hex): WeierstrassPoint<Fp2> {\n        return signatureG2FromBytes(hex);\n      },\n      toBytes(point: WeierstrassPoint<Fp2>) {\n        return signatureG2ToBytes(point);\n      },\n      toRawBytes(point: WeierstrassPoint<Fp2>) {\n        return signatureG2ToBytes(point);\n      },\n      toHex(point: WeierstrassPoint<Fp2>) {\n        return bytesToHex(signatureG2ToBytes(point));\n      },\n    },\n  },\n  params: {\n    ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n    r: bls12_381_CURVE_G1.n, // order; z⁴ − z² + 1; CURVE.n from other curves\n    xNegative: true,\n    twistType: 'multiplicative',\n  },\n  htfDefaults,\n  hash: sha256,\n});\n\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = isogenyMap(\n  Fp2,\n  [\n    // xNum\n    [\n      [\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n      ],\n      [\n        '0x0',\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n      ],\n      [\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n        '0x0',\n      ],\n    ],\n    // xDen\n    [\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n      ],\n      [\n        '0xc',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n      [\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n      ],\n      [\n        '0x0',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n      ],\n      [\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n        '0x0',\n      ],\n    ],\n    // yDen\n    [\n      [\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n      ],\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n      ],\n      [\n        '0x12',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt) as BigintTuple))) as [\n    Fp2[],\n    Fp2[],\n    Fp2[],\n    Fp2[],\n  ]\n);\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = isogenyMap(\n  Fp,\n  [\n    // xNum\n    [\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\n);\n\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\n  A: Fp.create(\n    BigInt(\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\n    )\n  ),\n  B: Fp.create(\n    BigInt(\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\n    )\n  ),\n  Z: Fp.create(BigInt(11)),\n});\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n\nfunction mapToG1(scalars: bigint[]) {\n  const { x, y } = G1_SWU(Fp.create(scalars[0]));\n  return isogenyMapG1(x, y);\n}\nfunction mapToG2(scalars: bigint[]) {\n  const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars as BigintTuple));\n  return isogenyMapG2(x, y);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Fp2, Fp12 } from '@noble/curves/abstract/tower';\nimport type { WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { bls12_381 } from '@noble/curves/bls12-381';\nimport { bytesToNumberBE, bytesToNumberLE, numberToBytesBE } from '@noble/curves/utils';\n\nexport class G1Element {\n\tpoint: WeierstrassPoint<bigint>;\n\n\tpublic static readonly SIZE = 48;\n\n\tconstructor(point: WeierstrassPoint<bigint>) {\n\t\tthis.point = point;\n\t}\n\n\tstatic generator(): G1Element {\n\t\treturn new G1Element(bls12_381.G1.Point.BASE);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): G1Element {\n\t\ttry {\n\t\t\treturn new G1Element(bls12_381.G1.Point.fromBytes(bytes));\n\t\t} catch {\n\t\t\tthrow new Error('Invalid G1 point');\n\t\t}\n\t}\n\n\ttoBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn this.point.toBytes() as Uint8Array<ArrayBuffer>;\n\t}\n\n\tmultiply(scalar: Scalar): G1Element {\n\t\treturn new G1Element(this.point.multiply(scalar.scalar));\n\t}\n\n\tadd(other: G1Element): G1Element {\n\t\treturn new G1Element(this.point.add(other.point));\n\t}\n\n\tsubtract(other: G1Element): G1Element {\n\t\treturn new G1Element(this.point.subtract(other.point));\n\t}\n\n\tstatic hashToCurve(data: Uint8Array): G1Element {\n\t\treturn new G1Element(bls12_381.G1.Point.fromAffine(bls12_381.G1.hashToCurve(data).toAffine()));\n\t}\n\n\tpairing(other: G2Element): GTElement {\n\t\treturn new GTElement(bls12_381.pairing(this.point, other.point));\n\t}\n}\n\nexport class G2Element {\n\tpoint: WeierstrassPoint<Fp2>;\n\n\tpublic static readonly SIZE = 96;\n\n\tconstructor(point: WeierstrassPoint<Fp2>) {\n\t\tthis.point = point;\n\t}\n\n\tstatic generator(): G2Element {\n\t\treturn new G2Element(bls12_381.G2.Point.BASE);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): G2Element {\n\t\ttry {\n\t\t\treturn new G2Element(bls12_381.G2.Point.fromBytes(bytes));\n\t\t} catch {\n\t\t\tthrow new Error('Invalid G2 point');\n\t\t}\n\t}\n\n\ttoBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn this.point.toBytes() as Uint8Array<ArrayBuffer>;\n\t}\n\n\tmultiply(scalar: Scalar): G2Element {\n\t\treturn new G2Element(this.point.multiply(scalar.scalar));\n\t}\n\n\tadd(other: G2Element): G2Element {\n\t\treturn new G2Element(this.point.add(other.point));\n\t}\n\n\tstatic hashToCurve(data: Uint8Array): G2Element {\n\t\treturn new G2Element(bls12_381.G2.Point.fromAffine(bls12_381.G2.hashToCurve(data).toAffine()));\n\t}\n\n\tequals(other: G2Element): boolean {\n\t\treturn this.point.equals(other.point);\n\t}\n}\n\nexport class GTElement {\n\telement: Fp12;\n\n\tpublic static readonly SIZE = 576;\n\n\tconstructor(element: Fp12) {\n\t\tthis.element = element;\n\t}\n\n\ttoBytes(): Uint8Array<ArrayBuffer> {\n\t\t// This permutation reorders the 6 pairs of coefficients of the GT element for compatability with the Rust and Move implementations.\n\t\t//\n\t\t// The permutation P may be computed as:\n\t\t// for i in 0..3 {\n\t\t//   for j in 0..2 {\n\t\t//     P[2 * i + j] = i + 3 * j;\n\t\t//   }\n\t\t// }\n\t\tconst P = [0, 3, 1, 4, 2, 5];\n\t\tconst PAIR_SIZE = GTElement.SIZE / P.length;\n\n\t\tconst bytes = bls12_381.fields.Fp12.toBytes(this.element);\n\t\tconst result = new Uint8Array(GTElement.SIZE);\n\n\t\tfor (let i = 0; i < P.length; i++) {\n\t\t\tconst sourceStart = P[i] * PAIR_SIZE;\n\t\t\tconst sourceEnd = sourceStart + PAIR_SIZE;\n\t\t\tconst targetStart = i * PAIR_SIZE;\n\t\t\tresult.set(bytes.subarray(sourceStart, sourceEnd), targetStart);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tequals(other: GTElement): boolean {\n\t\treturn bls12_381.fields.Fp12.eql(this.element, other.element);\n\t}\n}\n\nexport class Scalar {\n\tscalar: bigint;\n\n\tpublic static readonly SIZE = 32;\n\n\tconstructor(scalar: bigint) {\n\t\tthis.scalar = scalar;\n\t}\n\n\tstatic fromBigint(scalar: bigint): Scalar {\n\t\tif (scalar < 0n || scalar >= bls12_381.fields.Fr.ORDER) {\n\t\t\tthrow new Error('Scalar out of range');\n\t\t}\n\t\treturn new Scalar(scalar);\n\t}\n\n\tstatic random(): Scalar {\n\t\tconst randomSecretKey = bls12_381.utils.randomSecretKey();\n\t\treturn Scalar.fromBytes(randomSecretKey)!;\n\t}\n\n\ttoBytes(): Uint8Array {\n\t\treturn numberToBytesBE(this.scalar, Scalar.SIZE);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): Scalar {\n\t\tif (bytes.length !== Scalar.SIZE) {\n\t\t\tthrow new Error('Invalid scalar length');\n\t\t}\n\t\treturn this.fromBigint(bytesToNumberBE(bytes));\n\t}\n\n\tstatic fromBytesLE(bytes: Uint8Array): Scalar {\n\t\tif (bytes.length !== Scalar.SIZE) {\n\t\t\tthrow new Error('Invalid scalar length');\n\t\t}\n\t\treturn this.fromBigint(bytesToNumberLE(bytes));\n\t}\n}\n", "/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class SealError extends Error {}\n\nexport class UserError extends SealError {}\n\n// Errors returned by the Seal server\nexport class SealAPIError extends SealError {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic requestId?: string,\n\t\tpublic status?: number,\n\t) {\n\t\tsuper(message);\n\t}\n\n\tstatic #generate(error: string, message: string, requestId: string, status?: number) {\n\t\tswitch (error) {\n\t\t\tcase 'InvalidPTB':\n\t\t\t\treturn new InvalidPTBError(requestId, message);\n\t\t\tcase 'InvalidPackage':\n\t\t\t\treturn new InvalidPackageError(requestId);\n\t\t\tcase 'NoAccess':\n\t\t\t\treturn new NoAccessError(requestId);\n\t\t\tcase 'InvalidSignature':\n\t\t\t\treturn new InvalidUserSignatureError(requestId);\n\t\t\tcase 'InvalidSessionSignature':\n\t\t\t\treturn new InvalidSessionKeySignatureError(requestId);\n\t\t\tcase 'InvalidCertificate':\n\t\t\t\treturn new ExpiredSessionKeyError(requestId);\n\t\t\tcase 'InvalidSDKVersion':\n\t\t\t\treturn new InvalidSDKVersionError(requestId);\n\t\t\tcase 'DeprecatedSDKVersion':\n\t\t\t\treturn new DeprecatedSDKVersionError(requestId);\n\t\t\tcase 'InvalidParameter':\n\t\t\t\treturn new InvalidParameterError(requestId);\n\t\t\tcase 'InvalidMVRName':\n\t\t\t\treturn new InvalidMVRNameError(requestId);\n\t\t\tcase 'InvalidServiceId':\n\t\t\t\treturn new InvalidKeyServerObjectIdError(requestId);\n\t\t\tcase 'UnsupportedPackageId':\n\t\t\t\treturn new UnsupportedPackageIdError(requestId);\n\t\t\tcase 'Failure':\n\t\t\t\treturn new InternalError(requestId);\n\t\t\tdefault:\n\t\t\t\treturn new GeneralError(message, requestId, status);\n\t\t}\n\t}\n\n\tstatic async assertResponse(response: Response, requestId: string) {\n\t\tif (response.ok) {\n\t\t\treturn;\n\t\t}\n\t\tlet errorInstance: SealAPIError;\n\t\ttry {\n\t\t\tconst text = await response.text();\n\t\t\tconst error = JSON.parse(text)['error'];\n\t\t\tconst message = JSON.parse(text)['message'];\n\t\t\terrorInstance = SealAPIError.#generate(error, message, requestId);\n\t\t} catch {\n\t\t\t// If we can't parse the response as JSON or if it doesn't have the expected format,\n\t\t\t// fall back to using the status text\n\t\t\terrorInstance = new GeneralError(response.statusText, requestId, response.status);\n\t\t}\n\t\tthrow errorInstance;\n\t}\n}\n\n// Errors returned by the Seal server that indicate that the PTB is invalid\n\nexport class InvalidPTBError extends SealAPIError {\n\tconstructor(requestId?: string, message?: string) {\n\t\tsuper('PTB does not conform to the expected format ' + message, requestId);\n\t}\n}\n\nexport class InvalidPackageError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Package ID used in PTB is invalid', requestId);\n\t}\n}\n\nexport class InvalidParameterError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper(\n\t\t\t'PTB contains an invalid parameter, possibly a newly created object that the FN has not yet seen',\n\t\t\trequestId,\n\t\t);\n\t}\n}\n\n// Errors returned by the Seal server that indicate that the user's signature is invalid\n\nexport class InvalidUserSignatureError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('User signature on the session key is invalid', requestId);\n\t}\n}\n\nexport class InvalidSessionKeySignatureError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Session key signature is invalid', requestId);\n\t}\n}\n\nexport class InvalidMVRNameError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('MVR name is invalid or not consistent with the first version of the package', requestId);\n\t}\n}\n\n/** Server error indicating that the requested key server object id is invalid */\nexport class InvalidKeyServerObjectIdError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Key server object ID is invalid', requestId);\n\t}\n}\n\n/** Server error indicating that the requested package id is not supported (i.e., key server is running in Permissioned mode) */\nexport class UnsupportedPackageIdError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Requested package is not supported', requestId);\n\t}\n}\n\n// Errors returned by the Seal server that indicate that the SDK version is invalid (implying that HTTP headers used by the SDK are being removed) or deprecated (implying that the SDK should be upgraded).\n\nexport class InvalidSDKVersionError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('SDK version is invalid', requestId);\n\t}\n}\n\nexport class DeprecatedSDKVersionError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('SDK version is deprecated', requestId);\n\t}\n}\n\n/** Server error indicating that the user does not have access to one or more of the requested keys */\nexport class NoAccessError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('User does not have access to one or more of the requested keys', requestId);\n\t}\n}\n\n/** Server error indicating that the session key has expired */\nexport class ExpiredSessionKeyError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Session key has expired', requestId);\n\t}\n}\n\n/** Internal server error, caller should retry */\nexport class InternalError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Internal server error, caller should retry', requestId);\n\t}\n}\n\n/** General server errors that are not specific to the Seal API (e.g., 404 \"Not Found\") */\nexport class GeneralError extends SealAPIError {}\n\n// Errors returned by the SDK\nexport class InvalidPersonalMessageSignatureError extends UserError {}\nexport class InvalidGetObjectError extends UserError {}\nexport class UnsupportedFeatureError extends UserError {}\nexport class UnsupportedNetworkError extends UserError {}\nexport class InvalidKeyServerError extends UserError {}\nexport class InvalidKeyServerVersionError extends UserError {}\nexport class InvalidCiphertextError extends UserError {}\nexport class InvalidThresholdError extends UserError {}\nexport class InconsistentKeyServersError extends UserError {}\nexport class DecryptionError extends UserError {}\nexport class InvalidClientOptionsError extends UserError {}\nexport class TooManyFailedFetchKeyRequestsError extends UserError {}\n\nexport function toMajorityError(errors: Error[]): Error {\n\tlet maxCount = 0;\n\tlet majorityError = errors[0];\n\tconst counts = new Map<string, number>();\n\tfor (const error of errors) {\n\t\tconst errorName = error.constructor.name;\n\t\tconst newCount = (counts.get(errorName) || 0) + 1;\n\t\tcounts.set(errorName, newCount);\n\n\t\tif (newCount > maxCount) {\n\t\t\tmaxCount = newCount;\n\t\t\tmajorityError = error;\n\t\t}\n\t}\n\n\treturn majorityError;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex, toHex } from '@mysten/bcs';\nimport { isValidSuiObjectId } from '@mysten/sui/utils';\n\nimport { UserError } from './error.js';\n\n/** Maximum value for a u8 (unsigned 8-bit integer). */\nexport const MAX_U8 = 255;\n\nexport function xor(a: Uint8Array, b: Uint8Array): Uint8Array {\n\tif (a.length !== b.length) {\n\t\tthrow new Error('Invalid input');\n\t}\n\treturn xorUnchecked(a, b);\n}\n\nexport function xorUnchecked(a: Uint8Array, b: Uint8Array): Uint8Array {\n\treturn a.map((ai, i) => ai ^ b[i]);\n}\n\n/**\n * Create a full ID concatenating package ID || inner ID.\n * @param packageId - The package ID.\n * @param innerId - The inner ID.\n * @returns The full ID.\n */\nexport function createFullId(packageId: string, innerId: string): string {\n\tif (!isValidSuiObjectId(packageId)) {\n\t\tthrow new UserError(`Invalid package ID ${packageId}`);\n\t}\n\tconst fullId = flatten([fromHex(packageId), fromHex(innerId)]);\n\treturn toHex(fullId);\n}\n\n/**\n * Flatten an array of Uint8Arrays into a single Uint8Array.\n *\n * @param arrays - An array of Uint8Arrays to flatten.\n * @returns A single Uint8Array containing all the elements of the input arrays in the given order.\n */\nexport function flatten(arrays: Uint8Array[]): Uint8Array {\n\tconst length = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\tconst result = new Uint8Array(length);\n\tarrays.reduce((offset, array) => {\n\t\tresult.set(array, offset);\n\t\treturn offset + array.length;\n\t}, 0);\n\treturn result;\n}\n\n/** Count the number of occurrences of a value in an array. */\nexport function count<T>(array: T[], value: T): number {\n\treturn array.reduce((count, item) => (item === value ? count + 1 : count), 0);\n}\n\n/** Check if the array has any duplicate elements. */\nexport function hasDuplicates(array: number[]): boolean {\n\treturn new Set(array).size !== array.length;\n}\n\n/** Check if all elements in the array are equal. */\nexport function allEqual(array: number[]): boolean {\n\tif (array.length === 0) {\n\t\treturn true;\n\t}\n\treturn array.every((item) => item === array[0]);\n}\n\n/**\n * Check if two Uint8Arrays are equal.\n * @param a - The first Uint8Array.\n * @param b - The second Uint8Array.\n * @returns True if the two Uint8Arrays are equal, false otherwise.\n */\nexport function equals(a: Uint8Array, b: Uint8Array): boolean {\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\treturn a.every((ai, i) => ai === b[i]);\n}\n\n/**\n * A simple class to represent a version number of the form x.y.z.\n */\nexport class Version {\n\tmajor: number;\n\tminor: number;\n\tpatch: number;\n\n\tconstructor(version: string) {\n\t\t// Very basic version parsing. Assumes version is in the format x.y.z where x, y, and z are non-negative integers.\n\t\tconst parts = version.split('.').map(Number);\n\t\tif (\n\t\t\tparts.length !== 3 ||\n\t\t\tparts.some((part) => isNaN(part) || !Number.isInteger(part) || part < 0)\n\t\t) {\n\t\t\tthrow new UserError(`Invalid version format: ${version}`);\n\t\t}\n\t\tthis.major = parts[0];\n\t\tthis.minor = parts[1];\n\t\tthis.patch = parts[2];\n\t}\n\n\t// Compare this version with another version. True if this version is older than the other version.\n\tolder_than(other: Version): boolean {\n\t\tif (this.major !== other.major) {\n\t\t\treturn this.major < other.major;\n\t\t} else if (this.minor !== other.minor) {\n\t\t\treturn this.minor < other.minor;\n\t\t}\n\t\treturn this.patch < other.patch;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport { equalBytes } from '@noble/curves/abstract/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\nimport type { Ciphertext } from './bcs.js';\nimport { DecryptionError, InvalidCiphertextError } from './error.js';\nimport { flatten, xorUnchecked } from './utils.js';\n\n// Use a fixed IV for AES. This is okay because the key is unique for each message.\nexport const iv = Uint8Array.from([\n\t138, 55, 153, 253, 198, 46, 121, 219, 160, 128, 89, 7, 214, 156, 148, 220,\n]);\n\nasync function generateAesKey(): Promise<Uint8Array<ArrayBuffer>> {\n\tconst key = await crypto.subtle.generateKey(\n\t\t{\n\t\t\tname: 'AES-GCM',\n\t\t\tlength: 256,\n\t\t},\n\t\ttrue,\n\t\t['encrypt', 'decrypt'],\n\t);\n\treturn await crypto.subtle.exportKey('raw', key).then((keyData) => new Uint8Array(keyData));\n}\n\nexport interface EncryptionInput {\n\tencrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput>;\n\tgenerateKey(): Promise<Uint8Array<ArrayBuffer>>;\n}\n\nexport class AesGcm256 implements EncryptionInput {\n\treadonly plaintext: Uint8Array<ArrayBuffer>;\n\treadonly aad: Uint8Array<ArrayBuffer>;\n\n\tconstructor(msg: Uint8Array<ArrayBuffer>, aad: Uint8Array<ArrayBuffer>) {\n\t\tthis.plaintext = msg;\n\t\tthis.aad = aad;\n\t}\n\n\tgenerateKey(): Promise<Uint8Array<ArrayBuffer>> {\n\t\t// generate a random key\n\t\treturn generateAesKey();\n\t}\n\n\tasync encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput> {\n\t\tif (key.length !== 32) {\n\t\t\tthrow new Error('Key must be 32 bytes');\n\t\t}\n\t\tconst aesCryptoKey = await crypto.subtle.importKey(\n\t\t\t'raw',\n\t\t\tkey as BufferSource,\n\t\t\t'AES-GCM',\n\t\t\tfalse,\n\t\t\t['encrypt'],\n\t\t);\n\n\t\tconst blob = new Uint8Array(\n\t\t\tawait crypto.subtle.encrypt(\n\t\t\t\t{\n\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\tiv,\n\t\t\t\t\tadditionalData: this.aad as BufferSource,\n\t\t\t\t},\n\t\t\t\taesCryptoKey,\n\t\t\t\tthis.plaintext as BufferSource,\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tAes256Gcm: {\n\t\t\t\tblob,\n\t\t\t\taad: this.aad ?? [],\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async decrypt(\n\t\tkey: Uint8Array,\n\t\tciphertext: typeof Ciphertext.$inferInput,\n\t): Promise<Uint8Array> {\n\t\tif (!('Aes256Gcm' in ciphertext)) {\n\t\t\tthrow new InvalidCiphertextError(`Invalid ciphertext ${JSON.stringify(ciphertext)}`);\n\t\t}\n\t\tif (key.length !== 32) {\n\t\t\tthrow new Error('Key must be 32 bytes');\n\t\t}\n\n\t\ttry {\n\t\t\tconst aesCryptoKey = await crypto.subtle.importKey(\n\t\t\t\t'raw',\n\t\t\t\tkey as BufferSource,\n\t\t\t\t'AES-GCM',\n\t\t\t\tfalse,\n\t\t\t\t['decrypt'],\n\t\t\t);\n\t\t\treturn new Uint8Array(\n\t\t\t\tawait crypto.subtle.decrypt(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\t\tiv,\n\t\t\t\t\t\tadditionalData: new Uint8Array(ciphertext.Aes256Gcm.aad ?? []),\n\t\t\t\t\t},\n\t\t\t\t\taesCryptoKey,\n\t\t\t\t\tnew Uint8Array(ciphertext.Aes256Gcm.blob),\n\t\t\t\t),\n\t\t\t);\n\t\t} catch {\n\t\t\tthrow new DecryptionError(`Decryption failed`);\n\t\t}\n\t}\n}\n\n/**\n * Authenticated encryption using CTR mode with HMAC-SHA3-256 as a PRF.\n * 1. Derive an encryption key, <i>k<sub>1</sub> = <b>hmac</b>(key, 1)</i>.\n * 2. Chunk the message into blocks of 32 bytes, <i>m = m<sub>1</sub> || ... || m<sub>n</sub></i>.\n * 3. Let the ciphertext be defined by <i>c = c<sub>1</sub> || ... || c<sub>n</sub></i> where <i>c<sub>i</sub> = m<sub>i</sub> \u2295 <b>hmac</b>(k<sub>1</sub>, i)</i>.\n * 4. Compute a MAC over the AAD and the ciphertext, <i>mac = <b>hmac</b>(k<sub>2</sub>, aad || c) where k<sub>2</sub> = <b>hmac</b>(key, 2)</i>.\n * 5. Return <i>mac || aad || c</i>.\n */\nexport class Hmac256Ctr implements EncryptionInput {\n\treadonly plaintext: Uint8Array<ArrayBuffer>;\n\treadonly aad: Uint8Array<ArrayBuffer>;\n\n\tconstructor(msg: Uint8Array<ArrayBuffer>, aad: Uint8Array<ArrayBuffer>) {\n\t\tthis.plaintext = msg;\n\t\tthis.aad = aad;\n\t}\n\n\tgenerateKey(): Promise<Uint8Array<ArrayBuffer>> {\n\t\t// generate a random key\n\t\treturn generateAesKey();\n\t}\n\n\tasync encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput> {\n\t\tconst blob = Hmac256Ctr.encryptInCtrMode(key, this.plaintext);\n\t\tconst mac = Hmac256Ctr.computeMac(key, this.aad, blob);\n\t\treturn {\n\t\t\tHmac256Ctr: {\n\t\t\t\tblob,\n\t\t\t\tmac,\n\t\t\t\taad: this.aad ?? [],\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async decrypt(\n\t\tkey: Uint8Array,\n\t\tciphertext: typeof Ciphertext.$inferInput,\n\t): Promise<Uint8Array> {\n\t\tif (!('Hmac256Ctr' in ciphertext)) {\n\t\t\tthrow new InvalidCiphertextError(`Invalid ciphertext ${JSON.stringify(ciphertext)}`);\n\t\t}\n\t\tif (key.length !== 32) {\n\t\t\tthrow new Error('Key must be 32 bytes');\n\t\t}\n\t\tconst aad = new Uint8Array(ciphertext.Hmac256Ctr.aad ?? []);\n\t\tconst blob = new Uint8Array(ciphertext.Hmac256Ctr.blob);\n\t\tconst mac = Hmac256Ctr.computeMac(key, aad, blob);\n\t\tif (!equalBytes(mac, new Uint8Array(ciphertext.Hmac256Ctr.mac))) {\n\t\t\tthrow new DecryptionError(`Invalid MAC ${mac}`);\n\t\t}\n\t\treturn Hmac256Ctr.encryptInCtrMode(key, blob);\n\t}\n\n\tprivate static computeMac(key: Uint8Array, aad: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n\t\tconst macInput = flatten([MacKeyTag, toBytes(aad.length), aad, ciphertext]);\n\t\tconst mac = hmac(sha3_256, key, macInput);\n\t\treturn mac;\n\t}\n\n\tprivate static encryptInCtrMode(key: Uint8Array, msg: Uint8Array): Uint8Array {\n\t\tconst blockSize = 32;\n\t\tconst result = new Uint8Array(msg.length);\n\t\tfor (let i = 0; i * blockSize < msg.length; i++) {\n\t\t\tconst block = msg.subarray(i * blockSize, (i + 1) * blockSize);\n\t\t\tconst mask = hmac(sha3_256, key, flatten([EncryptionKeyTag, toBytes(i)]));\n\t\t\tconst encryptedBlock = xorUnchecked(block, mask);\n\t\t\tresult.set(encryptedBlock, i * blockSize);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Convert a u64 to bytes using little-endian representation.\n */\nfunction toBytes(n: number): Uint8Array {\n\treturn bcs.u64().serialize(n).toBytes();\n}\n\nconst EncryptionKeyTag = new TextEncoder().encode('HMAC-CTR-ENC');\nconst MacKeyTag = new TextEncoder().encode('HMAC-CTR-MAC');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\nimport { G1Element } from './bls12381.js';\nimport type { G2Element, GTElement } from './bls12381.js';\nimport { flatten, MAX_U8 } from './utils.js';\n\n/**\n * The domain separation tag for the hash-to-group function.\n */\nconst DST: Uint8Array = new TextEncoder().encode('SUI-SEAL-IBE-BLS12381-00');\nconst KDF_DST = new TextEncoder().encode('SUI-SEAL-IBE-BLS12381-H2-00');\nconst DERIVE_KEY_DST = new TextEncoder().encode('SUI-SEAL-IBE-BLS12381-H3-00');\n\n/**\n * Hash an id to a G1Element.\n *\n * @param id The id to hash.\n * @returns The G1Element.\n */\nexport function hashToG1(id: Uint8Array): G1Element {\n\treturn G1Element.hashToCurve(flatten([DST, id]));\n}\n\n/**\n * The default key derivation function.\n *\n * @returns The derived key.\n */\nexport function kdf(\n\telement: GTElement,\n\tnonce: G2Element,\n\tid: Uint8Array,\n\tobjectId: string,\n\tindex: number,\n): Uint8Array {\n\tif (index < 0 || index > MAX_U8) {\n\t\tthrow new Error(`Invalid index ${index}`);\n\t}\n\tconst hash = sha3_256.create();\n\thash.update(KDF_DST);\n\thash.update(element.toBytes());\n\thash.update(nonce.toBytes());\n\thash.update(hashToG1(id).toBytes());\n\thash.update(fromHex(objectId));\n\thash.update(new Uint8Array([index])); // this is safe because index < 256.\n\treturn hash.digest();\n}\n\nexport enum KeyPurpose {\n\tEncryptedRandomness,\n\tDEM,\n}\n\nfunction tag(purpose: KeyPurpose): Uint8Array {\n\tswitch (purpose) {\n\t\tcase KeyPurpose.EncryptedRandomness:\n\t\t\treturn new Uint8Array([0]);\n\t\tcase KeyPurpose.DEM:\n\t\t\treturn new Uint8Array([1]);\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid key purpose ${purpose}`);\n\t}\n}\n\n/**\n * Derive a key from a base key and a list of encrypted shares.\n *\n * @param purpose The purpose of the key.\n * @param baseKey The base key.\n * @param encryptedShares The encrypted shares.\n * @param threshold The threshold.\n * @param keyServers The object ids of the key servers.\n * @returns The derived key.\n */\nexport function deriveKey(\n\tpurpose: KeyPurpose,\n\tbaseKey: Uint8Array,\n\tencryptedShares: Uint8Array[],\n\tthreshold: number,\n\tkeyServers: string[],\n): Uint8Array<ArrayBuffer> {\n\tif (threshold <= 0 || threshold > MAX_U8) {\n\t\tthrow new Error(`Invalid threshold ${threshold}`);\n\t}\n\tconst hash = sha3_256.create();\n\thash.update(DERIVE_KEY_DST);\n\thash.update(baseKey);\n\thash.update(tag(purpose));\n\thash.update(new Uint8Array([threshold]));\n\tencryptedShares.forEach((share) => hash.update(share));\n\tkeyServers.forEach((keyServer) => hash.update(fromHex(keyServer)));\n\treturn hash.digest() as Uint8Array<ArrayBuffer>;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\n\nimport type { IBEEncryptions } from './bcs.js';\nimport type { G1Element, GTElement } from './bls12381.js';\nimport { G2Element, Scalar } from './bls12381.js';\nimport { deriveKey, hashToG1, kdf, KeyPurpose } from './kdf.js';\nimport type { KeyServer } from './key-server.js';\nimport { xor } from './utils.js';\nimport type { Share } from './shamir.js';\nimport { InvalidCiphertextError } from './error.js';\n\n/**\n * The domain separation tag for the signing proof of possession.\n */\nexport const DST_POP: Uint8Array = new TextEncoder().encode('SUI-SEAL-IBE-BLS12381-POP-00');\n\n/**\n * The interface for the key servers.\n */\nexport abstract class IBEServers {\n\tobjectIds: string[];\n\n\tconstructor(objectIds: string[]) {\n\t\tthis.objectIds = objectIds;\n\t}\n\n\t/**\n\t * Encrypt a batch of messages for the given identity.\n\t *\n\t * @param id The identity.\n\t * @param msgAndIndices The messages and the corresponding indices of the share being encrypted.\n\t * @returns The encrypted messages.\n\t */\n\tabstract encryptBatched(\n\t\tid: Uint8Array,\n\t\tshares: Share[],\n\t\tbaseKey: Uint8Array,\n\t\tthreshold: number,\n\t): typeof IBEEncryptions.$inferType;\n}\n\n/**\n * Identity-based encryption based on the Boneh-Franklin IBE scheme (https://eprint.iacr.org/2001/090).\n * Note that this implementation is of the \"BasicIdent\" protocol which on its own is not CCA secure, so this IBE implementation should not be used on its own.\n *\n * This object represents a set of key servers that can be used to encrypt messages for a given identity.\n */\nexport class BonehFranklinBLS12381Services extends IBEServers {\n\treadonly publicKeys: G2Element[];\n\n\tconstructor(services: KeyServer[]) {\n\t\tsuper(services.map((service) => service.objectId));\n\t\tthis.publicKeys = services.map((service) => G2Element.fromBytes(service.pk));\n\t}\n\n\tencryptBatched(\n\t\tid: Uint8Array,\n\t\tshares: Share[],\n\t\tbaseKey: Uint8Array,\n\t\tthreshold: number,\n\t): typeof IBEEncryptions.$inferType {\n\t\tif (this.publicKeys.length === 0 || this.publicKeys.length !== shares.length) {\n\t\t\tthrow new Error('Invalid public keys');\n\t\t}\n\t\tconst [r, nonce, keys] = encapBatched(this.publicKeys, id);\n\t\tconst encryptedShares = shares.map(({ share, index }, i) =>\n\t\t\txor(share, kdf(keys[i], nonce, id, this.objectIds[i], index)),\n\t\t);\n\t\tconst randomnessKey = deriveKey(\n\t\t\tKeyPurpose.EncryptedRandomness,\n\t\t\tbaseKey,\n\t\t\tencryptedShares,\n\t\t\tthreshold,\n\t\t\tthis.objectIds,\n\t\t);\n\t\tconst encryptedRandomness = xor(randomnessKey, r.toBytes());\n\n\t\treturn {\n\t\t\tBonehFranklinBLS12381: {\n\t\t\t\tnonce: nonce.toBytes(),\n\t\t\t\tencryptedShares,\n\t\t\t\tencryptedRandomness,\n\t\t\t},\n\t\t\t$kind: 'BonehFranklinBLS12381',\n\t\t};\n\t}\n\n\t/**\n\t * Returns true if the user secret key is valid for the given public key and id.\n\t * @param user_secret_key - The user secret key.\n\t * @param id - The identity.\n\t * @param public_key - The public key.\n\t * @returns True if the user secret key is valid for the given public key and id.\n\t */\n\tstatic verifyUserSecretKey(userSecretKey: G1Element, id: string, publicKey: G2Element): boolean {\n\t\tconst lhs = userSecretKey.pairing(G2Element.generator());\n\t\tconst rhs = hashToG1(fromHex(id)).pairing(publicKey);\n\t\treturn lhs.equals(rhs);\n\t}\n\n\t/**\n\t * Identity-based decryption.\n\t *\n\t * @param nonce The encryption nonce.\n\t * @param sk The user secret key.\n\t * @param ciphertext The encrypted message.\n\t * @param info An info parameter also included in the KDF.\n\t * @returns The decrypted message.\n\t */\n\tstatic decrypt(\n\t\tnonce: G2Element,\n\t\tsk: G1Element,\n\t\tciphertext: Uint8Array,\n\t\tid: Uint8Array,\n\t\t[objectId, index]: [string, number],\n\t): Uint8Array {\n\t\treturn xor(ciphertext, kdf(decap(nonce, sk), nonce, id, objectId, index));\n\t}\n\n\t/**\n\t * Decrypt all shares and verify that the randomness was used to create the given nonce.\n\t *\n\t * @param randomness - The randomness.\n\t * @param encryptedShares - The encrypted shares.\n\t * @param services - The services.\n\t * @param publicKeys - The public keys.\n\t * @param nonce - The nonce.\n\t * @param id - The id.\n\t * @returns All decrypted shares.\n\t */\n\tstatic decryptAllSharesUsingRandomness(\n\t\trandomness: Uint8Array,\n\t\tencryptedShares: Uint8Array[],\n\t\tservices: [string, number][],\n\t\tpublicKeys: G2Element[],\n\t\tnonce: G2Element,\n\t\tid: Uint8Array,\n\t): { index: number; share: Uint8Array }[] {\n\t\tif (publicKeys.length !== encryptedShares.length || publicKeys.length !== services.length) {\n\t\t\tthrow new Error('The number of public keys, encrypted shares and services must be the same');\n\t\t}\n\t\tlet r;\n\t\ttry {\n\t\t\tr = Scalar.fromBytes(randomness);\n\t\t} catch {\n\t\t\tthrow new InvalidCiphertextError('Invalid randomness');\n\t\t}\n\t\tconst gid_r = hashToG1(id).multiply(r);\n\t\treturn services.map(([objectId, index], i) => {\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tshare: xor(\n\t\t\t\t\tencryptedShares[i],\n\t\t\t\t\tkdf(gid_r.pairing(publicKeys[i]), nonce, id, objectId, index),\n\t\t\t\t),\n\t\t\t};\n\t\t});\n\t}\n}\n\n/**\n * Batched identity-based key-encapsulation mechanism: encapsulate multiple keys for given identity using different key servers.\n *\n * @param publicKeys Public keys for a set of key servers.\n * @param id The identity used to encapsulate the keys.\n * @returns A common nonce of the keys and a list of keys, 32 bytes each.\n */\nfunction encapBatched(publicKeys: G2Element[], id: Uint8Array): [Scalar, G2Element, GTElement[]] {\n\tif (publicKeys.length === 0) {\n\t\tthrow new Error('No public keys provided');\n\t}\n\tconst r = Scalar.random();\n\tconst nonce = G2Element.generator().multiply(r);\n\tconst gid_r = hashToG1(id).multiply(r);\n\treturn [r, nonce, publicKeys.map((public_key) => gid_r.pairing(public_key))];\n}\n\n/**\n * Decapsulate a key using a user secret key and the nonce.\n *\n * @param usk The user secret key.\n * @param nonce The nonce.\n * @returns The encapsulated key.\n */\nfunction decap(nonce: G2Element, usk: G1Element): GTElement {\n\treturn usk.pairing(nonce);\n}\n\n/**\n * Verify that the given randomness was used to crate the nonce.\n * Throws an error if the given randomness is invalid (not a BLS scalar).\n *\n * @param randomness - The randomness.\n * @param nonce - The nonce.\n * @param useBE - Flag to indicate if BE encoding is used for the randomness. Defaults to true.\n * @returns True if the randomness was used to create the nonce, false otherwise.\n */\nexport function verifyNonce(\n\tnonce: G2Element,\n\trandomness: Uint8Array,\n\tuseBE: boolean = true,\n): boolean {\n\ttry {\n\t\tconst r = decodeRandomness(randomness, useBE);\n\t\treturn G2Element.generator().multiply(r).equals(nonce);\n\t} catch {\n\t\tthrow new InvalidCiphertextError('Invalid randomness');\n\t}\n}\n\nfunction decodeRandomness(bytes: Uint8Array, useBE: boolean): Scalar {\n\tif (useBE) {\n\t\treturn Scalar.fromBytes(bytes);\n\t} else {\n\t\treturn Scalar.fromBytesLE(bytes);\n\t}\n}\n\n/**\n * Decrypt the randomness using a key.\n *\n * @param encrypted_randomness - The encrypted randomness.\n * @param derived_key - The derived key.\n * @returns The randomness. Returns both the scalar interpreted in big-endian and little-endian encoding.\n */\nexport function decryptRandomness(\n\tencryptedRandomness: Uint8Array,\n\trandomnessKey: Uint8Array,\n): Uint8Array {\n\treturn xor(encryptedRandomness, randomnessKey);\n}\n\n/**\n * Verify that the given randomness was used to crate the nonce.\n * Check using both big-endian and little-endian encoding of the randomness.\n *\n * Throws an error if the nonce check doesn't pass using LE encoding _and_ the randomness is invalid as a BE encoded scalar.\n *\n * @param randomness - The randomness.\n * @param nonce - The nonce.\n * @returns True if the randomness was used to create the nonce using either LE or BE encoding, false otherwise.\n */\nexport function verifyNonceWithLE(nonce: G2Element, randomness: Uint8Array): boolean {\n\ttry {\n\t\t// First try little-endian encoding\n\t\tif (verifyNonce(nonce, randomness, false)) {\n\t\t\treturn true;\n\t\t}\n\t} catch {\n\t\t// Ignore error and try big-endian encoding\n\t}\n\treturn verifyNonce(nonce, randomness, true);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { allEqual, hasDuplicates } from './utils.js';\n\nconst GF256_SIZE = 256;\n\n/**\n * A field element in the Rijndael finite field GF(2\u2078) with a fixed generator g = 0x03.\n */\nexport class GF256 {\n\tvalue: number;\n\n\tconstructor(value: number) {\n\t\tif (value < 0 || value >= GF256_SIZE) {\n\t\t\tthrow new Error(`Invalid value ${value} for GF256`);\n\t\t}\n\t\tthis.value = value;\n\t}\n\n\tlog(): number {\n\t\tif (this.value === 0) {\n\t\t\tthrow new Error('Invalid value');\n\t\t}\n\t\treturn LOG[this.value - 1];\n\t}\n\n\tstatic exp(x: number): GF256 {\n\t\treturn new GF256(EXP[x % (GF256_SIZE - 1)]);\n\t}\n\n\tadd(other: GF256): GF256 {\n\t\treturn new GF256(this.value ^ other.value);\n\t}\n\n\tsub(other: GF256): GF256 {\n\t\t// Addition is the same as subtraction in a binary field.\n\t\treturn this.add(other);\n\t}\n\n\tneg(): GF256 {\n\t\t// Negation doesn't change the value in a binary field.\n\t\treturn this;\n\t}\n\n\tmul(other: GF256): GF256 {\n\t\tif (this.value === 0 || other.value === 0) {\n\t\t\treturn new GF256(0);\n\t\t}\n\t\treturn GF256.exp(this.log() + other.log());\n\t}\n\n\tdiv(other: GF256): GF256 {\n\t\treturn this.mul(GF256.exp(GF256_SIZE - other.log() - 1));\n\t}\n\n\tequals(other: GF256): boolean {\n\t\treturn this.value === other.value;\n\t}\n\n\tstatic zero(): GF256 {\n\t\treturn new GF256(0);\n\t}\n\n\tstatic one(): GF256 {\n\t\treturn new GF256(1);\n\t}\n}\n\n/// Table of E\u1D62 = g\u2071 where g = 0x03 generates the multiplicative group of the field.\nconst EXP: number[] = [\n\t0x01, 0x03, 0x05, 0x0f, 0x11, 0x33, 0x55, 0xff, 0x1a, 0x2e, 0x72, 0x96, 0xa1, 0xf8, 0x13, 0x35,\n\t0x5f, 0xe1, 0x38, 0x48, 0xd8, 0x73, 0x95, 0xa4, 0xf7, 0x02, 0x06, 0x0a, 0x1e, 0x22, 0x66, 0xaa,\n\t0xe5, 0x34, 0x5c, 0xe4, 0x37, 0x59, 0xeb, 0x26, 0x6a, 0xbe, 0xd9, 0x70, 0x90, 0xab, 0xe6, 0x31,\n\t0x53, 0xf5, 0x04, 0x0c, 0x14, 0x3c, 0x44, 0xcc, 0x4f, 0xd1, 0x68, 0xb8, 0xd3, 0x6e, 0xb2, 0xcd,\n\t0x4c, 0xd4, 0x67, 0xa9, 0xe0, 0x3b, 0x4d, 0xd7, 0x62, 0xa6, 0xf1, 0x08, 0x18, 0x28, 0x78, 0x88,\n\t0x83, 0x9e, 0xb9, 0xd0, 0x6b, 0xbd, 0xdc, 0x7f, 0x81, 0x98, 0xb3, 0xce, 0x49, 0xdb, 0x76, 0x9a,\n\t0xb5, 0xc4, 0x57, 0xf9, 0x10, 0x30, 0x50, 0xf0, 0x0b, 0x1d, 0x27, 0x69, 0xbb, 0xd6, 0x61, 0xa3,\n\t0xfe, 0x19, 0x2b, 0x7d, 0x87, 0x92, 0xad, 0xec, 0x2f, 0x71, 0x93, 0xae, 0xe9, 0x20, 0x60, 0xa0,\n\t0xfb, 0x16, 0x3a, 0x4e, 0xd2, 0x6d, 0xb7, 0xc2, 0x5d, 0xe7, 0x32, 0x56, 0xfa, 0x15, 0x3f, 0x41,\n\t0xc3, 0x5e, 0xe2, 0x3d, 0x47, 0xc9, 0x40, 0xc0, 0x5b, 0xed, 0x2c, 0x74, 0x9c, 0xbf, 0xda, 0x75,\n\t0x9f, 0xba, 0xd5, 0x64, 0xac, 0xef, 0x2a, 0x7e, 0x82, 0x9d, 0xbc, 0xdf, 0x7a, 0x8e, 0x89, 0x80,\n\t0x9b, 0xb6, 0xc1, 0x58, 0xe8, 0x23, 0x65, 0xaf, 0xea, 0x25, 0x6f, 0xb1, 0xc8, 0x43, 0xc5, 0x54,\n\t0xfc, 0x1f, 0x21, 0x63, 0xa5, 0xf4, 0x07, 0x09, 0x1b, 0x2d, 0x77, 0x99, 0xb0, 0xcb, 0x46, 0xca,\n\t0x45, 0xcf, 0x4a, 0xde, 0x79, 0x8b, 0x86, 0x91, 0xa8, 0xe3, 0x3e, 0x42, 0xc6, 0x51, 0xf3, 0x0e,\n\t0x12, 0x36, 0x5a, 0xee, 0x29, 0x7b, 0x8d, 0x8c, 0x8f, 0x8a, 0x85, 0x94, 0xa7, 0xf2, 0x0d, 0x17,\n\t0x39, 0x4b, 0xdd, 0x7c, 0x84, 0x97, 0xa2, 0xfd, 0x1c, 0x24, 0x6c, 0xb4, 0xc7, 0x52, 0xf6,\n];\n\n/// Table of L\u1D62 = LOG[i + 1] such that g^L\u1D62 = i where g = 0x03.\nconst LOG: number[] = [\n\t0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03, 0x64,\n\t0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1, 0x7d,\n\t0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78, 0x65,\n\t0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e, 0x96,\n\t0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38, 0x66,\n\t0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10, 0x7e,\n\t0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba, 0x2b,\n\t0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57, 0xaf,\n\t0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8, 0x2c,\n\t0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0, 0x7f,\n\t0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7, 0xcc,\n\t0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d, 0x97,\n\t0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1, 0x53,\n\t0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab, 0x44,\n\t0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5, 0x67,\n\t0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07,\n];\n\nexport class Polynomial {\n\tcoefficients: GF256[];\n\n\t/**\n\t * Construct a new Polynomial over [GF256] from the given coefficients.\n\t * The first coefficient is the constant term.\n\t */\n\tconstructor(coefficients: GF256[]) {\n\t\tthis.coefficients = coefficients.slice();\n\n\t\t// The highest degree coefficient is always non-zero.\n\t\twhile (\n\t\t\tthis.coefficients.length > 0 &&\n\t\t\tthis.coefficients[this.coefficients.length - 1].value === 0\n\t\t) {\n\t\t\tthis.coefficients.pop();\n\t\t}\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): Polynomial {\n\t\treturn new Polynomial(Array.from(bytes, (b) => new GF256(b)));\n\t}\n\n\tdegree(): number {\n\t\tif (this.coefficients.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.coefficients.length - 1;\n\t}\n\n\tgetCoefficient(index: number): GF256 {\n\t\tif (index >= this.coefficients.length) {\n\t\t\treturn GF256.zero();\n\t\t}\n\t\treturn this.coefficients[index];\n\t}\n\n\tadd(other: Polynomial): Polynomial {\n\t\tconst degree = Math.max(this.degree(), other.degree());\n\t\treturn new Polynomial(\n\t\t\tArray.from({ length: degree + 1 }, (_, i) =>\n\t\t\t\tthis.getCoefficient(i).add(other.getCoefficient(i)),\n\t\t\t),\n\t\t);\n\t}\n\n\tmul(other: Polynomial): Polynomial {\n\t\tconst degree = this.degree() + other.degree();\n\t\treturn new Polynomial(\n\t\t\tArray.from({ length: degree + 1 }, (_, i) => {\n\t\t\t\tlet sum = GF256.zero();\n\t\t\t\tfor (let j = 0; j <= i; j++) {\n\t\t\t\t\tif (j <= this.degree() && i - j <= other.degree()) {\n\t\t\t\t\t\tsum = sum.add(this.getCoefficient(j).mul(other.getCoefficient(i - j)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}),\n\t\t);\n\t}\n\n\t/** The polynomial s * this. */\n\tscale(s: GF256): Polynomial {\n\t\treturn new Polynomial(this.coefficients.map((c) => c.mul(s)));\n\t}\n\n\tdiv(s: GF256): Polynomial {\n\t\treturn this.scale(new GF256(1).div(s));\n\t}\n\n\t/** The polynomial x + c. */\n\tstatic monic_linear(c: GF256): Polynomial {\n\t\treturn new Polynomial([c, GF256.one()]);\n\t}\n\n\tstatic zero(): Polynomial {\n\t\treturn new Polynomial([]);\n\t}\n\n\tstatic one(): Polynomial {\n\t\treturn new Polynomial([GF256.one()]);\n\t}\n\n\t/** Given a set of coordinates, interpolate a polynomial. */\n\tstatic interpolate(coordinates: { x: GF256; y: GF256 }[]): Polynomial {\n\t\tif (coordinates.length < 1) {\n\t\t\tthrow new Error('At least one coefficient is required');\n\t\t}\n\n\t\tif (hasDuplicates(coordinates.map(({ x }) => x.value))) {\n\t\t\tthrow new Error('Coefficients must have unique x values');\n\t\t}\n\n\t\treturn coordinates.reduce(\n\t\t\t(sum, { x: x_j, y: y_j }, j) =>\n\t\t\t\tsum.add(\n\t\t\t\t\tcoordinates\n\t\t\t\t\t\t.filter((_, i) => i !== j)\n\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t(product, { x: x_i }) =>\n\t\t\t\t\t\t\t\tproduct.mul(Polynomial.monic_linear(x_i.neg()).div(x_j.sub(x_i))),\n\t\t\t\t\t\t\tPolynomial.one(),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.scale(y_j),\n\t\t\t\t),\n\t\t\tPolynomial.zero(),\n\t\t);\n\t}\n\n\t/** Given a set of coordinates, interpolate a polynomial and evaluate it at x = 0. */\n\tstatic combine(coordinates: { x: GF256; y: GF256 }[]): GF256 {\n\t\tif (coordinates.length < 1) {\n\t\t\tthrow new Error('At least one coefficient is required');\n\t\t}\n\n\t\tif (hasDuplicates(coordinates.map(({ x }) => x.value))) {\n\t\t\tthrow new Error('Coefficients must have unique x values');\n\t\t}\n\n\t\tconst quotient: GF256 = coordinates.reduce((sum, { x: x_j, y: y_j }, j) => {\n\t\t\tconst denominator = x_j.mul(\n\t\t\t\tcoordinates\n\t\t\t\t\t.filter((_, i) => i !== j)\n\t\t\t\t\t.reduce((product, { x: x_i }) => product.mul(x_i.sub(x_j)), GF256.one()),\n\t\t\t);\n\t\t\treturn sum.add(y_j.div(denominator));\n\t\t}, GF256.zero());\n\n\t\tconst xProduct = coordinates.reduce((product, { x }) => product.mul(x), GF256.one());\n\t\treturn xProduct.mul(quotient);\n\t}\n\n\t/** Evaluate the polynomial at x. */\n\tevaluate(x: GF256): GF256 {\n\t\treturn this.coefficients\n\t\t\t.toReversed()\n\t\t\t.reduce((sum, coefficient) => sum.mul(x).add(coefficient), GF256.zero());\n\t}\n\n\tequals(other: Polynomial): boolean {\n\t\tif (this.coefficients.length !== other.coefficients.length) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.coefficients.every((c, i) => c.equals(other.getCoefficient(i)));\n\t}\n}\n\n/** Representation of a share of a secret. The index is a number between 1 and 255. */\nexport type Share = {\n\tindex: number;\n\tshare: Uint8Array<ArrayBuffer>;\n};\n\nfunction toInternalShare(share: Share): InternalShare {\n\treturn {\n\t\tindex: new GF256(share.index),\n\t\tshare: Array.from(share.share, (byte) => new GF256(byte)),\n\t};\n}\n\n/** Internal representation of a share of a secret. The index is a non-zero GF256. */\ntype InternalShare = {\n\tindex: GF256;\n\tshare: GF256[];\n};\n\nfunction toShare(internalShare: InternalShare): Share {\n\treturn {\n\t\tindex: internalShare.index.value,\n\t\tshare: new Uint8Array(internalShare.share.map((byte) => byte.value)),\n\t};\n}\n\n/**\n * Sample a random polynomial with the given constant and degree.\n *\n * @param constant The constant term of the polynomial.\n * @param degree The degree of the polynomial.\n * @returns A random polynomial with the given constant and degree.\n */\nfunction samplePolynomial(constant: GF256, degree: number): Polynomial {\n\tconst randomCoefficients = new Uint8Array(degree);\n\tcrypto.getRandomValues(randomCoefficients);\n\n\t// The resulting polynomial has degree + 1 coefficients.\n\treturn Polynomial.fromBytes(new Uint8Array([constant.value, ...randomCoefficients]));\n}\n\n/**\n * Split a secret into shares.\n *\n * @param secret The secret to split.\n * @param threshold The minimum number of shares required to reconstruct the secret.\n * @param total The total number of shares to generate.\n * @returns The shares.\n */\nexport function split(secret: Uint8Array, threshold: number, total: number): Share[] {\n\tif (threshold > total || threshold < 1 || total >= GF256_SIZE) {\n\t\tthrow new Error(`Invalid threshold ${threshold} or total ${total}`);\n\t}\n\n\tconst polynomials = Array.from(secret, (s) => samplePolynomial(new GF256(s), threshold - 1));\n\treturn Array.from({ length: total }, (_, i) => {\n\t\t// Indexes start at 1 because 0 is reserved for the constant term (which is also the secret).\n\t\tconst index = new GF256(i + 1);\n\t\tconst share = polynomials.map((p) => p.evaluate(index));\n\t\treturn toShare({ index, share });\n\t});\n}\n\n/** Validate a set of shares and return them in internal shares representation along with the length of the shares. */\nfunction validateShares(shares: Share[]): { internalShares: InternalShare[]; length: number } {\n\tif (shares.length < 1) {\n\t\tthrow new Error('At least one share is required');\n\t}\n\n\tif (!allEqual(shares.map(({ share }) => share.length))) {\n\t\tthrow new Error('All shares must have the same length');\n\t}\n\n\tif (hasDuplicates(shares.map(({ index }) => index))) {\n\t\tthrow new Error('Shares must have unique indices');\n\t}\n\n\tconst internalShares = shares.map(toInternalShare);\n\tconst length = internalShares[0].share.length;\n\n\treturn { internalShares, length };\n}\n\n/**\n * Combine shares into a secret. If fewer than the threshold number of shares are provided,\n * the result will be indistinguishable from random.\n *\n * @param shares The shares to combine.\n * @returns The secret.\n */\nexport function combine(shares: Share[]): Uint8Array<ArrayBuffer> {\n\tconst { internalShares, length } = validateShares(shares);\n\n\treturn new Uint8Array(\n\t\tArray.from(\n\t\t\t{ length },\n\t\t\t(_, i) =>\n\t\t\t\tPolynomial.combine(\n\t\t\t\t\tinternalShares.map(({ index, share }) => ({\n\t\t\t\t\t\tx: index,\n\t\t\t\t\t\ty: share[i],\n\t\t\t\t\t})),\n\t\t\t\t).value,\n\t\t),\n\t);\n}\n\n/**\n * Interpolate a polynomial from the given shares.\n *\n * @param shares The shares to interpolate from.\n * @returns A function that evaluates the polynomial at a given x.\n */\nexport function interpolate(shares: Share[]): (x: number) => Uint8Array {\n\tconst { internalShares, length } = validateShares(shares);\n\n\tconst polynomials = Array.from({ length }, (_, i) =>\n\t\tPolynomial.interpolate(internalShares.map(({ index, share }) => ({ x: index, y: share[i] }))),\n\t);\n\n\treturn (x: number) => {\n\t\treturn new Uint8Array(polynomials.map((p) => p.evaluate(new GF256(x)).value));\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\n\nimport type { EncryptedObject } from './bcs.js';\nimport type { G1Element } from './bls12381.js';\nimport { G2Element } from './bls12381.js';\nimport { AesGcm256, Hmac256Ctr } from './dem.js';\nimport { InvalidCiphertextError, UnsupportedFeatureError } from './error.js';\nimport {\n\tBonehFranklinBLS12381Services,\n\tdecryptRandomness,\n\tverifyNonce,\n\tverifyNonceWithLE,\n} from './ibe.js';\nimport { deriveKey, KeyPurpose } from './kdf.js';\nimport type { KeyCacheKey } from './types.js';\nimport { createFullId, equals } from './utils.js';\nimport { combine, interpolate } from './shamir.js';\n\nexport interface DecryptOptions {\n\tencryptedObject: typeof EncryptedObject.$inferType;\n\tkeys: Map<KeyCacheKey, G1Element>;\n\tpublicKeys?: G2Element[];\n\tcheckLEEncoding?: boolean;\n}\n\n/**\n * Decrypt the given encrypted bytes with the given cached secret keys for the full ID.\n * It's assumed that fetchKeys has been called to fetch the secret keys for enough key servers\n * otherwise, this will throw an error.\n * Also, it's assumed that the keys were verified by the caller.\n *\n * If publicKeys are provided, the decrypted shares are checked for consistency, meaning that\n * any combination of at least threshold shares should either succesfully combine to the plaintext or fail.\n *\n * @returns - The decrypted plaintext corresponding to ciphertext.\n */\nexport async function decrypt({\n\tencryptedObject,\n\tkeys,\n\tpublicKeys,\n\tcheckLEEncoding,\n}: DecryptOptions): Promise<Uint8Array> {\n\tif (!encryptedObject.encryptedShares.BonehFranklinBLS12381) {\n\t\tthrow new UnsupportedFeatureError('Encryption mode not supported');\n\t}\n\n\tconst fullId = createFullId(encryptedObject.packageId, encryptedObject.id);\n\n\t// Get the indices of the service whose keys are in the keystore.\n\tconst inKeystore = encryptedObject.services\n\t\t.map((_, i) => i)\n\t\t.filter((i) => keys.has(`${fullId}:${encryptedObject.services[i][0]}`));\n\n\tif (inKeystore.length < encryptedObject.threshold) {\n\t\tthrow new Error('Not enough shares. Please fetch more keys.');\n\t}\n\n\tconst encryptedShares = encryptedObject.encryptedShares.BonehFranklinBLS12381.encryptedShares;\n\tif (encryptedShares.length !== encryptedObject.services.length) {\n\t\tthrow new InvalidCiphertextError(\n\t\t\t`Mismatched shares ${encryptedShares.length} and services ${encryptedObject.services.length}`,\n\t\t);\n\t}\n\n\tconst nonce = G2Element.fromBytes(encryptedObject.encryptedShares.BonehFranklinBLS12381.nonce);\n\n\t// Decrypt each share.\n\tconst shares = inKeystore.map((i) => {\n\t\tconst [objectId, index] = encryptedObject.services[i];\n\t\t// Use the index as the unique info parameter to allow for multiple shares per key server.\n\t\tconst share = BonehFranklinBLS12381Services.decrypt(\n\t\t\tnonce,\n\t\t\tkeys.get(`${fullId}:${objectId}`)!,\n\t\t\tencryptedShares[i],\n\t\t\tfromHex(fullId),\n\t\t\t[objectId, index],\n\t\t) as Uint8Array<ArrayBuffer>;\n\t\treturn { index, share };\n\t});\n\n\t// Combine the decrypted shares into the key\n\tconst baseKey = combine(shares);\n\n\t// Decrypt randomness\n\tconst randomnessKey = deriveKey(\n\t\tKeyPurpose.EncryptedRandomness,\n\t\tbaseKey,\n\t\tencryptedShares,\n\t\tencryptedObject.threshold,\n\t\tencryptedObject.services.map(([objectIds, _]) => objectIds),\n\t);\n\tconst randomness = decryptRandomness(\n\t\tencryptedObject.encryptedShares.BonehFranklinBLS12381.encryptedRandomness,\n\t\trandomnessKey,\n\t);\n\n\t// Verify that the nonce was created with the randomness.\n\tif (!(checkLEEncoding ? verifyNonceWithLE(nonce, randomness) : verifyNonce(nonce, randomness))) {\n\t\tthrow new InvalidCiphertextError('Invalid nonce');\n\t}\n\n\t// If public keys are provided, check consistency of the shares.\n\tconst checkShareConsistency = publicKeys !== undefined;\n\tif (checkShareConsistency) {\n\t\tconst polynomial = interpolate(shares);\n\t\tconst allShares = BonehFranklinBLS12381Services.decryptAllSharesUsingRandomness(\n\t\t\trandomness,\n\t\t\tencryptedShares,\n\t\t\tencryptedObject.services,\n\t\t\tpublicKeys,\n\t\t\tnonce,\n\t\t\tfromHex(fullId),\n\t\t);\n\t\tif (allShares.some(({ index, share }) => !equals(polynomial(index), share))) {\n\t\t\tthrow new InvalidCiphertextError('Invalid shares');\n\t\t}\n\t}\n\n\t// Derive the DEM key\n\tconst demKey = deriveKey(\n\t\tKeyPurpose.DEM,\n\t\tbaseKey,\n\t\tencryptedShares,\n\t\tencryptedObject.threshold,\n\t\tencryptedObject.services.map(([objectId, _]) => objectId),\n\t);\n\n\t// Decrypt the ciphertext\n\tif (encryptedObject.ciphertext.Aes256Gcm) {\n\t\treturn AesGcm256.decrypt(demKey, encryptedObject.ciphertext);\n\t} else if (encryptedObject.ciphertext.Hmac256Ctr) {\n\t\treturn Hmac256Ctr.decrypt(demKey, encryptedObject.ciphertext);\n\t} else if (encryptedObject.ciphertext.Plain) {\n\t\t// In case `Plain` mode is used, return the key.\n\t\treturn demKey;\n\t} else {\n\t\tthrow new InvalidCiphertextError('Invalid ciphertext type');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\n\nimport type { IBEEncryptions } from './bcs.js';\nimport { EncryptedObject } from './bcs.js';\nimport type { EncryptionInput } from './dem.js';\nimport { UserError } from './error.js';\nimport { BonehFranklinBLS12381Services } from './ibe.js';\nimport { deriveKey, KeyPurpose } from './kdf.js';\nimport type { KeyServer } from './key-server.js';\nimport { createFullId, MAX_U8 } from './utils.js';\nimport type { Share } from './shamir.js';\nimport { split } from './shamir.js';\n\n/**\n * Given full ID and what key servers to use, return the encrypted message under the identity and return the bcs bytes of the encrypted object.\n *\n * @param keyServers - A list of KeyServers (same server can be used multiple times)\n * @param kemType - The type of KEM to use.\n * @param packageId - packageId\n * @param id - id\n * @param encryptionInput - Input to the encryption. Should be one of the EncryptionInput types, AesGcmEncryptionInput or Plain.\n * @param threshold - The threshold for the TSS encryption.\n * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.\n * Since the key can be used to decrypt, it should not be shared but can be used eg. for backup.\n */\nexport async function encrypt({\n\tkeyServers,\n\tkemType,\n\tthreshold,\n\tpackageId,\n\tid,\n\tencryptionInput,\n}: {\n\tkeyServers: KeyServer[];\n\tkemType: KemType;\n\tthreshold: number;\n\tpackageId: string;\n\tid: string;\n\tencryptionInput: EncryptionInput;\n}): Promise<{\n\tencryptedObject: Uint8Array<ArrayBuffer>;\n\tkey: Uint8Array<ArrayBuffer>;\n}> {\n\t// Check inputs\n\tif (\n\t\tthreshold <= 0 ||\n\t\tthreshold > MAX_U8 ||\n\t\tkeyServers.length < threshold ||\n\t\tkeyServers.length > MAX_U8\n\t) {\n\t\tthrow new UserError(\n\t\t\t`Invalid key servers or threshold ${threshold} for ${keyServers.length} key servers for package ${packageId}`,\n\t\t);\n\t}\n\n\t// Generate a random base key.\n\tconst baseKey = await encryptionInput.generateKey();\n\n\t// Split the key into shares and encrypt each share with the public keys of the key servers.\n\tconst shares = split(baseKey, threshold, keyServers.length);\n\n\t// Encrypt the shares with the public keys of the key servers.\n\tconst fullId = createFullId(packageId, id);\n\tconst encryptedShares = encryptBatched(\n\t\tkeyServers,\n\t\tkemType,\n\t\tfromHex(fullId),\n\t\tshares,\n\t\tbaseKey,\n\t\tthreshold,\n\t);\n\n\t// Encrypt the object with the derived DEM key.\n\tconst demKey = deriveKey(\n\t\tKeyPurpose.DEM,\n\t\tbaseKey,\n\t\tencryptedShares.BonehFranklinBLS12381.encryptedShares,\n\t\tthreshold,\n\t\tkeyServers.map(({ objectId }) => objectId),\n\t);\n\tconst ciphertext = await encryptionInput.encrypt(demKey);\n\n\t// Services and indices of their shares are stored as a tuple\n\tconst services: [string, number][] = keyServers.map(({ objectId }, i) => [\n\t\tobjectId,\n\t\tshares[i].index,\n\t]);\n\n\treturn {\n\t\tencryptedObject: EncryptedObject.serialize({\n\t\t\tversion: 0,\n\t\t\tpackageId,\n\t\t\tid,\n\t\t\tservices,\n\t\t\tthreshold,\n\t\t\tencryptedShares,\n\t\t\tciphertext,\n\t\t}).toBytes(),\n\t\tkey: demKey,\n\t};\n}\n\nexport enum KemType {\n\tBonehFranklinBLS12381DemCCA = 0,\n}\n\nexport enum DemType {\n\tAesGcm256 = 0,\n\tHmac256Ctr = 1,\n}\n\nfunction encryptBatched(\n\tkeyServers: KeyServer[],\n\tkemType: KemType,\n\tid: Uint8Array,\n\tshares: Share[],\n\tbaseKey: Uint8Array,\n\tthreshold: number,\n): typeof IBEEncryptions.$inferType {\n\tswitch (kemType) {\n\t\tcase KemType.BonehFranklinBLS12381DemCCA:\n\t\t\treturn new BonehFranklinBLS12381Services(keyServers).encryptBatched(\n\t\t\t\tid,\n\t\t\t\tshares,\n\t\t\t\tbaseKey,\n\t\t\t\tthreshold,\n\t\t\t);\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid KEM type ${kemType}`);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '0.9.4';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { G1Element, G2Element, Scalar } from './bls12381.js';\n\n/**\n * Decrypt a ciphertext with a given secret key. The secret key must be a 32-byte scalar.\n * The ciphertext is a pair of G1Elements (48 bytes).\n *\n * Throws an error if the secret key is not a valid scalar or if the ciphertext elements are not valid G1 points.\n */\nexport function elgamalDecrypt(sk: Uint8Array, [c0, c1]: [Uint8Array, Uint8Array]): Uint8Array {\n\treturn decrypt(Scalar.fromBytes(sk), [\n\t\tG1Element.fromBytes(c0),\n\t\tG1Element.fromBytes(c1),\n\t]).toBytes();\n}\n\n/**\n * Decrypt a ciphertext with a given secret key. The secret key must be a 32-byte scalar.\n * The ciphertext is a pair of G1Elements (48 bytes).\n */\nfunction decrypt(sk: Scalar, [c0, c1]: [G1Element, G1Element]): G1Element {\n\treturn c1.subtract(c0.multiply(sk));\n}\n\n/** Generate a random secret key. */\nexport function generateSecretKey(): Uint8Array<ArrayBuffer> {\n\treturn Scalar.random().toBytes() as Uint8Array<ArrayBuffer>;\n}\n\n/** Derive the BLS public key for a given secret key. */\nexport function toPublicKey(sk: Uint8Array<ArrayBuffer>): Uint8Array<ArrayBuffer> {\n\treturn G1Element.generator().multiply(Scalar.fromBytes(sk)).toBytes();\n}\n\n/** Derive the BLS verification key for a given secret key. */\nexport function toVerificationKey(sk: Uint8Array<ArrayBuffer>): Uint8Array<ArrayBuffer> {\n\treturn G2Element.generator().multiply(Scalar.fromBytes(sk)).toBytes();\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { bcs, fromBase64, fromHex, toBase64, toHex } from '@mysten/bcs';\nimport { bls12_381 } from '@noble/curves/bls12-381';\n\nimport { KeyServerMove, KeyServerMoveV1 } from './bcs.js';\nimport { InvalidKeyServerError, InvalidKeyServerVersionError, SealAPIError } from './error.js';\nimport { DST_POP } from './ibe.js';\nimport { PACKAGE_VERSION } from './version.js';\nimport type { SealCompatibleClient } from './types.js';\nimport type { G1Element } from './bls12381.js';\nimport { flatten, Version } from './utils.js';\nimport { elgamalDecrypt } from './elgamal.js';\nimport type { Certificate } from './session-key.js';\n\nconst EXPECTED_SERVER_VERSION = 1;\n\nexport type KeyServer = {\n\tobjectId: string;\n\tname: string;\n\turl: string;\n\tkeyType: KeyServerType;\n\tpk: Uint8Array<ArrayBuffer>;\n};\n\nexport enum KeyServerType {\n\tBonehFranklinBLS12381 = 0,\n}\n\nexport const SERVER_VERSION_REQUIREMENT = new Version('0.4.1');\n\n/**\n * Given a list of key server object IDs, returns a list of SealKeyServer\n * from onchain state containing name, objectId, URL and pk.\n *\n * @param objectIds - The key server object IDs.\n * @param client - The SuiClient to use.\n * @returns - An array of SealKeyServer.\n */\nexport async function retrieveKeyServers({\n\tobjectIds,\n\tclient,\n}: {\n\tobjectIds: string[];\n\tclient: SealCompatibleClient;\n}): Promise<KeyServer[]> {\n\treturn await Promise.all(\n\t\tobjectIds.map(async (objectId) => {\n\t\t\t// First get the KeyServer object and validate it.\n\t\t\tconst res = await client.core.getObject({\n\t\t\t\tobjectId,\n\t\t\t});\n\t\t\tconst ks = KeyServerMove.parse(await res.object.content);\n\t\t\tif (\n\t\t\t\tEXPECTED_SERVER_VERSION < Number(ks.firstVersion) ||\n\t\t\t\tEXPECTED_SERVER_VERSION > Number(ks.lastVersion)\n\t\t\t) {\n\t\t\t\tthrow new InvalidKeyServerVersionError(\n\t\t\t\t\t`Key server ${objectId} supports versions between ${ks.firstVersion} and ${ks.lastVersion} (inclusive), but SDK expects version ${EXPECTED_SERVER_VERSION}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Then fetch the expected versioned object and parse it.\n\t\t\tconst resVersionedKs = await client.core.getDynamicField({\n\t\t\t\tparentId: objectId,\n\t\t\t\tname: {\n\t\t\t\t\ttype: 'u64',\n\t\t\t\t\tbcs: bcs.u64().serialize(EXPECTED_SERVER_VERSION).toBytes(),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst ksVersioned = KeyServerMoveV1.parse(resVersionedKs.dynamicField.value.bcs);\n\n\t\t\tif (ksVersioned.keyType !== KeyServerType.BonehFranklinBLS12381) {\n\t\t\t\tthrow new InvalidKeyServerError(\n\t\t\t\t\t`Server ${objectId} has invalid key type: ${ksVersioned.keyType}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tobjectId,\n\t\t\t\tname: ksVersioned.name,\n\t\t\t\turl: ksVersioned.url,\n\t\t\t\tkeyType: ksVersioned.keyType,\n\t\t\t\tpk: new Uint8Array(ksVersioned.pk),\n\t\t\t};\n\t\t}),\n\t);\n}\n\n/**\n * Given a KeyServer, fetch the proof of possession (PoP) from the URL and verify it\n * against the pubkey. This should be used only rarely when the dapp uses a dynamic\n * set of key servers.\n *\n * @param server - The KeyServer to verify.\n * @returns - True if the key server is valid, false otherwise.\n */\nexport async function verifyKeyServer(\n\tserver: KeyServer,\n\ttimeout: number,\n\tapiKeyName?: string,\n\tapiKey?: string,\n): Promise<boolean> {\n\tconst requestId = crypto.randomUUID();\n\tconst response = await fetch(server.url! + '/v1/service?service_id=' + server.objectId, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Request-Id': requestId,\n\t\t\t'Client-Sdk-Type': 'typescript',\n\t\t\t'Client-Sdk-Version': PACKAGE_VERSION,\n\t\t\t...(apiKeyName && apiKey ? { [apiKeyName]: apiKey } : {}),\n\t\t},\n\t\tsignal: AbortSignal.timeout(timeout),\n\t});\n\n\tawait SealAPIError.assertResponse(response, requestId);\n\tverifyKeyServerVersion(response);\n\tconst serviceResponse = await response.json();\n\n\tif (serviceResponse.service_id !== server.objectId) {\n\t\treturn false;\n\t}\n\tconst fullMsg = flatten([DST_POP, server.pk, fromHex(server.objectId)]);\n\treturn bls12_381.verifyShortSignature(fromBase64(serviceResponse.pop), fullMsg, server.pk);\n}\n\n/**\n * Verify the key server version. Throws an `InvalidKeyServerError` if the version is not supported.\n *\n * @param response - The response from the key server.\n */\nexport function verifyKeyServerVersion(response: Response) {\n\tconst keyServerVersion = response.headers.get('X-KeyServer-Version');\n\tif (keyServerVersion == null) {\n\t\tthrow new InvalidKeyServerVersionError('Key server version not found');\n\t}\n\tif (new Version(keyServerVersion).older_than(SERVER_VERSION_REQUIREMENT)) {\n\t\tthrow new InvalidKeyServerVersionError(\n\t\t\t`Key server version ${keyServerVersion} is not supported`,\n\t\t);\n\t}\n}\n\nexport interface DerivedKey {\n\ttoString(): string;\n}\n\n/**\n * A user secret key for the Boneh-Franklin BLS12381 scheme.\n * This is a wrapper around the G1Element type.\n */\nexport class BonehFranklinBLS12381DerivedKey implements DerivedKey {\n\trepresentation: string;\n\n\tconstructor(public key: G1Element) {\n\t\tthis.representation = toHex(key.toBytes());\n\t}\n\n\ttoString(): string {\n\t\treturn this.representation;\n\t}\n}\n\n/**\n * Options for fetching keys from the key server.\n */\nexport interface FetchKeysOptions {\n\t/** The URL of the key server. */\n\turl: string;\n\t/** The Base64 string of request signature. */\n\trequestSignature: string;\n\t/** The transaction bytes. */\n\ttransactionBytes: Uint8Array;\n\t/** The ephemeral secret key. */\n\tencKey: Uint8Array<ArrayBuffer>;\n\t/** The ephemeral public key. */\n\tencKeyPk: Uint8Array<ArrayBuffer>;\n\t/** The ephemeral verification key. */\n\tencVerificationKey: Uint8Array;\n\t/** The certificate. */\n\tcertificate: Certificate;\n\t/** Request timeout in milliseconds. */\n\ttimeout: number;\n\t/** Optional API key name. */\n\tapiKeyName?: string;\n\t/** Optional API key. */\n\tapiKey?: string;\n\t/** Optional abort signal for cancellation. */\n\tsignal?: AbortSignal;\n}\n\n/**\n * Helper function to request all keys from URL with requestSig, txBytes, ephemeral pubkey.\n * Then decrypt the Seal key with ephemeral secret key. Returns a list decryption keys with\n * their full IDs.\n *\n * @param url - The URL of the key server.\n * @param requestSig - The Base64 string of request signature.\n * @param txBytes - The transaction bytes.\n * @param encKey - The ephemeral secret key.\n * @param certificate - The certificate.\n * @returns - A list of full ID and the decrypted key.\n */\nexport async function fetchKeysForAllIds({\n\turl,\n\trequestSignature,\n\ttransactionBytes,\n\tencKey,\n\tencKeyPk,\n\tencVerificationKey,\n\tcertificate,\n\ttimeout,\n\tapiKeyName,\n\tapiKey,\n\tsignal,\n}: FetchKeysOptions): Promise<{ fullId: string; key: Uint8Array<ArrayBuffer> }[]> {\n\tconst body = {\n\t\tptb: toBase64(transactionBytes.slice(1)), // removes the byte of the transaction type version\n\t\tenc_key: toBase64(encKeyPk),\n\t\tenc_verification_key: toBase64(encVerificationKey),\n\t\trequest_signature: requestSignature, // already b64\n\t\tcertificate,\n\t};\n\n\tconst timeoutSignal = AbortSignal.timeout(timeout);\n\tconst combinedSignal = signal ? AbortSignal.any([signal, timeoutSignal]) : timeoutSignal;\n\n\tconst requestId = crypto.randomUUID();\n\tconst response = await fetch(url + '/v1/fetch_key', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Request-Id': requestId,\n\t\t\t'Client-Sdk-Type': 'typescript',\n\t\t\t'Client-Sdk-Version': PACKAGE_VERSION,\n\t\t\t...(apiKeyName && apiKey ? { [apiKeyName]: apiKey } : {}),\n\t\t},\n\t\tbody: JSON.stringify(body),\n\t\tsignal: combinedSignal,\n\t});\n\tawait SealAPIError.assertResponse(response, requestId);\n\tconst resp = await response.json();\n\tverifyKeyServerVersion(response);\n\n\treturn resp.decryption_keys.map(\n\t\t(dk: { id: Uint8Array<ArrayBuffer>; encrypted_key: [string, string] }) => ({\n\t\t\tfullId: toHex(dk.id),\n\t\t\tkey: elgamalDecrypt(encKey, dk.encrypted_key.map(fromBase64) as [Uint8Array, Uint8Array]),\n\t\t}),\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { EncryptedObject } from './bcs.js';\nimport { G1Element, G2Element } from './bls12381.js';\nimport { decrypt } from './decrypt.js';\nimport type { EncryptionInput } from './dem.js';\nimport { AesGcm256, Hmac256Ctr } from './dem.js';\nimport { DemType, encrypt, KemType } from './encrypt.js';\nimport {\n\tInconsistentKeyServersError,\n\tInvalidClientOptionsError,\n\tInvalidKeyServerError,\n\tInvalidPackageError,\n\tInvalidThresholdError,\n\ttoMajorityError,\n\tTooManyFailedFetchKeyRequestsError,\n} from './error.js';\nimport { BonehFranklinBLS12381Services } from './ibe.js';\nimport {\n\tBonehFranklinBLS12381DerivedKey,\n\tretrieveKeyServers,\n\tverifyKeyServer,\n\tfetchKeysForAllIds,\n} from './key-server.js';\nimport type { DerivedKey, KeyServer } from './key-server.js';\nimport type {\n\tDecryptOptions,\n\tEncryptOptions,\n\tFetchKeysOptions,\n\tGetDerivedKeysOptions,\n\tKeyCacheKey,\n\tKeyServerConfig,\n\tSealClientExtensionOptions,\n\tSealClientOptions,\n\tSealCompatibleClient,\n\tSealOptions,\n} from './types.js';\nimport { createFullId, count } from './utils.js';\n\nexport function seal<Name = 'seal'>({ name = 'seal' as Name, ...options }: SealOptions<Name>) {\n\treturn {\n\t\tname,\n\t\tregister: (client: SealCompatibleClient) => {\n\t\t\treturn new SealClient({\n\t\t\t\tsuiClient: client,\n\t\t\t\t...options,\n\t\t\t});\n\t\t},\n\t};\n}\n\nexport class SealClient {\n\t#suiClient: SealCompatibleClient;\n\t#configs: Map<string, KeyServerConfig>;\n\t#keyServers: Promise<Map<string, KeyServer>> | null = null;\n\t#verifyKeyServers: boolean;\n\t// A caching map for: fullId:object_id -> partial key.\n\t#cachedKeys = new Map<KeyCacheKey, G1Element>();\n\t#cachedPublicKeys = new Map<string, G2Element>();\n\t#timeout: number;\n\t#totalWeight: number;\n\n\tconstructor(options: SealClientOptions) {\n\t\tthis.#suiClient = options.suiClient;\n\n\t\tif (\n\t\t\tnew Set(options.serverConfigs.map((s) => s.objectId)).size !== options.serverConfigs.length\n\t\t) {\n\t\t\tthrow new InvalidClientOptionsError('Duplicate object IDs');\n\t\t}\n\n\t\tif (\n\t\t\toptions.serverConfigs.some((s) => (s.apiKeyName && !s.apiKey) || (!s.apiKeyName && s.apiKey))\n\t\t) {\n\t\t\tthrow new InvalidClientOptionsError(\n\t\t\t\t'Both apiKeyName and apiKey must be provided or not provided for all key servers',\n\t\t\t);\n\t\t}\n\n\t\tthis.#configs = new Map(options.serverConfigs.map((server) => [server.objectId, server]));\n\t\tthis.#totalWeight = options.serverConfigs\n\t\t\t.map((server) => server.weight)\n\t\t\t.reduce((sum, term) => sum + term, 0);\n\n\t\tthis.#verifyKeyServers = options.verifyKeyServers ?? true;\n\t\tthis.#timeout = options.timeout ?? 10_000;\n\t}\n\n\t/** @deprecated Use `seal()` instead */\n\tstatic asClientExtension(options: SealClientExtensionOptions) {\n\t\treturn {\n\t\t\tname: 'seal' as const,\n\t\t\tregister: (client: SealCompatibleClient) => {\n\t\t\t\treturn new SealClient({\n\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Return an encrypted message under the identity.\n\t *\n\t * @param kemType - The type of KEM to use.\n\t * @param demType - The type of DEM to use.\n\t * @param threshold - The threshold for the TSS encryption.\n\t * @param packageId - the packageId namespace.\n\t * @param id - the identity to use.\n\t * @param data - the data to encrypt.\n\t * @param aad - optional additional authenticated data.\n\t * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.\n\t * \tSince the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.\n\t */\n\tasync encrypt({\n\t\tkemType = KemType.BonehFranklinBLS12381DemCCA,\n\t\tdemType = DemType.AesGcm256,\n\t\tthreshold,\n\t\tpackageId,\n\t\tid,\n\t\tdata,\n\t\taad = new Uint8Array(),\n\t}: EncryptOptions) {\n\t\tconst packageObj = await this.#suiClient.core.getObject({ objectId: packageId });\n\t\tif (String(packageObj.object.version) !== '1') {\n\t\t\tthrow new InvalidPackageError(`Package ${packageId} is not the first version`);\n\t\t}\n\n\t\treturn encrypt({\n\t\t\tkeyServers: await this.#getWeightedKeyServers(),\n\t\t\tkemType,\n\t\t\tthreshold,\n\t\t\tpackageId,\n\t\t\tid,\n\t\t\tencryptionInput: this.#createEncryptionInput(\n\t\t\t\tdemType,\n\t\t\t\tdata as Uint8Array<ArrayBuffer>,\n\t\t\t\taad as Uint8Array<ArrayBuffer>,\n\t\t\t),\n\t\t});\n\t}\n\n\t#createEncryptionInput(\n\t\ttype: DemType,\n\t\tdata: Uint8Array<ArrayBuffer>,\n\t\taad: Uint8Array<ArrayBuffer>,\n\t): EncryptionInput {\n\t\tswitch (type) {\n\t\t\tcase DemType.AesGcm256:\n\t\t\t\treturn new AesGcm256(data, aad);\n\t\t\tcase DemType.Hmac256Ctr:\n\t\t\t\treturn new Hmac256Ctr(data, aad);\n\t\t}\n\t}\n\n\t/**\n\t * Decrypt the given encrypted bytes using cached keys.\n\t * Calls fetchKeys in case one or more of the required keys is not cached yet.\n\t * The function throws an error if the client's key servers are not a subset of\n\t * the encrypted object's key servers or if the threshold cannot be met.\n\t *\n\t * If checkShareConsistency is true, the decrypted shares are checked for consistency, meaning that\n\t * any combination of at least threshold shares should either succesfully combine to the plaintext or fail.\n\t * This is useful in case the encryptor is not trusted and the decryptor wants to ensure all decryptors\n\t * receive the same output (e.g., for onchain encrypted voting).\n\t *\n\t * @param data - The encrypted bytes to decrypt.\n\t * @param sessionKey - The session key to use.\n\t * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).\n\t * @param checkShareConsistency - If true, the shares are checked for consistency.\n\t * @param checkLEEncoding - If true, the encryption is also checked using an LE encoded nonce.\n\t * @returns - The decrypted plaintext corresponding to ciphertext.\n\t */\n\tasync decrypt({\n\t\tdata,\n\t\tsessionKey,\n\t\ttxBytes,\n\t\tcheckShareConsistency,\n\t\tcheckLEEncoding,\n\t}: DecryptOptions) {\n\t\tconst encryptedObject = EncryptedObject.parse(data);\n\n\t\tthis.#validateEncryptionServices(\n\t\t\tencryptedObject.services.map((s) => s[0]),\n\t\t\tencryptedObject.threshold,\n\t\t);\n\n\t\tawait this.fetchKeys({\n\t\t\tids: [encryptedObject.id],\n\t\t\ttxBytes,\n\t\t\tsessionKey,\n\t\t\tthreshold: encryptedObject.threshold,\n\t\t});\n\n\t\tif (checkShareConsistency) {\n\t\t\tconst publicKeys = await this.getPublicKeys(\n\t\t\t\tencryptedObject.services.map(([objectId, _]) => objectId),\n\t\t\t);\n\t\t\treturn decrypt({\n\t\t\t\tencryptedObject,\n\t\t\t\tkeys: this.#cachedKeys,\n\t\t\t\tpublicKeys,\n\t\t\t\tcheckLEEncoding: false, // We intentionally do not support other encodings here\n\t\t\t});\n\t\t}\n\t\treturn decrypt({ encryptedObject, keys: this.#cachedKeys, checkLEEncoding });\n\t}\n\n\t#weight(objectId: string) {\n\t\treturn this.#configs.get(objectId)?.weight ?? 0;\n\t}\n\n\t#validateEncryptionServices(services: string[], threshold: number) {\n\t\t// Check that the client's key servers are a subset of the encrypted object's key servers.\n\t\tif (\n\t\t\tservices.some((objectId) => {\n\t\t\t\tconst countInClient = this.#weight(objectId);\n\t\t\t\treturn countInClient > 0 && countInClient !== count(services, objectId);\n\t\t\t})\n\t\t) {\n\t\t\tthrow new InconsistentKeyServersError(\n\t\t\t\t`Client's key servers must be a subset of the encrypted object's key servers`,\n\t\t\t);\n\t\t}\n\t\t// Check that the threshold can be met with the client's key servers.\n\t\tif (threshold > this.#totalWeight) {\n\t\t\tthrow new InvalidThresholdError(\n\t\t\t\t`Invalid threshold ${threshold} for ${this.#totalWeight} servers`,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync getKeyServers(): Promise<Map<string, KeyServer>> {\n\t\tif (!this.#keyServers) {\n\t\t\tthis.#keyServers = this.#loadKeyServers().catch((error) => {\n\t\t\t\tthis.#keyServers = null;\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\t\treturn this.#keyServers;\n\t}\n\n\t/**\n\t * Get the public keys for the given services.\n\t * If all public keys are not in the cache, they are retrieved.\n\t *\n\t * @param services - The services to get the public keys for.\n\t * @returns The public keys for the given services in the same order as the given services.\n\t */\n\tasync getPublicKeys(services: string[]): Promise<G2Element[]> {\n\t\tconst keyServers = await this.getKeyServers();\n\n\t\t// Collect the key servers not already in store or cache.\n\t\tconst missingKeyServers = services.filter(\n\t\t\t(objectId) => !keyServers.has(objectId) && !this.#cachedPublicKeys.has(objectId),\n\t\t);\n\n\t\t// If there are missing key servers, retrieve them and update the cache.\n\t\tif (missingKeyServers.length > 0) {\n\t\t\t(\n\t\t\t\tawait retrieveKeyServers({\n\t\t\t\t\tobjectIds: missingKeyServers,\n\t\t\t\t\tclient: this.#suiClient,\n\t\t\t\t})\n\t\t\t).forEach((keyServer) =>\n\t\t\t\tthis.#cachedPublicKeys.set(keyServer.objectId, G2Element.fromBytes(keyServer.pk)),\n\t\t\t);\n\t\t}\n\n\t\treturn services.map((objectId) => {\n\t\t\tconst keyServer = keyServers.get(objectId);\n\t\t\tif (keyServer) {\n\t\t\t\treturn G2Element.fromBytes(keyServer.pk);\n\t\t\t}\n\t\t\treturn this.#cachedPublicKeys.get(objectId)!;\n\t\t});\n\t}\n\n\t/**\n\t * Returns a list of key servers with multiplicity according to their weights.\n\t * The list is used for encryption.\n\t */\n\tasync #getWeightedKeyServers() {\n\t\tconst keyServers = await this.getKeyServers();\n\t\tconst keyServersWithMultiplicity = [];\n\t\tfor (const [objectId, config] of this.#configs) {\n\t\t\tconst keyServer = keyServers.get(objectId)!;\n\t\t\tfor (let i = 0; i < config.weight; i++) {\n\t\t\t\tkeyServersWithMultiplicity.push(keyServer);\n\t\t\t}\n\t\t}\n\t\treturn keyServersWithMultiplicity;\n\t}\n\n\tasync #loadKeyServers(): Promise<Map<string, KeyServer>> {\n\t\tconst keyServers = await retrieveKeyServers({\n\t\t\tobjectIds: [...this.#configs].map(([objectId]) => objectId),\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (keyServers.length === 0) {\n\t\t\tthrow new InvalidKeyServerError('No key servers found');\n\t\t}\n\n\t\tif (this.#verifyKeyServers) {\n\t\t\tawait Promise.all(\n\t\t\t\tkeyServers.map(async (server) => {\n\t\t\t\t\tconst config = this.#configs.get(server.objectId);\n\t\t\t\t\tif (!(await verifyKeyServer(server, this.#timeout, config?.apiKeyName, config?.apiKey))) {\n\t\t\t\t\t\tthrow new InvalidKeyServerError(`Key server ${server.objectId} is not valid`);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t\treturn new Map(keyServers.map((server) => [server.objectId, server]));\n\t}\n\n\t/**\n\t * Fetch keys from the key servers and update the cache.\n\t *\n\t * It is recommended to call this function once for all ids of all encrypted objects if\n\t * there are multiple, then call decrypt for each object. This avoids calling fetchKey\n\t * individually for each decrypt.\n\t *\n\t * @param ids - The ids of the encrypted objects.\n\t * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).\n\t * @param sessionKey - The session key to use.\n\t * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.\n\t */\n\tasync fetchKeys({ ids, txBytes, sessionKey, threshold }: FetchKeysOptions) {\n\t\tif (threshold > this.#totalWeight || threshold < 1) {\n\t\t\tthrow new InvalidThresholdError(\n\t\t\t\t`Invalid threshold ${threshold} servers with weights ${JSON.stringify(this.#configs)}`,\n\t\t\t);\n\t\t}\n\t\tconst keyServers = await this.getKeyServers();\n\t\tconst fullIds = ids.map((id) => createFullId(sessionKey.getPackageId(), id));\n\n\t\t// Count a server as completed if it has keys for all fullIds.\n\t\t// Duplicated key server ids will be counted towards the threshold.\n\t\tlet completedWeight = 0;\n\t\tconst remainingKeyServers = [];\n\t\tlet remainingKeyServersWeight = 0;\n\t\tfor (const objectId of keyServers.keys()) {\n\t\t\tif (fullIds.every((fullId) => this.#cachedKeys.has(`${fullId}:${objectId}`))) {\n\t\t\t\tcompletedWeight += this.#weight(objectId);\n\t\t\t} else {\n\t\t\t\tremainingKeyServers.push(objectId);\n\t\t\t\tremainingKeyServersWeight += this.#weight(objectId);\n\t\t\t}\n\t\t}\n\n\t\t// Return early if we have enough keys from cache.\n\t\tif (completedWeight >= threshold) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst certificate = await sessionKey.getCertificate();\n\t\tconst signedRequest = await sessionKey.createRequestParams(txBytes);\n\n\t\tconst controller = new AbortController();\n\t\tconst errors: Error[] = [];\n\n\t\tconst keyFetches = remainingKeyServers.map(async (objectId) => {\n\t\t\tconst server = keyServers.get(objectId)!;\n\t\t\ttry {\n\t\t\t\tconst config = this.#configs.get(objectId);\n\t\t\t\tconst allKeys = await fetchKeysForAllIds({\n\t\t\t\t\turl: server.url,\n\t\t\t\t\trequestSignature: signedRequest.requestSignature,\n\t\t\t\t\ttransactionBytes: txBytes,\n\t\t\t\t\tencKey: signedRequest.encKey,\n\t\t\t\t\tencKeyPk: signedRequest.encKeyPk,\n\t\t\t\t\tencVerificationKey: signedRequest.encVerificationKey,\n\t\t\t\t\tcertificate,\n\t\t\t\t\ttimeout: this.#timeout,\n\t\t\t\t\tapiKeyName: config?.apiKeyName,\n\t\t\t\t\tapiKey: config?.apiKey,\n\t\t\t\t\tsignal: controller.signal,\n\t\t\t\t});\n\t\t\t\t// Check validity of the keys and add them to the cache.\n\t\t\t\tfor (const { fullId, key } of allKeys) {\n\t\t\t\t\tconst keyElement = G1Element.fromBytes(key);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!BonehFranklinBLS12381Services.verifyUserSecretKey(\n\t\t\t\t\t\t\tkeyElement,\n\t\t\t\t\t\t\tfullId,\n\t\t\t\t\t\t\tG2Element.fromBytes(server.pk),\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconsole.warn('Received invalid key from key server ' + server.objectId);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis.#cachedKeys.set(`${fullId}:${server.objectId}`, keyElement);\n\t\t\t\t}\n\n\t\t\t\t// Check if all the receivedIds are consistent with the requested fullIds.\n\t\t\t\t// If so, consider the key server got all keys and mark as completed.\n\t\t\t\tif (fullIds.every((fullId) => this.#cachedKeys.has(`${fullId}:${server.objectId}`))) {\n\t\t\t\t\tcompletedWeight += this.#weight(objectId);\n\n\t\t\t\t\t// Return early if the completed servers is more than the threshold.\n\t\t\t\t\tif (completedWeight >= threshold) {\n\t\t\t\t\t\tcontroller.abort();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!controller.signal.aborted) {\n\t\t\t\t\terrors.push(error as Error);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\t// If there are too many errors that the threshold is not attainable, return early with error.\n\t\t\t\tremainingKeyServersWeight -= this.#weight(objectId);\n\t\t\t\tif (remainingKeyServersWeight < threshold - completedWeight) {\n\t\t\t\t\tcontroller.abort(new TooManyFailedFetchKeyRequestsError());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.allSettled(keyFetches);\n\n\t\tif (completedWeight < threshold) {\n\t\t\tthrow toMajorityError(errors);\n\t\t}\n\t}\n\n\t/**\n\t * Get derived keys from the given services.\n\t *\n\t * @param id - The id of the encrypted object.\n\t * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).\n\t * @param sessionKey - The session key to use.\n\t * @param threshold - The threshold.\n\t * @returns - Derived keys for the given services that are in the cache as a \"service object ID\" -> derived key map. If the call is succesful, exactly threshold keys will be returned.\n\t */\n\tasync getDerivedKeys({\n\t\tkemType = KemType.BonehFranklinBLS12381DemCCA,\n\t\tid,\n\t\ttxBytes,\n\t\tsessionKey,\n\t\tthreshold,\n\t}: GetDerivedKeysOptions): Promise<Map<string, DerivedKey>> {\n\t\tswitch (kemType) {\n\t\t\tcase KemType.BonehFranklinBLS12381DemCCA:\n\t\t\t\tconst keyServers = await this.getKeyServers();\n\t\t\t\tif (threshold > this.#totalWeight) {\n\t\t\t\t\tthrow new InvalidThresholdError(\n\t\t\t\t\t\t`Invalid threshold ${threshold} for ${this.#totalWeight} servers`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tawait this.fetchKeys({\n\t\t\t\t\tids: [id],\n\t\t\t\t\ttxBytes,\n\t\t\t\t\tsessionKey,\n\t\t\t\t\tthreshold,\n\t\t\t\t});\n\n\t\t\t\t// After calling fetchKeys, we can be sure that there are at least `threshold` of the required keys in the cache.\n\t\t\t\t// It is also checked there that the KeyServerType is BonehFranklinBLS12381 for all services.\n\n\t\t\t\tconst fullId = createFullId(sessionKey.getPackageId(), id);\n\n\t\t\t\tconst derivedKeys = new Map();\n\t\t\t\tlet weight = 0;\n\t\t\t\tfor (const objectId of keyServers.keys()) {\n\t\t\t\t\t// The code below assumes that the KeyServerType is BonehFranklinBLS12381.\n\t\t\t\t\tconst cachedKey = this.#cachedKeys.get(`${fullId}:${objectId}`);\n\t\t\t\t\tif (cachedKey) {\n\t\t\t\t\t\tderivedKeys.set(objectId, new BonehFranklinBLS12381DerivedKey(cachedKey));\n\t\t\t\t\t\tweight += this.#weight(objectId);\n\t\t\t\t\t\tif (weight >= threshold) {\n\t\t\t\t\t\t\t// We have enough keys, so we can stop.\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn derivedKeys;\n\t\t}\n\t}\n}\n", "/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ψ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport type { CurveInfo } from './abstract/curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CMethod,\n  isogenyMap,\n} from './abstract/hash-to-curve.ts';\nimport { Field, mapHashToField, mod, pow2 } from './abstract/modular.ts';\nimport {\n  _normFnElement,\n  type EndomorphismOpts,\n  mapToCurveSimpleSWU,\n  type WeierstrassPoint as PointType,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\nimport type { Hex, PrivKey } from './utils.ts';\nimport {\n  aInRange,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  inRange,\n  numberToBytesBE,\n} from './utils.ts';\n\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n  Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\n\nconst secp256k1_ENDO: EndomorphismOpts = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  basises: [\n    [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n    [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n  ],\n};\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1_CURVE.p;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1_CURVE.p, undefined, undefined, { sqrt: sqrtMod });\n\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */\nexport const secp256k1: CurveFnWithCreate = createCurve(\n  { ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1_CURVE.p);\nconst modN = (x: bigint) => mod(x, secp256k1_CURVE.n);\nconst Point = /* @__PURE__ */ (() => secp256k1.Point)();\nconst hasEven = (y: bigint) => y % _2n === _0n;\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  // TODO: replace with Point.Fn.fromBytes(priv)\n  let d_ = _normFnElement(Point.Fn, priv);\n  let p = Point.BASE.multiply(d_); // P = d'⋅G; 0 < d' < n check is done inside\n  const scalar = hasEven(p.y) ? d_ : modN(-d_);\n  return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  aInRange('x', x, _1n, secp256k1_CURVE.p); // Fail if x ≥ p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (!hasEven(y)) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = Point.fromAffine({ x, y }); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message: Hex, secretKey: PrivKey, auxRand: Hex = randomBytes(32)): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n    if (!inRange(r, _1n, secp256k1_CURVE.p)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n    if (!inRange(s, _1n, secp256k1_CURVE.n)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    // R = s⋅G - e⋅P, where -eP == (n-e)P\n    const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));\n    const { x, y } = R.toAffine();\n    // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    if (R.is0() || !hasEven(y) || x !== r) return false;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    lift_x: typeof lift_x;\n    taggedHash: typeof taggedHash;\n\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `utils` */\n    numberToBytesBE: typeof numberToBytesBE;\n    /** @deprecated use `utils` */\n    bytesToNumberBE: typeof bytesToNumberBE;\n    /** @deprecated use `modular` */\n    mod: typeof mod;\n  };\n  info: { type: 'weierstrass'; publicKeyHasPrefix: false; lengths: CurveInfo['lengths'] };\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => {\n  const size = 32;\n  const seedLength = 48;\n  const randomSecretKey = (seed = randomBytes(seedLength)): Uint8Array => {\n    return mapHashToField(seed, secp256k1_CURVE.n);\n  };\n  // TODO: remove\n  secp256k1.utils.randomSecretKey;\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };\n  }\n  return {\n    keygen,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    Point,\n    utils: {\n      randomSecretKey: randomSecretKey,\n      randomPrivateKey: randomSecretKey,\n      taggedHash,\n\n      // TODO: remove\n      lift_x,\n      pointToBytes,\n      numberToBytesBE,\n      bytesToNumberBE,\n      mod,\n    },\n    info: {\n      type: 'weierstrass',\n      publicKeyHasPrefix: false,\n      lengths: {\n        secret: size,\n        public: size,\n        signature: size * 2,\n        seed: seedLength,\n      },\n    },\n  };\n})();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\n\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.Point,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\n\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.hashToCurve)();\n\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.encodeToCurve)();\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport {\n\tbytesEqual,\n\tparseSerializedKeypairSignature,\n\tPublicKey,\n} from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nconst SECP256K1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256k1 public key\n */\nexport class Secp256k1PublicKey extends PublicKey {\n\tstatic SIZE = SECP256K1_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array<ArrayBuffer>;\n\n\t/**\n\t * Create a new Secp256k1PublicKey object\n\t * @param value secp256k1 public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value as Uint8Array<ArrayBuffer>;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two Secp256k1 public keys are equal\n\t */\n\toverride equals(publicKey: Secp256k1PublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256k1 public key\n\t */\n\ttoRawBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256k1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Secp256k1'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tlet bytes;\n\t\tif (typeof signature === 'string') {\n\t\t\tconst parsed = parseSerializedKeypairSignature(signature);\n\t\t\tif (parsed.signatureScheme !== 'Secp256k1') {\n\t\t\t\tthrow new Error('Invalid signature scheme');\n\t\t\t}\n\n\t\t\tif (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n\t\t\t\tthrow new Error('Signature does not match public key');\n\t\t\t}\n\n\t\t\tbytes = parsed.signature;\n\t\t} else {\n\t\t\tbytes = signature;\n\t\t}\n\n\t\treturn secp256k1.verify(\n\t\t\tsecp256k1.Signature.fromCompact(bytes),\n\t\t\tsha256(message),\n\t\t\tthis.toRawBytes(),\n\t\t);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../../cryptography/signature.js';\n\nconst SECP256R1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256r1 public key\n */\nexport class Secp256r1PublicKey extends PublicKey {\n\tstatic SIZE = SECP256R1_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array<ArrayBuffer>;\n\n\t/**\n\t * Create a new Secp256r1PublicKey object\n\t * @param value secp256r1 public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value as Uint8Array<ArrayBuffer>;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two Secp256r1 public keys are equal\n\t */\n\toverride equals(publicKey: Secp256r1PublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256r1 public key\n\t */\n\ttoRawBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256r1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Secp256r1'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tlet bytes;\n\t\tif (typeof signature === 'string') {\n\t\t\tconst parsed = parseSerializedSignature(signature);\n\t\t\tif (parsed.signatureScheme !== 'Secp256r1') {\n\t\t\t\tthrow new Error('Invalid signature scheme');\n\t\t\t}\n\n\t\t\tif (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n\t\t\t\tthrow new Error('Signature does not match public key');\n\t\t\t}\n\n\t\t\tbytes = parsed.signature;\n\t\t} else {\n\t\t\tbytes = signature;\n\t\t}\n\n\t\treturn secp256r1.verify(\n\t\t\tsecp256r1.Signature.fromCompact(bytes),\n\t\t\tsha256(message),\n\t\t\tthis.toRawBytes(),\n\t\t);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { toBase64 } from '@mysten/bcs';\n\nimport type { SignatureScheme } from '../cryptography/index.js';\nimport { Signer } from '../cryptography/index.js';\nimport type { MultiSigPublicKey } from './publickey.js';\n\nexport class MultiSigSigner extends Signer {\n\t#pubkey: MultiSigPublicKey;\n\t#signers: Signer[];\n\n\tconstructor(pubkey: MultiSigPublicKey, signers: Signer[] = []) {\n\t\tsuper();\n\t\tthis.#pubkey = pubkey;\n\t\tthis.#signers = signers;\n\n\t\tconst uniqueKeys = new Set();\n\t\tlet combinedWeight = 0;\n\n\t\tconst weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({\n\t\t\tweight,\n\t\t\taddress: publicKey.toSuiAddress(),\n\t\t}));\n\n\t\tfor (const signer of signers) {\n\t\t\tconst address = signer.toSuiAddress();\n\t\t\tif (uniqueKeys.has(address)) {\n\t\t\t\tthrow new Error(`Can't create MultiSigSigner with duplicate signers`);\n\t\t\t}\n\t\t\tuniqueKeys.add(address);\n\n\t\t\tconst weight = weights.find((w) => w.address === address)?.weight;\n\n\t\t\tif (!weight) {\n\t\t\t\tthrow new Error(`Signer ${address} is not part of the MultiSig public key`);\n\t\t\t}\n\n\t\t\tcombinedWeight += weight;\n\t\t}\n\n\t\tif (combinedWeight < pubkey.getThreshold()) {\n\t\t\tthrow new Error(`Combined weight of signers is less than threshold`);\n\t\t}\n\t}\n\n\tgetKeyScheme(): SignatureScheme {\n\t\treturn 'MultiSig';\n\t}\n\n\tgetPublicKey(): MultiSigPublicKey {\n\t\treturn this.#pubkey;\n\t}\n\n\tsign(_data: Uint8Array): never {\n\t\tthrow new Error(\n\t\t\t'MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead',\n\t\t);\n\t}\n\n\t/** @deprecated use `sign` instead */\n\tsignData(_data: Uint8Array): never {\n\t\tthrow new Error(\n\t\t\t'MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead',\n\t\t);\n\t}\n\n\tasync signTransaction(bytes: Uint8Array) {\n\t\tconst signature = this.#pubkey.combinePartialSignatures(\n\t\t\tawait Promise.all(\n\t\t\t\tthis.#signers.map(async (signer) => (await signer.signTransaction(bytes)).signature),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n\n\tasync signPersonalMessage(bytes: Uint8Array) {\n\t\tconst signature = this.#pubkey.combinePartialSignatures(\n\t\t\tawait Promise.all(\n\t\t\t\tthis.#signers.map(async (signer) => (await signer.signPersonalMessage(bytes)).signature),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Signer } from '../cryptography/keypair.js';\nimport { bytesEqual, PublicKey } from '../cryptography/publickey.js';\nimport {\n\tSIGNATURE_FLAG_TO_SCHEME,\n\tSIGNATURE_SCHEME_TO_FLAG,\n} from '../cryptography/signature-scheme.js';\nimport type { SignatureFlag, SignatureScheme } from '../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../cryptography/signature.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\n// eslint-disable-next-line import/no-cycle\nimport { publicKeyFromRawBytes } from '../verify/index.js';\nimport type { ZkLoginCompatibleClient } from '../zklogin/publickey.js';\nimport { toZkLoginPublicIdentifier } from '../zklogin/publickey.js';\nimport { MultiSigSigner } from './signer.js';\n\ntype CompressedSignature =\n\t| { ED25519: Uint8Array }\n\t| { Secp256k1: Uint8Array }\n\t| { Secp256r1: Uint8Array }\n\t| { ZkLogin: Uint8Array }\n\t| { Passkey: Uint8Array };\n\ntype PublicKeyEnum =\n\t| { ED25519: Uint8Array }\n\t| { Secp256k1: Uint8Array }\n\t| { Secp256r1: Uint8Array }\n\t| { ZkLogin: Uint8Array }\n\t| { Passkey: Uint8Array };\n\ntype PubkeyEnumWeightPair = {\n\tpubKey: PublicKeyEnum;\n\tweight: number;\n};\n\ntype MultiSigPublicKeyStruct = {\n\tpk_map: PubkeyEnumWeightPair[];\n\tthreshold: number;\n};\n\nexport type MultiSigStruct = {\n\tsigs: CompressedSignature[];\n\tbitmap: number;\n\tmultisig_pk: MultiSigPublicKeyStruct;\n};\n\ntype ParsedPartialMultiSigSignature = {\n\tsignatureScheme: SignatureScheme;\n\tsignature: Uint8Array;\n\tpublicKey: PublicKey;\n\tweight: number;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\nexport const MIN_SIGNER_IN_MULTISIG = 1;\n/**\n * A MultiSig public key\n */\nexport class MultiSigPublicKey extends PublicKey {\n\tprivate rawBytes: Uint8Array<ArrayBuffer>;\n\tprivate multisigPublicKey: MultiSigPublicKeyStruct;\n\tprivate publicKeys: {\n\t\tweight: number;\n\t\tpublicKey: PublicKey;\n\t}[];\n\t/**\n\t * Create a new MultiSigPublicKey object\n\t */\n\tconstructor(\n\t\t/**\n\t\t *  MultiSig public key as buffer or base-64 encoded string\n\t\t */\n\t\tvalue: string | Uint8Array | MultiSigPublicKeyStruct,\n\t\toptions: { client?: ZkLoginCompatibleClient } = {},\n\t) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.rawBytes = fromBase64(value);\n\n\t\t\tthis.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.rawBytes = value as Uint8Array<ArrayBuffer>;\n\t\t\tthis.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n\t\t} else {\n\t\t\tthis.multisigPublicKey = value;\n\t\t\tthis.rawBytes = bcs.MultiSigPublicKey.serialize(value).toBytes();\n\t\t}\n\t\tif (this.multisigPublicKey.threshold < 1) {\n\t\t\tthrow new Error('Invalid threshold');\n\t\t}\n\n\t\tconst seenPublicKeys = new Set<string>();\n\n\t\tthis.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {\n\t\t\tconst [scheme, bytes] = Object.entries(pubKey).filter(([name]) => name !== '$kind')[0] as [\n\t\t\t\tSignatureScheme,\n\t\t\t\tUint8Array,\n\t\t\t];\n\t\t\tconst publicKeyStr = Uint8Array.from(bytes).toString();\n\n\t\t\tif (seenPublicKeys.has(publicKeyStr)) {\n\t\t\t\tthrow new Error(`Multisig does not support duplicate public keys`);\n\t\t\t}\n\t\t\tseenPublicKeys.add(publicKeyStr);\n\n\t\t\tif (weight < 1) {\n\t\t\t\tthrow new Error(`Invalid weight`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpublicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),\n\t\t\t\tweight,\n\t\t\t};\n\t\t});\n\n\t\tconst totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);\n\n\t\tif (this.multisigPublicKey.threshold > totalWeight) {\n\t\t\tthrow new Error(`Unreachable threshold`);\n\t\t}\n\n\t\tif (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\n\t\tif (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);\n\t\t}\n\t}\n\t/**\n\t * \tA static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.\n\t */\n\n\tstatic fromPublicKeys({\n\t\tthreshold,\n\t\tpublicKeys,\n\t}: {\n\t\tthreshold: number;\n\t\tpublicKeys: { publicKey: PublicKey; weight: number }[];\n\t}) {\n\t\treturn new MultiSigPublicKey({\n\t\t\tpk_map: publicKeys.map(({ publicKey, weight }) => {\n\t\t\t\tconst scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag() as SignatureFlag];\n\n\t\t\t\treturn {\n\t\t\t\t\tpubKey: { [scheme]: publicKey.toRawBytes() } as PublicKeyEnum,\n\t\t\t\t\tweight,\n\t\t\t\t};\n\t\t\t}),\n\t\t\tthreshold,\n\t\t});\n\t}\n\n\t/**\n\t * Checks if two MultiSig public keys are equal\n\t */\n\toverride equals(publicKey: MultiSigPublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the MultiSig public key\n\t */\n\ttoRawBytes(): Uint8Array<ArrayBuffer> {\n\t\treturn this.rawBytes;\n\t}\n\n\tgetPublicKeys() {\n\t\treturn this.publicKeys;\n\t}\n\n\tgetThreshold() {\n\t\treturn this.multisigPublicKey.threshold;\n\t}\n\n\tgetSigner(...signers: [signer: Signer]) {\n\t\treturn new MultiSigSigner(this, signers);\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\toverride toSuiAddress(): string {\n\t\t// max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n\t\tconst maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n\t\tconst tmp = new Uint8Array(maxLength);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n\t\ttmp.set(bcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);\n\t\t// The initial value 3 ensures that following data will be after the flag byte and threshold bytes\n\t\tlet i = 3;\n\t\tfor (const { publicKey, weight } of this.publicKeys) {\n\t\t\tconst bytes = publicKey.toSuiBytes();\n\t\t\ttmp.set(bytes, i);\n\t\t\ti += bytes.length;\n\t\t\ttmp.set([weight], i++);\n\t\t}\n\t\treturn normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['MultiSig'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, multisigSignature: string): Promise<boolean> {\n\t\t// Multisig verification only supports serialized signature\n\t\tconst parsed = parseSerializedSignature(multisigSignature);\n\n\t\tif (parsed.signatureScheme !== 'MultiSig') {\n\t\t\tthrow new Error('Invalid signature scheme');\n\t\t}\n\n\t\tconst { multisig } = parsed;\n\n\t\tlet signatureWeight = 0;\n\n\t\tif (\n\t\t\t!bytesEqual(\n\t\t\t\tbcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),\n\t\t\t\tbcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes(),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {\n\t\t\tif (!(await publicKey.verify(message, signature))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsignatureWeight += weight;\n\t\t}\n\n\t\treturn signatureWeight >= this.multisigPublicKey.threshold;\n\t}\n\n\t/**\n\t * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once\n\t * and that all the public keys involved are known and valid, and then serializes multisig into the standard format\n\t */\n\tcombinePartialSignatures(signatures: string[]): string {\n\t\tif (signatures.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\n\t\tlet bitmap = 0;\n\t\tconst compressedSignatures: CompressedSignature[] = new Array(signatures.length);\n\n\t\tfor (let i = 0; i < signatures.length; i++) {\n\t\t\tconst parsed = parseSerializedSignature(signatures[i]);\n\t\t\tif (parsed.signatureScheme === 'MultiSig') {\n\t\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t\t}\n\n\t\t\tlet publicKey;\n\t\t\tif (parsed.signatureScheme === 'ZkLogin') {\n\t\t\t\tpublicKey = toZkLoginPublicIdentifier(\n\t\t\t\t\tparsed.zkLogin?.addressSeed,\n\t\t\t\t\tparsed.zkLogin?.iss,\n\t\t\t\t).toRawBytes();\n\t\t\t} else {\n\t\t\t\tpublicKey = parsed.publicKey;\n\t\t\t}\n\n\t\t\tcompressedSignatures[i] = {\n\t\t\t\t[parsed.signatureScheme]: parsed.signature,\n\t\t\t} as CompressedSignature;\n\n\t\t\tlet publicKeyIndex;\n\t\t\tfor (let j = 0; j < this.publicKeys.length; j++) {\n\t\t\t\tif (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {\n\t\t\t\t\tif (bitmap & (1 << j)) {\n\t\t\t\t\t\tthrow new Error('Received multiple signatures from the same public key');\n\t\t\t\t\t}\n\n\t\t\t\t\tpublicKeyIndex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (publicKeyIndex === undefined) {\n\t\t\t\tthrow new Error('Received signature from unknown public key');\n\t\t\t}\n\n\t\t\tbitmap |= 1 << publicKeyIndex;\n\t\t}\n\n\t\tconst multisig: MultiSigStruct = {\n\t\t\tsigs: compressedSignatures,\n\t\t\tbitmap,\n\t\t\tmultisig_pk: this.multisigPublicKey,\n\t\t};\n\t\tconst bytes = bcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();\n\t\tconst tmp = new Uint8Array(bytes.length + 1);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\t\ttmp.set(bytes, 1);\n\t\treturn toBase64(tmp);\n\t}\n}\n\n/**\n * Parse multisig structure into an array of individual signatures: signature scheme, the actual individual signature, public key and its weight.\n */\nexport function parsePartialSignatures(\n\tmultisig: MultiSigStruct,\n\toptions: { client?: ZkLoginCompatibleClient } = {},\n): ParsedPartialMultiSigSignature[] {\n\tconst res: ParsedPartialMultiSigSignature[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tconst [signatureScheme, signature] = Object.entries(multisig.sigs[i]).filter(\n\t\t\t([name]) => name !== '$kind',\n\t\t)[0] as [SignatureScheme, Uint8Array];\n\t\tconst pkIndex = asIndices(multisig.bitmap).at(i)!;\n\t\tconst pair = multisig.multisig_pk.pk_map[pkIndex];\n\t\tconst pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);\n\n\t\tif (signatureScheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tconst publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);\n\n\t\tres[i] = {\n\t\t\tsignatureScheme,\n\t\t\tsignature: Uint8Array.from(signature),\n\t\t\tpublicKey: publicKey,\n\t\t\tweight: pair.weight,\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction asIndices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tconst res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\n\nimport type { PublicKey, SignatureFlag, SignatureScheme } from '../cryptography/index.js';\nimport { parseSerializedSignature, SIGNATURE_FLAG_TO_SCHEME } from '../cryptography/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { PasskeyPublicKey } from '../keypairs/passkey/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\n// eslint-disable-next-line import/no-cycle\nimport { MultiSigPublicKey } from '../multisig/publickey.js';\nimport type { ZkLoginCompatibleClient } from '../zklogin/publickey.js';\nimport { ZkLoginPublicIdentifier } from '../zklogin/publickey.js';\n\nexport async function verifySignature(\n\tbytes: Uint8Array,\n\tsignature: string,\n\toptions?: {\n\t\taddress?: string;\n\t},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature);\n\n\tif (!(await parsedSignature.publicKey.verify(bytes, parsedSignature.serializedSignature))) {\n\t\tthrow new Error(`Signature is not valid for the provided data`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyPersonalMessageSignature(\n\tmessage: Uint8Array,\n\tsignature: string,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyPersonalMessage(\n\t\t\tmessage,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided message`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyTransactionSignature(\n\ttransaction: Uint8Array,\n\tsignature: string,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyTransaction(\n\t\t\ttransaction,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided Transaction`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nfunction parseSignature(signature: string, options: { client?: ZkLoginCompatibleClient } = {}) {\n\tconst parsedSignature = parseSerializedSignature(signature);\n\n\tif (parsedSignature.signatureScheme === 'MultiSig') {\n\t\treturn {\n\t\t\t...parsedSignature,\n\t\t\tpublicKey: new MultiSigPublicKey(parsedSignature.multisig.multisig_pk),\n\t\t};\n\t}\n\n\tconst publicKey = publicKeyFromRawBytes(\n\t\tparsedSignature.signatureScheme,\n\t\tparsedSignature.publicKey,\n\t\toptions,\n\t);\n\treturn {\n\t\t...parsedSignature,\n\t\tpublicKey,\n\t};\n}\n\nexport function publicKeyFromRawBytes(\n\tsignatureScheme: SignatureScheme,\n\tbytes: Uint8Array,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n): PublicKey {\n\tlet publicKey: PublicKey;\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\t\tpublicKey = new Ed25519PublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'Secp256k1':\n\t\t\tpublicKey = new Secp256k1PublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'Secp256r1':\n\t\t\tpublicKey = new Secp256r1PublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'MultiSig':\n\t\t\tpublicKey = new MultiSigPublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'ZkLogin':\n\t\t\tpublicKey = ZkLoginPublicIdentifier.fromBytes(bytes, options);\n\t\t\tbreak;\n\t\tcase 'Passkey':\n\t\t\tpublicKey = new PasskeyPublicKey(bytes);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported signature scheme ${signatureScheme}`);\n\t}\n\n\tif (options.address && publicKey.toSuiAddress() !== options.address) {\n\t\tthrow new Error(`Public key bytes do not match the provided address`);\n\t}\n\n\treturn publicKey;\n}\n\nexport function publicKeyFromSuiBytes(\n\tpublicKey: string | Uint8Array,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n) {\n\tconst bytes = typeof publicKey === 'string' ? fromBase64(publicKey) : publicKey;\n\n\tconst signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0] as SignatureFlag];\n\n\treturn publicKeyFromRawBytes(signatureScheme, bytes.slice(1), options);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport { isValidNamedPackage, isValidSuiAddress, isValidSuiObjectId } from '@mysten/sui/utils';\nimport { verifyPersonalMessageSignature } from '@mysten/sui/verify';\nimport { generateSecretKey, toPublicKey, toVerificationKey } from './elgamal.js';\nimport {\n\tExpiredSessionKeyError,\n\tInvalidPackageError,\n\tInvalidPersonalMessageSignatureError,\n\tUserError,\n} from './error.js';\nimport type { SealCompatibleClient } from './types.js';\n\nexport const RequestFormat = bcs.struct('RequestFormat', {\n\tptb: bcs.byteVector(),\n\tencKey: bcs.byteVector(),\n\tencVerificationKey: bcs.byteVector(),\n});\n\nexport type Certificate = {\n\tuser: string;\n\tsession_vk: string;\n\tcreation_time: number;\n\tttl_min: number;\n\tsignature: string;\n\tmvr_name?: string;\n};\n\nexport type ExportedSessionKey = {\n\taddress: string;\n\tpackageId: string;\n\tmvrName?: string;\n\tcreationTimeMs: number;\n\tttlMin: number;\n\tpersonalMessageSignature?: string;\n\tsessionKey: string;\n};\n\nexport class SessionKey {\n\t#address: string;\n\t#packageId: string;\n\t#mvrName?: string;\n\t#creationTimeMs: number;\n\t#ttlMin: number;\n\t#sessionKey: Ed25519Keypair;\n\t#personalMessageSignature?: string;\n\t#signer?: Signer;\n\t#suiClient: SealCompatibleClient;\n\n\tprivate constructor({\n\t\taddress,\n\t\tpackageId,\n\t\tmvrName,\n\t\tttlMin,\n\t\tsigner,\n\t\tsuiClient,\n\t}: {\n\t\taddress: string;\n\t\tpackageId: string;\n\t\tmvrName?: string;\n\t\tttlMin: number;\n\t\tsigner?: Signer;\n\t\tsuiClient: SealCompatibleClient;\n\t}) {\n\t\tif (mvrName && !isValidNamedPackage(mvrName)) {\n\t\t\tthrow new UserError(`Invalid package name ${mvrName}`);\n\t\t}\n\t\tif (!isValidSuiObjectId(packageId) || !isValidSuiAddress(address)) {\n\t\t\tthrow new UserError(`Invalid package ID ${packageId} or address ${address}`);\n\t\t}\n\t\tif (ttlMin > 30 || ttlMin < 1) {\n\t\t\tthrow new UserError(`Invalid TTL ${ttlMin}, must be between 1 and 30`);\n\t\t}\n\t\tif (signer && signer.getPublicKey().toSuiAddress() !== address) {\n\t\t\tthrow new UserError('Signer address does not match session key address');\n\t\t}\n\n\t\tthis.#address = address;\n\t\tthis.#packageId = packageId;\n\t\tthis.#mvrName = mvrName;\n\t\tthis.#creationTimeMs = Date.now();\n\t\tthis.#ttlMin = ttlMin;\n\t\tthis.#sessionKey = Ed25519Keypair.generate();\n\t\tthis.#signer = signer;\n\t\tthis.#suiClient = suiClient;\n\t}\n\n\t/**\n\t * Create a new SessionKey instance.\n\t * @param address - The address of the user.\n\t * @param packageId - The ID of the package.\n\t * @param mvrName - Optional. The name of the MVR, if there is one.\n\t * @param ttlMin - The TTL in minutes.\n\t * @param signer - Optional. The signer instance, e.g. EnokiSigner.\n\t * @param suiClient - The Sui client.\n\t * @returns A new SessionKey instance.\n\t */\n\tstatic async create({\n\t\taddress,\n\t\tpackageId,\n\t\tmvrName,\n\t\tttlMin,\n\t\tsigner,\n\t\tsuiClient,\n\t}: {\n\t\taddress: string;\n\t\tpackageId: string;\n\t\tmvrName?: string;\n\t\tttlMin: number;\n\t\tsigner?: Signer;\n\t\tsuiClient: SealCompatibleClient;\n\t}): Promise<SessionKey> {\n\t\tconst packageObj = await suiClient.core.getObject({ objectId: packageId });\n\t\tif (String(packageObj.object.version) !== '1') {\n\t\t\tthrow new InvalidPackageError(`Package ${packageId} is not the first version`);\n\t\t}\n\n\t\treturn new SessionKey({\n\t\t\taddress,\n\t\t\tpackageId,\n\t\t\tmvrName,\n\t\t\tttlMin,\n\t\t\tsigner,\n\t\t\tsuiClient,\n\t\t});\n\t}\n\tisExpired(): boolean {\n\t\t// Allow 10 seconds for clock skew\n\t\treturn this.#creationTimeMs + this.#ttlMin * 60 * 1000 - 10_000 < Date.now();\n\t}\n\n\tgetAddress(): string {\n\t\treturn this.#address;\n\t}\n\n\tgetPackageName(): string {\n\t\tif (this.#mvrName) {\n\t\t\treturn this.#mvrName;\n\t\t}\n\t\treturn this.#packageId;\n\t}\n\n\tgetPackageId(): string {\n\t\treturn this.#packageId;\n\t}\n\n\tgetPersonalMessage(): Uint8Array {\n\t\tconst creationTimeUtc =\n\t\t\tnew Date(this.#creationTimeMs).toISOString().slice(0, 19).replace('T', ' ') + ' UTC';\n\t\tconst message = `Accessing keys of package ${this.getPackageName()} for ${this.#ttlMin} mins from ${creationTimeUtc}, session key ${toBase64(this.#sessionKey.getPublicKey().toRawBytes())}`;\n\t\treturn new TextEncoder().encode(message);\n\t}\n\n\tasync setPersonalMessageSignature(personalMessageSignature: string) {\n\t\tif (!this.#personalMessageSignature) {\n\t\t\ttry {\n\t\t\t\tawait verifyPersonalMessageSignature(this.getPersonalMessage(), personalMessageSignature, {\n\t\t\t\t\taddress: this.#address,\n\t\t\t\t\tclient: this.#suiClient,\n\t\t\t\t});\n\t\t\t\tthis.#personalMessageSignature = personalMessageSignature;\n\t\t\t} catch {\n\t\t\t\tthrow new InvalidPersonalMessageSignatureError('Not valid');\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getCertificate(): Promise<Certificate> {\n\t\tif (!this.#personalMessageSignature) {\n\t\t\tif (this.#signer) {\n\t\t\t\tconst { signature } = await this.#signer.signPersonalMessage(this.getPersonalMessage());\n\t\t\t\tthis.#personalMessageSignature = signature;\n\t\t\t} else {\n\t\t\t\tthrow new InvalidPersonalMessageSignatureError('Personal message signature is not set');\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tuser: this.#address,\n\t\t\tsession_vk: toBase64(this.#sessionKey.getPublicKey().toRawBytes()),\n\t\t\tcreation_time: this.#creationTimeMs,\n\t\t\tttl_min: this.#ttlMin,\n\t\t\tsignature: this.#personalMessageSignature,\n\t\t\tmvr_name: this.#mvrName,\n\t\t};\n\t}\n\n\t/**\n\t * Create request params for the given transaction bytes.\n\t * @param txBytes - The transaction bytes.\n\t * @returns The request params containing the ephemeral secret key,\n\t * its public key and its verification key.\n\t */\n\tasync createRequestParams(txBytes: Uint8Array): Promise<{\n\t\tencKey: Uint8Array<ArrayBuffer>;\n\t\tencKeyPk: Uint8Array<ArrayBuffer>;\n\t\tencVerificationKey: Uint8Array<ArrayBuffer>;\n\t\trequestSignature: string;\n\t}> {\n\t\tif (this.isExpired()) {\n\t\t\tthrow new ExpiredSessionKeyError();\n\t\t}\n\t\tconst encKey = generateSecretKey();\n\t\tconst encKeyPk = toPublicKey(encKey);\n\t\tconst encVerificationKey = toVerificationKey(encKey);\n\n\t\tconst msgToSign = RequestFormat.serialize({\n\t\t\tptb: txBytes.slice(1),\n\t\t\tencKey: encKeyPk,\n\t\t\tencVerificationKey,\n\t\t}).toBytes();\n\t\treturn {\n\t\t\tencKey,\n\t\t\tencKeyPk,\n\t\t\tencVerificationKey,\n\t\t\trequestSignature: toBase64(await this.#sessionKey.sign(msgToSign)),\n\t\t};\n\t}\n\n\t/**\n\t * Export the Session Key object from the instance. Store the object in IndexedDB to persist.\n\t */\n\texport(): ExportedSessionKey {\n\t\tconst obj = {\n\t\t\taddress: this.#address,\n\t\t\tpackageId: this.#packageId,\n\t\t\tmvrName: this.#mvrName,\n\t\t\tcreationTimeMs: this.#creationTimeMs,\n\t\t\tttlMin: this.#ttlMin,\n\t\t\tpersonalMessageSignature: this.#personalMessageSignature,\n\t\t\tsessionKey: this.#sessionKey.getSecretKey(), // bech32 encoded string\n\t\t};\n\n\t\tObject.defineProperty(obj, 'toJSON', {\n\t\t\tenumerable: false,\n\t\t\tvalue: () => {\n\t\t\t\tthrow new Error('This object is not serializable');\n\t\t\t},\n\t\t});\n\t\treturn obj;\n\t}\n\n\t/**\n\t * Restore a SessionKey instance for the given object.\n\t * @returns A new SessionKey instance with restored state\n\t */\n\tstatic import(\n\t\tdata: ExportedSessionKey,\n\t\tsuiClient: SealCompatibleClient,\n\t\tsigner?: Signer,\n\t): SessionKey {\n\t\tconst instance = new SessionKey({\n\t\t\taddress: data.address,\n\t\t\tpackageId: data.packageId,\n\t\t\tmvrName: data.mvrName,\n\t\t\tttlMin: data.ttlMin,\n\t\t\tsigner,\n\t\t\tsuiClient,\n\t\t});\n\n\t\tinstance.#creationTimeMs = data.creationTimeMs;\n\t\tinstance.#sessionKey = Ed25519Keypair.fromSecretKey(data.sessionKey);\n\t\tinstance.#personalMessageSignature = data.personalMessageSignature;\n\n\t\tif (instance.isExpired()) {\n\t\t\tthrow new ExpiredSessionKeyError();\n\t\t}\n\t\treturn instance;\n\t}\n}\n"],
  "mappings": "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AGA,IAAM,MAAgB;EACrB;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;AACrF;AAGA,IAAM,MAAgB;EACrB;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;AACrF;AAEO,IAAM,aAAN,MAAM,YAAW;;;;;EAOvB,YAAY,cAAuB;AAClC,SAAK,eAAe,aAAa,MAAM;AAGvC,WACC,KAAK,aAAa,SAAS,KAC3B,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC,EAAE,UAAU,GACzD;AACD,WAAK,aAAa,IAAI;IACvB;EACD;EAEA,OAAO,UAAU,OAA+B;AAC/C,WAAO,IAAI,YAAW,MAAM,KAAK,OAAO,CAAC,MAAM,IAAI,MAAM,CAAC,CAAC,CAAC;EAC7D;EAEA,SAAiB;AAChB,QAAI,KAAK,aAAa,WAAW,GAAG;AACnC,aAAO;IACR;AACA,WAAO,KAAK,aAAa,SAAS;EACnC;EAEA,eAAe,OAAsB;AACpC,QAAI,SAAS,KAAK,aAAa,QAAQ;AACtC,aAAO,MAAM,KAAK;IACnB;AACA,WAAO,KAAK,aAAa,KAAK;EAC/B;EAEA,IAAI,OAA+B;AAClC,UAAM,SAAS,KAAK,IAAI,KAAK,OAAO,GAAG,MAAM,OAAO,CAAC;AACrD,WAAO,IAAI;MACV,MAAM;QAAK,EAAE,QAAQ,SAAS,EAAE;QAAG,CAAC,GAAG,MACtC,KAAK,eAAe,CAAC,EAAE,IAAI,MAAM,eAAe,CAAC,CAAC;MACnD;IACD;EACD;EAEA,IAAI,OAA+B;AAClC,UAAM,SAAS,KAAK,OAAO,IAAI,MAAM,OAAO;AAC5C,WAAO,IAAI;MACV,MAAM,KAAK,EAAE,QAAQ,SAAS,EAAE,GAAG,CAAC,GAAG,MAAM;AAC5C,YAAI,MAAM,MAAM,KAAK;AACrB,iBAAS,IAAI,GAAG,KAAK,GAAG,KAAK;AAC5B,cAAI,KAAK,KAAK,OAAO,KAAK,IAAI,KAAK,MAAM,OAAO,GAAG;AAClD,kBAAM,IAAI,IAAI,KAAK,eAAe,CAAC,EAAE,IAAI,MAAM,eAAe,IAAI,CAAC,CAAC,CAAC;UACtE;QACD;AACA,eAAO;MACR,CAAC;IACF;EACD;;EAGA,MAAM,GAAsB;AAC3B,WAAO,IAAI,YAAW,KAAK,aAAa,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;EAC7D;EAEA,IAAI,GAAsB;AACzB,WAAO,KAAK,MAAM,IAAI,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;EACtC;;EAGA,OAAO,aAAa,GAAsB;AACzC,WAAO,IAAI,YAAW,CAAC,GAAG,MAAM,IAAI,CAAC,CAAC;EACvC;EAEA,OAAO,OAAmB;AACzB,WAAO,IAAI,YAAW,CAAC,CAAC;EACzB;EAEA,OAAO,MAAkB;AACxB,WAAO,IAAI,YAAW,CAAC,MAAM,IAAI,CAAC,CAAC;EACpC;;EAGA,OAAO,YAAY,aAAmD;AACrE,QAAI,YAAY,SAAS,GAAG;AAC3B,YAAM,IAAI,MAAM,sCAAsC;IACvD;AAEA,QAAI,cAAc,YAAY,IAAI,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,GAAG;AACvD,YAAM,IAAI,MAAM,wCAAwC;IACzD;AAEA,WAAO,YAAY;MAClB,CAAC,KAAK,EAAE,GAAG,KAAK,GAAG,IAAI,GAAG,MACzB,IAAI;QACH,YACE,OAAO,CAAC,GAAG,MAAM,MAAM,CAAC,EACxB;UACA,CAAC,SAAS,EAAE,GAAG,IAAI,MAClB,QAAQ,IAAI,YAAW,aAAa,IAAI,IAAI,CAAC,EAAE,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC;UACjE,YAAW,IAAI;QAChB,EACC,MAAM,GAAG;MACZ;MACD,YAAW,KAAK;IACjB;EACD;;EAGA,OAAO,QAAQ,aAA8C;AAC5D,QAAI,YAAY,SAAS,GAAG;AAC3B,YAAM,IAAI,MAAM,sCAAsC;IACvD;AAEA,QAAI,cAAc,YAAY,IAAI,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,GAAG;AACvD,YAAM,IAAI,MAAM,wCAAwC;IACzD;AAEA,UAAM,WAAkB,YAAY,OAAO,CAAC,KAAK,EAAE,GAAG,KAAK,GAAG,IAAI,GAAG,MAAM;AAC1E,YAAM,cAAc,IAAI;QACvB,YACE,OAAO,CAAC,GAAG,MAAM,MAAM,CAAC,EACxB,OAAO,CAAC,SAAS,EAAE,GAAG,IAAI,MAAM,QAAQ,IAAI,IAAI,IAAI,GAAG,CAAC,GAAG,MAAM,IAAI,CAAC;MACzE;AACA,aAAO,IAAI,IAAI,IAAI,IAAI,WAAW,CAAC;IACpC,GAAG,MAAM,KAAK,CAAC;AAEf,UAAM,WAAW,YAAY,OAAO,CAAC,SAAS,EAAE,EAAE,MAAM,QAAQ,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC;AACnF,WAAO,SAAS,IAAI,QAAQ;EAC7B;;EAGA,SAAS,GAAiB;AACzB,WAAO,KAAK,aACV,WAAW,EACX,OAAO,CAAC,KAAK,gBAAgB,IAAI,IAAI,CAAC,EAAE,IAAI,WAAW,GAAG,MAAM,KAAK,CAAC;EACzE;EAEA,OAAO,OAA4B;AAClC,QAAI,KAAK,aAAa,WAAW,MAAM,aAAa,QAAQ;AAC3D,aAAO;IACR;AACA,WAAO,KAAK,aAAa,MAAM,CAAC,GAAG,MAAM,EAAE,OAAO,MAAM,eAAe,CAAC,CAAC,CAAC;EAC3E;AACD;AAQA,SAAS,gBAAgB,OAA6B;AACrD,SAAO;IACN,OAAO,IAAI,MAAM,MAAM,KAAK;IAC5B,OAAO,MAAM,KAAK,MAAM,OAAO,CAAC,SAAS,IAAI,MAAM,IAAI,CAAC;EACzD;AACD;AAQA,SAAS,QAAQ,eAAqC;AACrD,SAAO;IACN,OAAO,cAAc,MAAM;IAC3B,OAAO,IAAI,WAAW,cAAc,MAAM,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC;EACpE;AACD;AASA,SAAS,iBAAiB,UAAiB,QAA4B;AACtE,QAAM,qBAAqB,IAAI,WAAW,MAAM;AAChD,SAAO,gBAAgB,kBAAkB;AAGzC,SAAO,WAAW,UAAU,IAAI,WAAW,CAAC,SAAS,OAAO,GAAG,kBAAkB,CAAC,CAAC;AACpF;AAUO,SAASC,OAAM,QAAoB,WAAmB,OAAwB;AACpF,MAAI,YAAY,SAAS,YAAY,KAAK,SAAS,YAAY;AAC9D,UAAM,IAAI,MAAM,qBAAqB,SAAS,aAAa,KAAK,EAAE;EACnE;AAEA,QAAM,cAAc,MAAM,KAAK,QAAQ,CAAC,MAAM,iBAAiB,IAAI,MAAM,CAAC,GAAG,YAAY,CAAC,CAAC;AAC3F,SAAO,MAAM,KAAK,EAAE,QAAQ,MAAM,GAAG,CAAC,GAAG,MAAM;AAE9C,UAAM,QAAQ,IAAI,MAAM,IAAI,CAAC;AAC7B,UAAM,QAAQ,YAAY,IAAI,CAAC,MAAM,EAAE,SAAS,KAAK,CAAC;AACtD,WAAO,QAAQ,EAAE,OAAO,MAAM,CAAC;EAChC,CAAC;AACF;AAGA,SAAS,eAAe,QAAsE;AAC7F,MAAI,OAAO,SAAS,GAAG;AACtB,UAAM,IAAI,MAAM,gCAAgC;EACjD;AAEA,MAAI,CAAC,SAAS,OAAO,IAAI,CAAC,EAAE,MAAM,MAAM,MAAM,MAAM,CAAC,GAAG;AACvD,UAAM,IAAI,MAAM,sCAAsC;EACvD;AAEA,MAAI,cAAc,OAAO,IAAI,CAAC,EAAE,MAAM,MAAM,KAAK,CAAC,GAAG;AACpD,UAAM,IAAI,MAAM,iCAAiC;EAClD;AAEA,QAAM,iBAAiB,OAAO,IAAI,eAAe;AACjD,QAAM,SAAS,eAAe,CAAC,EAAE,MAAM;AAEvC,SAAO,EAAE,gBAAgB,OAAO;AACjC;AASO,SAAS,QAAQ,QAA0C;AACjE,QAAM,EAAE,gBAAgB,OAAO,IAAI,eAAe,MAAM;AAExD,SAAO,IAAI;IACV,MAAM;MACL,EAAE,OAAO;MACT,CAAC,GAAG,MACH,WAAW;QACV,eAAe,IAAI,CAAC,EAAE,OAAO,MAAM,OAAO;UACzC,GAAG;UACH,GAAG,MAAM,CAAC;QACX,EAAE;MACH,EAAE;IACJ;EACD;AACD;AAQO,SAAS,YAAY,QAA4C;AACvE,QAAM,EAAE,gBAAgB,OAAO,IAAI,eAAe,MAAM;AAExD,QAAM,cAAc,MAAM;IAAK,EAAE,OAAO;IAAG,CAAC,GAAG,MAC9C,WAAW,YAAY,eAAe,IAAI,CAAC,EAAE,OAAO,MAAM,OAAO,EAAE,GAAG,OAAO,GAAG,MAAM,CAAC,EAAE,EAAE,CAAC;EAC7F;AAEA,SAAO,CAAC,MAAc;AACrB,WAAO,IAAI,WAAW,YAAY,IAAI,CAAC,MAAM,EAAE,SAAS,IAAI,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC;EAC7E;AACD;;;ACpVA,eAAsB,QAAQ;EAC7B;EACA;EACA;EACA;AACD,GAAwC;AACvC,MAAI,CAAC,gBAAgB,gBAAgB,uBAAuB;AAC3D,UAAM,IAAI,wBAAwB,+BAA+B;EAClE;AAEA,QAAM,SAAS,aAAa,gBAAgB,WAAW,gBAAgB,EAAE;AAGzE,QAAM,aAAa,gBAAgB,SACjC,IAAI,CAAC,GAAG,MAAM,CAAC,EACf,OAAO,CAAC,MAAM,KAAK,IAAI,GAAG,MAAM,IAAI,gBAAgB,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;AAEvE,MAAI,WAAW,SAAS,gBAAgB,WAAW;AAClD,UAAM,IAAI,MAAM,4CAA4C;EAC7D;AAEA,QAAM,kBAAkB,gBAAgB,gBAAgB,sBAAsB;AAC9E,MAAI,gBAAgB,WAAW,gBAAgB,SAAS,QAAQ;AAC/D,UAAM,IAAI;MACT,qBAAqB,gBAAgB,MAAM,iBAAiB,gBAAgB,SAAS,MAAM;IAC5F;EACD;AAEA,QAAM,QAAQ,UAAU,UAAU,gBAAgB,gBAAgB,sBAAsB,KAAK;AAG7F,QAAM,SAAS,WAAW,IAAI,CAAC,MAAM;AACpC,UAAM,CAAC,UAAU,KAAK,IAAI,gBAAgB,SAAS,CAAC;AAEpD,UAAM,QAAQ,8BAA8B;MAC3C;MACA,KAAK,IAAI,GAAG,MAAM,IAAI,QAAQ,EAAE;MAChC,gBAAgB,CAAC;MACjB,QAAQ,MAAM;MACd,CAAC,UAAU,KAAK;IACjB;AACA,WAAO,EAAE,OAAO,MAAM;EACvB,CAAC;AAGD,QAAM,UAAU,QAAQ,MAAM;AAG9B,QAAM,gBAAgB;IACrB,WAAW;IACX;IACA;IACA,gBAAgB;IAChB,gBAAgB,SAAS,IAAI,CAAC,CAAC,WAAW,CAAC,MAAM,SAAS;EAC3D;AACA,QAAM,aAAa;IAClB,gBAAgB,gBAAgB,sBAAsB;IACtD;EACD;AAGA,MAAI,EAAE,kBAAkB,kBAAkB,OAAO,UAAU,IAAI,YAAY,OAAO,UAAU,IAAI;AAC/F,UAAM,IAAI,uBAAuB,eAAe;EACjD;AAGA,QAAM,wBAAwB,eAAe;AAC7C,MAAI,uBAAuB;AAC1B,UAAM,aAAa,YAAY,MAAM;AACrC,UAAM,YAAY,8BAA8B;MAC/C;MACA;MACA,gBAAgB;MAChB;MACA;MACA,QAAQ,MAAM;IACf;AACA,QAAI,UAAU,KAAK,CAAC,EAAE,OAAO,MAAM,MAAM,CAAC,OAAO,WAAW,KAAK,GAAG,KAAK,CAAC,GAAG;AAC5E,YAAM,IAAI,uBAAuB,gBAAgB;IAClD;EACD;AAGA,QAAM,SAAS;IACd,WAAW;IACX;IACA;IACA,gBAAgB;IAChB,gBAAgB,SAAS,IAAI,CAAC,CAAC,UAAU,CAAC,MAAM,QAAQ;EACzD;AAGA,MAAI,gBAAgB,WAAW,WAAW;AACzC,WAAO,UAAU,QAAQ,QAAQ,gBAAgB,UAAU;EAC5D,WAAW,gBAAgB,WAAW,YAAY;AACjD,WAAO,WAAW,QAAQ,QAAQ,gBAAgB,UAAU;EAC7D,WAAW,gBAAgB,WAAW,OAAO;AAE5C,WAAO;EACR,OAAO;AACN,UAAM,IAAI,uBAAuB,yBAAyB;EAC3D;AACD;;;ACjHA,eAAsB,QAAQ;EAC7B;EACA;EACA;EACA;EACA;EACA;AACD,GAUG;AAEF,MACC,aAAa,KACb,YAAY,UACZ,WAAW,SAAS,aACpB,WAAW,SAAS,QACnB;AACD,UAAM,IAAI;MACT,oCAAoC,SAAS,QAAQ,WAAW,MAAM,4BAA4B,SAAS;IAC5G;EACD;AAGA,QAAM,UAAU,MAAM,gBAAgB,YAAY;AAGlD,QAAM,SAASC,OAAM,SAAS,WAAW,WAAW,MAAM;AAG1D,QAAM,SAAS,aAAa,WAAW,EAAE;AACzC,QAAM,kBAAkB;IACvB;IACA;IACA,QAAQ,MAAM;IACd;IACA;IACA;EACD;AAGA,QAAM,SAAS;IACd,WAAW;IACX;IACA,gBAAgB,sBAAsB;IACtC;IACA,WAAW,IAAI,CAAC,EAAE,SAAS,MAAM,QAAQ;EAC1C;AACA,QAAM,aAAa,MAAM,gBAAgB,QAAQ,MAAM;AAGvD,QAAM,WAA+B,WAAW,IAAI,CAAC,EAAE,SAAS,GAAG,MAAM;IACxE;IACA,OAAO,CAAC,EAAE;EACX,CAAC;AAED,SAAO;IACN,iBAAiB,gBAAgB,UAAU;MAC1C,SAAS;MACT;MACA;MACA;MACA;MACA;MACA;IACD,CAAC,EAAE,QAAQ;IACX,KAAK;EACN;AACD;AAEO,IAAK,WAAL,CAAKC,aAAL;AACNA,WAAAA,SAAA,6BAAA,IAA8B,CAAA,IAA9B;AADW,SAAAA;AAAA,GAAA,WAAA,CAAA,CAAA;AAIL,IAAK,WAAL,CAAKC,aAAL;AACNA,WAAAA,SAAA,WAAA,IAAY,CAAA,IAAZ;AACAA,WAAAA,SAAA,YAAA,IAAa,CAAA,IAAb;AAFW,SAAAA;AAAA,GAAA,WAAA,CAAA,CAAA;AAKZ,SAAS,eACR,YACA,SACA,IACA,QACA,SACA,WACmC;AACnC,UAAQ,SAAS;IAChB,KAAK;AACJ,aAAO,IAAI,8BAA8B,UAAU,EAAE;QACpD;QACA;QACA;QACA;MACD;IACD;AACC,YAAM,IAAI,MAAM,oBAAoB,OAAO,EAAE;EAC/C;AACD;;;AChIO,IAAM,kBAAkB;;;ACMxB,SAAS,eAAe,IAAgB,CAAC,IAAI,EAAE,GAAyC;AAC9F,SAAOC,SAAQ,OAAO,UAAU,EAAE,GAAG;IACpC,UAAU,UAAU,EAAE;IACtB,UAAU,UAAU,EAAE;EACvB,CAAC,EAAE,QAAQ;AACZ;AAMA,SAASA,SAAQ,IAAY,CAAC,IAAI,EAAE,GAAsC;AACzE,SAAO,GAAG,SAAS,GAAG,SAAS,EAAE,CAAC;AACnC;AAGO,SAAS,oBAA6C;AAC5D,SAAO,OAAO,OAAO,EAAE,QAAQ;AAChC;AAGO,SAAS,YAAY,IAAsD;AACjF,SAAO,UAAU,UAAU,EAAE,SAAS,OAAO,UAAU,EAAE,CAAC,EAAE,QAAQ;AACrE;AAGO,SAAS,kBAAkB,IAAsD;AACvF,SAAO,UAAU,UAAU,EAAE,SAAS,OAAO,UAAU,EAAE,CAAC,EAAE,QAAQ;AACrE;;;ACxBA,IAAM,0BAA0B;AAUzB,IAAK,iBAAL,CAAKC,mBAAL;AACNA,iBAAAA,eAAA,uBAAA,IAAwB,CAAA,IAAxB;AADW,SAAAA;AAAA,GAAA,iBAAA,CAAA,CAAA;AAIL,IAAM,6BAA6B,IAAI,QAAQ,OAAO;AAU7D,eAAsB,mBAAmB;EACxC;EACA;AACD,GAGyB;AACxB,SAAO,MAAM,QAAQ;IACpB,UAAU,IAAI,OAAO,aAAa;AAEjC,YAAM,MAAM,MAAM,OAAO,KAAK,UAAU;QACvC;MACD,CAAC;AACD,YAAM,KAAK,cAAc,MAAM,MAAM,IAAI,OAAO,OAAO;AACvD,UACC,0BAA0B,OAAO,GAAG,YAAY,KAChD,0BAA0B,OAAO,GAAG,WAAW,GAC9C;AACD,cAAM,IAAI;UACT,cAAc,QAAQ,8BAA8B,GAAG,YAAY,QAAQ,GAAG,WAAW,yCAAyC,uBAAuB;QAC1J;MACD;AAGA,YAAM,iBAAiB,MAAM,OAAO,KAAK,gBAAgB;QACxD,UAAU;QACV,MAAM;UACL,MAAM;UACN,KAAK,IAAI,IAAI,EAAE,UAAU,uBAAuB,EAAE,QAAQ;QAC3D;MACD,CAAC;AAED,YAAM,cAAc,gBAAgB,MAAM,eAAe,aAAa,MAAM,GAAG;AAE/E,UAAI,YAAY,YAAY,GAAqC;AAChE,cAAM,IAAI;UACT,UAAU,QAAQ,0BAA0B,YAAY,OAAO;QAChE;MACD;AAEA,aAAO;QACN;QACA,MAAM,YAAY;QAClB,KAAK,YAAY;QACjB,SAAS,YAAY;QACrB,IAAI,IAAI,WAAW,YAAY,EAAE;MAClC;IACD,CAAC;EACF;AACD;AAUA,eAAsB,gBACrB,QACA,SACA,YACA,QACmB;AACnB,QAAM,YAAY,OAAO,WAAW;AACpC,QAAM,WAAW,MAAM,MAAM,OAAO,MAAO,4BAA4B,OAAO,UAAU;IACvF,QAAQ;IACR,SAAS;MACR,gBAAgB;MAChB,cAAc;MACd,mBAAmB;MACnB,sBAAsB;MACtB,GAAI,cAAc,SAAS,EAAE,CAAC,UAAU,GAAG,OAAO,IAAI,CAAC;IACxD;IACA,QAAQ,YAAY,QAAQ,OAAO;EACpC,CAAC;AAED,QAAM,aAAa,eAAe,UAAU,SAAS;AACrD,yBAAuB,QAAQ;AAC/B,QAAM,kBAAkB,MAAM,SAAS,KAAK;AAE5C,MAAI,gBAAgB,eAAe,OAAO,UAAU;AACnD,WAAO;EACR;AACA,QAAM,UAAU,QAAQ,CAAC,SAAS,OAAO,IAAI,QAAQ,OAAO,QAAQ,CAAC,CAAC;AACtE,SAAO,UAAU,qBAAqB,WAAW,gBAAgB,GAAG,GAAG,SAAS,OAAO,EAAE;AAC1F;AAOO,SAAS,uBAAuB,UAAoB;AAC1D,QAAM,mBAAmB,SAAS,QAAQ,IAAI,qBAAqB;AACnE,MAAI,oBAAoB,MAAM;AAC7B,UAAM,IAAI,6BAA6B,8BAA8B;EACtE;AACA,MAAI,IAAI,QAAQ,gBAAgB,EAAE,WAAW,0BAA0B,GAAG;AACzE,UAAM,IAAI;MACT,sBAAsB,gBAAgB;IACvC;EACD;AACD;AAUO,IAAM,kCAAN,MAA4D;EAGlE,YAAmB,KAAgB;AAAhB,SAAA,MAAA;AAClB,SAAK,iBAAiB,MAAM,IAAI,QAAQ,CAAC;EAC1C;EAEA,WAAmB;AAClB,WAAO,KAAK;EACb;AACD;AA0CA,eAAsB,mBAAmB;EACxC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACD,GAAkF;AACjF,QAAM,OAAO;IACZ,KAAK,SAAS,iBAAiB,MAAM,CAAC,CAAC;;IACvC,SAAS,SAAS,QAAQ;IAC1B,sBAAsB,SAAS,kBAAkB;IACjD,mBAAmB;;IACnB;EACD;AAEA,QAAM,gBAAgB,YAAY,QAAQ,OAAO;AACjD,QAAM,iBAAiB,SAAS,YAAY,IAAI,CAAC,QAAQ,aAAa,CAAC,IAAI;AAE3E,QAAM,YAAY,OAAO,WAAW;AACpC,QAAM,WAAW,MAAM,MAAM,MAAM,iBAAiB;IACnD,QAAQ;IACR,SAAS;MACR,gBAAgB;MAChB,cAAc;MACd,mBAAmB;MACnB,sBAAsB;MACtB,GAAI,cAAc,SAAS,EAAE,CAAC,UAAU,GAAG,OAAO,IAAI,CAAC;IACxD;IACA,MAAM,KAAK,UAAU,IAAI;IACzB,QAAQ;EACT,CAAC;AACD,QAAM,aAAa,eAAe,UAAU,SAAS;AACrD,QAAM,OAAO,MAAM,SAAS,KAAK;AACjC,yBAAuB,QAAQ;AAE/B,SAAO,KAAK,gBAAgB;IAC3B,CAAC,QAA0E;MAC1E,QAAQ,MAAM,GAAG,EAAE;MACnB,KAAK,eAAe,QAAQ,GAAG,cAAc,IAAI,UAAU,CAA6B;IACzF;EACD;AACD;;;;;;;;;;;AC5PA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAoDO,IAAM,cAAN,MAAMC,aAAW;EAWvB,YAAY,SAA4B;AAXlC,IAAAC,cAAA,MAAA,qBAAA;AACN,IAAAA,cAAA,MAAA,UAAA;AACA,IAAAA,cAAA,MAAA,QAAA;AACA,IAAAA,cAAA,MAAA,aAAsD,IAAA;AACtD,IAAAA,cAAA,MAAA,iBAAA;AAEA,IAAAA,cAAA,MAAA,aAAc,oBAAI,IAA4B,CAAA;AAC9C,IAAAA,cAAA,MAAA,mBAAoB,oBAAI,IAAuB,CAAA;AAC/C,IAAAA,cAAA,MAAA,QAAA;AACA,IAAAA,cAAA,MAAA,YAAA;AAGC,iBAAA,MAAK,YAAa,QAAQ,SAAA;AAE1B,QACC,IAAI,IAAI,QAAQ,cAAc,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE,SAAS,QAAQ,cAAc,QACpF;AACD,YAAM,IAAI,0BAA0B,sBAAsB;IAC3D;AAEA,QACC,QAAQ,cAAc,KAAK,CAAC,MAAO,EAAE,cAAc,CAAC,EAAE,UAAY,CAAC,EAAE,cAAc,EAAE,MAAO,GAC3F;AACD,YAAM,IAAI;QACT;MACD;IACD;AAEA,iBAAA,MAAK,UAAW,IAAI,IAAI,QAAQ,cAAc,IAAI,CAAC,WAAW,CAAC,OAAO,UAAU,MAAM,CAAC,CAAC,CAAA;AACxF,iBAAA,MAAK,cAAe,QAAQ,cAC1B,IAAI,CAAC,WAAW,OAAO,MAAM,EAC7B,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC,CAAA;AAErC,iBAAA,MAAK,mBAAoB,QAAQ,oBAAoB,IAAA;AACrD,iBAAA,MAAK,UAAW,QAAQ,WAAW,GAAA;EACpC;;EAGA,OAAO,kBAAkB,SAAqC;AAC7D,WAAO;MACN,MAAM;MACN,UAAU,CAAC,WAAiC;AAC3C,eAAO,IAAID,aAAW;UACrB,WAAW;UACX,GAAG;QACJ,CAAC;MACF;IACD;EACD;;;;;;;;;;;;;;EAeA,MAAM,QAAQ;IACb,UAAU,QAAQ;IAClB,UAAU,QAAQ;IAClB;IACA;IACA;IACA;IACA,MAAM,IAAI,WAAW;EACtB,GAAmB;AAClB,UAAM,aAAa,MAAM,aAAA,MAAK,UAAA,EAAW,KAAK,UAAU,EAAE,UAAU,UAAU,CAAC;AAC/E,QAAI,OAAO,WAAW,OAAO,OAAO,MAAM,KAAK;AAC9C,YAAM,IAAI,oBAAoB,WAAW,SAAS,2BAA2B;IAC9E;AAEA,WAAO,QAAQ;MACd,YAAY,MAAME,iBAAA,MAAK,uBAAA,wBAAA,EAAL,KAAA,IAAA;MAClB;MACA;MACA;MACA;MACA,iBAAiBA,iBAAA,MAAK,uBAAA,wBAAA,EAAL,KAAA,MAChB,SACA,MACA,GAAA;IAEF,CAAC;EACF;;;;;;;;;;;;;;;;;;;EAiCA,MAAM,QAAQ;IACb;IACA;IACA;IACA;IACA;EACD,GAAmB;AAClB,UAAM,kBAAkB,gBAAgB,MAAM,IAAI;AAElD,IAAAA,iBAAA,MAAK,uBAAA,6BAAA,EAAL,KAAA,MACC,gBAAgB,SAAS,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,GACxC,gBAAgB,SAAA;AAGjB,UAAM,KAAK,UAAU;MACpB,KAAK,CAAC,gBAAgB,EAAE;MACxB;MACA;MACA,WAAW,gBAAgB;IAC5B,CAAC;AAED,QAAI,uBAAuB;AAC1B,YAAM,aAAa,MAAM,KAAK;QAC7B,gBAAgB,SAAS,IAAI,CAAC,CAAC,UAAU,CAAC,MAAM,QAAQ;MACzD;AACA,aAAO,QAAQ;QACd;QACA,MAAM,aAAA,MAAK,WAAA;QACX;QACA,iBAAiB;;MAClB,CAAC;IACF;AACA,WAAO,QAAQ,EAAE,iBAAiB,MAAM,aAAA,MAAK,WAAA,GAAa,gBAAgB,CAAC;EAC5E;EA0BA,MAAM,gBAAiD;AACtD,QAAI,CAAC,aAAA,MAAK,WAAA,GAAa;AACtB,mBAAA,MAAK,aAAcA,iBAAA,MAAK,uBAAA,iBAAA,EAAL,KAAA,IAAA,EAAuB,MAAM,CAAC,UAAU;AAC1D,qBAAA,MAAK,aAAc,IAAA;AACnB,cAAM;MACP,CAAC,CAAA;IACF;AACA,WAAO,aAAA,MAAK,WAAA;EACb;;;;;;;;EASA,MAAM,cAAc,UAA0C;AAC7D,UAAM,aAAa,MAAM,KAAK,cAAc;AAG5C,UAAM,oBAAoB,SAAS;MAClC,CAAC,aAAa,CAAC,WAAW,IAAI,QAAQ,KAAK,CAAC,aAAA,MAAK,iBAAA,EAAkB,IAAI,QAAQ;IAChF;AAGA,QAAI,kBAAkB,SAAS,GAAG;AACjC,OACC,MAAM,mBAAmB;QACxB,WAAW;QACX,QAAQ,aAAA,MAAK,UAAA;MACd,CAAC,GACA;QAAQ,CAAC,cACV,aAAA,MAAK,iBAAA,EAAkB,IAAI,UAAU,UAAU,UAAU,UAAU,UAAU,EAAE,CAAC;MACjF;IACD;AAEA,WAAO,SAAS,IAAI,CAAC,aAAa;AACjC,YAAM,YAAY,WAAW,IAAI,QAAQ;AACzC,UAAI,WAAW;AACd,eAAO,UAAU,UAAU,UAAU,EAAE;MACxC;AACA,aAAO,aAAA,MAAK,iBAAA,EAAkB,IAAI,QAAQ;IAC3C,CAAC;EACF;;;;;;;;;;;;;EAqDA,MAAM,UAAU,EAAE,KAAK,SAAS,YAAY,UAAU,GAAqB;AAC1E,QAAI,YAAY,aAAA,MAAK,YAAA,KAAgB,YAAY,GAAG;AACnD,YAAM,IAAI;QACT,qBAAqB,SAAS,yBAAyB,KAAK,UAAU,aAAA,MAAK,QAAA,CAAQ,CAAC;MACrF;IACD;AACA,UAAM,aAAa,MAAM,KAAK,cAAc;AAC5C,UAAM,UAAU,IAAI,IAAI,CAAC,OAAO,aAAa,WAAW,aAAa,GAAG,EAAE,CAAC;AAI3E,QAAI,kBAAkB;AACtB,UAAM,sBAAsB,CAAC;AAC7B,QAAI,4BAA4B;AAChC,eAAW,YAAY,WAAW,KAAK,GAAG;AACzC,UAAI,QAAQ,MAAM,CAAC,WAAW,aAAA,MAAK,WAAA,EAAY,IAAI,GAAG,MAAM,IAAI,QAAQ,EAAE,CAAC,GAAG;AAC7E,2BAAmBA,iBAAA,MAAK,uBAAA,SAAA,EAAL,KAAA,MAAa,QAAA;MACjC,OAAO;AACN,4BAAoB,KAAK,QAAQ;AACjC,qCAA6BA,iBAAA,MAAK,uBAAA,SAAA,EAAL,KAAA,MAAa,QAAA;MAC3C;IACD;AAGA,QAAI,mBAAmB,WAAW;AACjC;IACD;AAEA,UAAM,cAAc,MAAM,WAAW,eAAe;AACpD,UAAM,gBAAgB,MAAM,WAAW,oBAAoB,OAAO;AAElE,UAAM,aAAa,IAAI,gBAAgB;AACvC,UAAM,SAAkB,CAAC;AAEzB,UAAM,aAAa,oBAAoB,IAAI,OAAO,aAAa;AAC9D,YAAM,SAAS,WAAW,IAAI,QAAQ;AACtC,UAAI;AACH,cAAM,SAAS,aAAA,MAAK,QAAA,EAAS,IAAI,QAAQ;AACzC,cAAM,UAAU,MAAM,mBAAmB;UACxC,KAAK,OAAO;UACZ,kBAAkB,cAAc;UAChC,kBAAkB;UAClB,QAAQ,cAAc;UACtB,UAAU,cAAc;UACxB,oBAAoB,cAAc;UAClC;UACA,SAAS,aAAA,MAAK,QAAA;UACd,YAAY,iCAAQ;UACpB,QAAQ,iCAAQ;UAChB,QAAQ,WAAW;QACpB,CAAC;AAED,mBAAW,EAAE,QAAQ,IAAI,KAAK,SAAS;AACtC,gBAAM,aAAa,UAAU,UAAU,GAAG;AAC1C,cACC,CAAC,8BAA8B;YAC9B;YACA;YACA,UAAU,UAAU,OAAO,EAAE;UAC9B,GACC;AACD,oBAAQ,KAAK,0CAA0C,OAAO,QAAQ;AACtE;UACD;AACA,uBAAA,MAAK,WAAA,EAAY,IAAI,GAAG,MAAM,IAAI,OAAO,QAAQ,IAAI,UAAU;QAChE;AAIA,YAAI,QAAQ,MAAM,CAAC,WAAW,aAAA,MAAK,WAAA,EAAY,IAAI,GAAG,MAAM,IAAI,OAAO,QAAQ,EAAE,CAAC,GAAG;AACpF,6BAAmBA,iBAAA,MAAK,uBAAA,SAAA,EAAL,KAAA,MAAa,QAAA;AAGhC,cAAI,mBAAmB,WAAW;AACjC,uBAAW,MAAM;UAClB;QACD;MACD,SAAS,OAAO;AACf,YAAI,CAAC,WAAW,OAAO,SAAS;AAC/B,iBAAO,KAAK,KAAc;QAC3B;MACD,UAAA;AAEC,qCAA6BA,iBAAA,MAAK,uBAAA,SAAA,EAAL,KAAA,MAAa,QAAA;AAC1C,YAAI,4BAA4B,YAAY,iBAAiB;AAC5D,qBAAW,MAAM,IAAI,mCAAmC,CAAC;QAC1D;MACD;IACD,CAAC;AAED,UAAM,QAAQ,WAAW,UAAU;AAEnC,QAAI,kBAAkB,WAAW;AAChC,YAAM,gBAAgB,MAAM;IAC7B;EACD;;;;;;;;;;EAWA,MAAM,eAAe;IACpB,UAAU,QAAQ;IAClB;IACA;IACA;IACA;EACD,GAA4D;AAC3D,YAAQ,SAAS;MAChB,KAAK,QAAQ;AACZ,cAAM,aAAa,MAAM,KAAK,cAAc;AAC5C,YAAI,YAAY,aAAA,MAAK,YAAA,GAAc;AAClC,gBAAM,IAAI;YACT,qBAAqB,SAAS,QAAQ,aAAA,MAAK,YAAA,CAAY;UACxD;QACD;AACA,cAAM,KAAK,UAAU;UACpB,KAAK,CAAC,EAAE;UACR;UACA;UACA;QACD,CAAC;AAKD,cAAM,SAAS,aAAa,WAAW,aAAa,GAAG,EAAE;AAEzD,cAAM,cAAc,oBAAI,IAAI;AAC5B,YAAI,SAAS;AACb,mBAAW,YAAY,WAAW,KAAK,GAAG;AAEzC,gBAAM,YAAY,aAAA,MAAK,WAAA,EAAY,IAAI,GAAG,MAAM,IAAI,QAAQ,EAAE;AAC9D,cAAI,WAAW;AACd,wBAAY,IAAI,UAAU,IAAI,gCAAgC,SAAS,CAAC;AACxE,sBAAUA,iBAAA,MAAK,uBAAA,SAAA,EAAL,KAAA,MAAa,QAAA;AACvB,gBAAI,UAAU,WAAW;AAExB;YACD;UACD;QACD;AACA,eAAO;IACT;EACD;AACD;AA3aC,aAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AACA,cAAA,oBAAA,QAAA;AACA,oBAAA,oBAAA,QAAA;AAEA,cAAA,oBAAA,QAAA;AACA,oBAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AACA,eAAA,oBAAA,QAAA;AATM,wBAAA,oBAAA,QAAA;AA2FN,2BAAsB,SACrB,MACA,MACA,KACkB;AAClB,UAAQ,MAAM;IACb,KAAK,QAAQ;AACZ,aAAO,IAAI,UAAU,MAAM,GAAG;IAC/B,KAAK,QAAQ;AACZ,aAAO,IAAI,WAAW,MAAM,GAAG;EACjC;AACD;AAuDA,YAAO,SAAC,UAAkB;;AACzB,WAAO,kBAAA,MAAK,QAAA,EAAS,IAAI,QAAQ,MAA1B,mBAA6B,WAAU;AAC/C;AAEA,gCAA2B,SAAC,UAAoB,WAAmB;AAElE,MACC,SAAS,KAAK,CAAC,aAAa;AAC3B,UAAM,gBAAgBA,iBAAA,MAAK,uBAAA,SAAA,EAAL,KAAA,MAAa,QAAA;AACnC,WAAO,gBAAgB,KAAK,kBAAkB,MAAM,UAAU,QAAQ;EACvE,CAAC,GACA;AACD,UAAM,IAAI;MACT;IACD;EACD;AAEA,MAAI,YAAY,aAAA,MAAK,YAAA,GAAc;AAClC,UAAM,IAAI;MACT,qBAAqB,SAAS,QAAQ,aAAA,MAAK,YAAA,CAAY;IACxD;EACD;AACD;AAoDM,2BAAsB,iBAAG;AAC9B,QAAM,aAAa,MAAM,KAAK,cAAc;AAC5C,QAAM,6BAA6B,CAAC;AACpC,aAAW,CAAC,UAAU,MAAM,KAAK,aAAA,MAAK,QAAA,GAAU;AAC/C,UAAM,YAAY,WAAW,IAAI,QAAQ;AACzC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,iCAA2B,KAAK,SAAS;IAC1C;EACD;AACA,SAAO;AACR;AAEM,oBAAe,iBAAoC;AACxD,QAAM,aAAa,MAAM,mBAAmB;IAC3C,WAAW,CAAC,GAAG,aAAA,MAAK,QAAA,CAAQ,EAAE,IAAI,CAAC,CAAC,QAAQ,MAAM,QAAQ;IAC1D,QAAQ,aAAA,MAAK,UAAA;EACd,CAAC;AAED,MAAI,WAAW,WAAW,GAAG;AAC5B,UAAM,IAAI,sBAAsB,sBAAsB;EACvD;AAEA,MAAI,aAAA,MAAK,iBAAA,GAAmB;AAC3B,UAAM,QAAQ;MACb,WAAW,IAAI,OAAO,WAAW;AAChC,cAAM,SAAS,aAAA,MAAK,QAAA,EAAS,IAAI,OAAO,QAAQ;AAChD,YAAI,CAAE,MAAM,gBAAgB,QAAQ,aAAA,MAAK,QAAA,GAAU,iCAAQ,YAAY,iCAAQ,MAAM,GAAI;AACxF,gBAAM,IAAI,sBAAsB,cAAc,OAAO,QAAQ,eAAe;QAC7E;MACD,CAAC;IACF;EACD;AACA,SAAO,IAAI,IAAI,WAAW,IAAI,CAAC,WAAW,CAAC,OAAO,UAAU,MAAM,CAAC,CAAC;AACrE;AAxQM,IAAM,aAAN;;;ACZP,IAAM,kBAA2C;EAC/C,GAAG,OAAO,oEAAoE;EAC9E,GAAG,OAAO,oEAAoE;EAC9E,GAAG,OAAO,CAAC;EACX,GAAG,OAAO,CAAC;EACX,GAAG,OAAO,CAAC;EACX,IAAI,OAAO,oEAAoE;EAC/E,IAAI,OAAO,oEAAoE;;AAGjF,IAAM,iBAAmC;EACvC,MAAM,OAAO,oEAAoE;EACjF,SAAS;IACP,CAAC,OAAO,oCAAoC,GAAG,CAAC,OAAO,oCAAoC,CAAC;IAC5F,CAAC,OAAO,qCAAqC,GAAG,OAAO,oCAAoC,CAAC;;;AAIhG,IAAMC,OAAsB,OAAO,CAAC;AACpC,IAAMC,OAAsB,OAAO,CAAC;AACpC,IAAMC,OAAsB,OAAO,CAAC;AAMpC,SAAS,QAAQ,GAAS;AACxB,QAAM,IAAI,gBAAgB;AAE1B,QAAMC,OAAM,OAAO,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,OAAO,OAAO,EAAE,GAAG,OAAO,OAAO,EAAE;AAE3E,QAAM,OAAO,OAAO,EAAE,GAAG,OAAO,OAAO,EAAE,GAAG,OAAO,OAAO,EAAE;AAC5D,QAAM,KAAM,IAAI,IAAI,IAAK;AACzB,QAAM,KAAM,KAAK,KAAK,IAAK;AAC3B,QAAM,KAAM,KAAK,IAAIA,MAAK,CAAC,IAAI,KAAM;AACrC,QAAM,KAAM,KAAK,IAAIA,MAAK,CAAC,IAAI,KAAM;AACrC,QAAM,MAAO,KAAK,IAAID,MAAK,CAAC,IAAI,KAAM;AACtC,QAAM,MAAO,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,MAAO,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,MAAO,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,OAAQ,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AAC1C,QAAM,OAAQ,KAAK,MAAM,MAAM,CAAC,IAAI,MAAO;AAC3C,QAAM,OAAQ,KAAK,MAAMC,MAAK,CAAC,IAAI,KAAM;AACzC,QAAM,KAAM,KAAK,MAAM,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,KAAM,KAAK,IAAI,KAAK,CAAC,IAAI,KAAM;AACrC,QAAM,OAAO,KAAK,IAAID,MAAK,CAAC;AAC5B,MAAI,CAAC,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC;AAAG,UAAM,IAAI,MAAM,yBAAyB;AAC3E,SAAO;AACT;AAEA,IAAM,OAAO,MAAM,gBAAgB,GAAG,QAAW,QAAW,EAAE,MAAM,QAAO,CAAE;AAgBtE,IAAM,YAA+B,YAC1C,EAAE,GAAG,iBAAiB,IAAI,MAAM,MAAM,MAAM,MAAM,eAAc,GAChE,MAAM;AAMR,IAAM,uBAAsD,CAAA;AAC5D,SAAS,WAAWE,SAAgB,UAAsB;AACxD,MAAI,OAAO,qBAAqBA,IAAG;AACnC,MAAI,SAAS,QAAW;AACtB,UAAM,OAAO,OAAO,WAAW,KAAKA,MAAK,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;AAChE,WAAO,YAAY,MAAM,IAAI;AAC7B,yBAAqBA,IAAG,IAAI;EAC9B;AACA,SAAO,OAAO,YAAY,MAAM,GAAG,QAAQ,CAAC;AAC9C;AAGA,IAAM,eAAe,CAAC,UAA6B,MAAM,QAAQ,IAAI,EAAE,MAAM,CAAC;AAC9E,IAAM,WAAW,CAAC,MAAc,gBAAgB,GAAG,EAAE;AACrD,IAAM,OAAO,CAAC,MAAc,IAAI,GAAG,gBAAgB,CAAC;AACpD,IAAM,OAAO,CAAC,MAAc,IAAI,GAAG,gBAAgB,CAAC;AACpD,IAAM,SAAyB,MAAM,UAAU,OAAM;AACrD,IAAM,UAAU,CAAC,MAAc,IAAIF,SAAQF;AAG3C,SAAS,oBAAoB,MAAa;AAExC,MAAI,KAAK,eAAe,MAAM,IAAI,IAAI;AACtC,MAAI,IAAI,MAAM,KAAK,SAAS,EAAE;AAC9B,QAAM,SAAS,QAAQ,EAAE,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE;AAC3C,SAAO,EAAE,QAAQ,OAAO,aAAa,CAAC,EAAC;AACzC;AAKA,SAAS,OAAO,GAAS;AACvB,WAAS,KAAK,GAAGC,MAAK,gBAAgB,CAAC;AACvC,QAAM,KAAK,KAAK,IAAI,CAAC;AACrB,QAAM,IAAI,KAAK,KAAK,IAAI,OAAO,CAAC,CAAC;AACjC,MAAI,IAAI,QAAQ,CAAC;AACjB,MAAI,CAAC,QAAQ,CAAC;AAAG,QAAI,KAAK,CAAC,CAAC;AAC5B,QAAM,IAAI,MAAM,WAAW,EAAE,GAAG,EAAC,CAAE;AACnC,IAAE,eAAc;AAChB,SAAO;AACT;AACA,IAAM,MAAM;AAIZ,SAAS,aAAa,MAAkB;AACtC,SAAO,KAAK,IAAI,WAAW,qBAAqB,GAAG,IAAI,CAAC,CAAC;AAC3D;AAKA,SAAS,oBAAoB,WAAc;AACzC,SAAO,oBAAoB,SAAS,EAAE;AACxC;AAMA,SAAS,YAAY,SAAc,WAAoB,UAAe,YAAY,EAAE,GAAC;AACnF,QAAM,IAAI,YAAY,WAAW,OAAO;AACxC,QAAM,EAAE,OAAO,IAAI,QAAQ,EAAC,IAAK,oBAAoB,SAAS;AAC9D,QAAM,IAAI,YAAY,WAAW,SAAS,EAAE;AAC5C,QAAM,IAAI,SAAS,IAAI,IAAI,WAAW,eAAe,CAAC,CAAC,CAAC;AACxD,QAAM,OAAO,WAAW,iBAAiB,GAAG,IAAI,CAAC;AACjD,QAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACzB,MAAI,OAAOD;AAAK,UAAM,IAAI,MAAM,wBAAwB;AACxD,QAAM,EAAE,OAAO,IAAI,QAAQ,EAAC,IAAK,oBAAoB,EAAE;AACvD,QAAM,IAAI,UAAU,IAAI,IAAI,CAAC;AAC7B,QAAM,MAAM,IAAI,WAAW,EAAE;AAC7B,MAAI,IAAI,IAAI,CAAC;AACb,MAAI,IAAI,SAAS,KAAK,IAAI,IAAI,CAAC,CAAC,GAAG,EAAE;AAErC,MAAI,CAAC,cAAc,KAAK,GAAG,EAAE;AAAG,UAAM,IAAI,MAAM,kCAAkC;AAClF,SAAO;AACT;AAMA,SAAS,cAAc,WAAgB,SAAc,WAAc;AACjE,QAAM,MAAM,YAAY,aAAa,WAAW,EAAE;AAClD,QAAM,IAAI,YAAY,WAAW,OAAO;AACxC,QAAM,MAAM,YAAY,aAAa,WAAW,EAAE;AAClD,MAAI;AACF,UAAM,IAAI,OAAO,IAAI,GAAG,CAAC;AACzB,UAAM,IAAI,IAAI,IAAI,SAAS,GAAG,EAAE,CAAC;AACjC,QAAI,CAAC,QAAQ,GAAGC,MAAK,gBAAgB,CAAC;AAAG,aAAO;AAChD,UAAM,IAAI,IAAI,IAAI,SAAS,IAAI,EAAE,CAAC;AAClC,QAAI,CAAC,QAAQ,GAAGA,MAAK,gBAAgB,CAAC;AAAG,aAAO;AAChD,UAAM,IAAI,UAAU,SAAS,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC;AAEnD,UAAM,IAAI,MAAM,KAAK,eAAe,CAAC,EAAE,IAAI,EAAE,eAAe,KAAK,CAAC,CAAC,CAAC,CAAC;AACrE,UAAM,EAAE,GAAG,EAAC,IAAK,EAAE,SAAQ;AAE3B,QAAI,EAAE,IAAG,KAAM,CAAC,QAAQ,CAAC,KAAK,MAAM;AAAG,aAAO;AAC9C,WAAO;EACT,SAAS,OAAO;AACd,WAAO;EACT;AACF;AAsCO,IAAM,WAAwC,MAAK;AACxD,QAAM,OAAO;AACb,QAAM,aAAa;AACnB,QAAM,kBAAkB,CAAC,OAAO,YAAY,UAAU,MAAiB;AACrE,WAAO,eAAe,MAAM,gBAAgB,CAAC;EAC/C;AAEA,YAAU,MAAM;AAChB,WAAS,OAAO,MAAiB;AAC/B,UAAM,YAAY,gBAAgB,IAAI;AACtC,WAAO,EAAE,WAAW,WAAW,oBAAoB,SAAS,EAAC;EAC/D;AACA,SAAO;IACL;IACA,cAAc;IACd,MAAM;IACN,QAAQ;IACR;IACA,OAAO;MACL;MACA,kBAAkB;MAClB;;MAGA;MACA;MACA;MACA;MACA;;IAEF,MAAM;MACJ,MAAM;MACN,oBAAoB;MACpB,SAAS;QACP,QAAQ;QACR,QAAQ;QACR,WAAW,OAAO;QAClB,MAAM;;;;AAId,GAAE;AAEF,IAAM,UAA0B,MAC9B,WACE,MACA;;EAEE;IACE;IACA;IACA;IACA;;;EAGF;IACE;IACA;IACA;;;;EAGF;IACE;IACA;IACA;IACA;;;EAGF;IACE;IACA;IACA;IACA;;;EAEF,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC,CAAC,CAA6C,GACjF;AACJ,IAAM,UAA0B,MAC9B,oBAAoB,MAAM;EACxB,GAAG,OAAO,oEAAoE;EAC9E,GAAG,OAAO,MAAM;EAChB,GAAG,KAAK,OAAO,OAAO,KAAK,CAAC;CAC7B,GAAE;AAGE,IAAM,oBAAuD,MAClEI,cACE,UAAU,OACV,CAAC,YAAqB;AACpB,QAAM,EAAE,GAAG,EAAC,IAAK,OAAO,KAAK,OAAO,QAAQ,CAAC,CAAC,CAAC;AAC/C,SAAO,OAAO,GAAG,CAAC;AACpB,GACA;EACE,KAAK;EACL,WAAW;EACX,GAAG,KAAK;EACR,GAAG;EACH,GAAG;EACH,QAAQ;EACR,MAAM;CACP,GACD;AAGG,IAAM,eAAkD,MAC7D,iBAAiB,aAAY;AAGxB,IAAM,iBAAoD,MAC/D,iBAAiB,eAAc;;;AC3VjC,IAAM,4BAA4B;AAK3B,IAAM,qBAAN,cAAiC,UAAU;;;;;EAQjD,YAAY,OAA0B;AACrC,UAAM;AAEN,QAAI,OAAO,UAAU,UAAU;AAC9B,WAAK,OAAO,WAAW,KAAK;IAC7B,WAAW,iBAAiB,YAAY;AACvC,WAAK,OAAO;IACb,OAAO;AACN,WAAK,OAAO,WAAW,KAAK,KAAK;IAClC;AAEA,QAAI,KAAK,KAAK,WAAW,2BAA2B;AACnD,YAAM,IAAI;QACT,sCAAsC,yBAAyB,eAAe,KAAK,KAAK,MAAM;MAC/F;IACD;EACD;;;;EAKS,OAAO,WAAwC;AACvD,WAAO,MAAM,OAAO,SAAS;EAC9B;;;;EAKA,aAAsC;AACrC,WAAO,KAAK;EACb;;;;EAKA,OAAe;AACd,WAAO,yBAAyB,WAAW;EAC5C;;;;EAKA,MAAM,OAAO,SAAqB,WAAkD;AACnF,QAAI;AACJ,QAAI,OAAO,cAAc,UAAU;AAClC,YAAM,SAAS,gCAAgC,SAAS;AACxD,UAAI,OAAO,oBAAoB,aAAa;AAC3C,cAAM,IAAI,MAAM,0BAA0B;MAC3C;AAEA,UAAI,CAAC,WAAW,KAAK,WAAW,GAAG,OAAO,SAAS,GAAG;AACrD,cAAM,IAAI,MAAM,qCAAqC;MACtD;AAEA,cAAQ,OAAO;IAChB,OAAO;AACN,cAAQ;IACT;AAEA,WAAO,UAAU;MAChB,UAAU,UAAU,YAAY,KAAK;MACrCC,QAAO,OAAO;MACd,KAAK,WAAW;IACjB;EACD;AACD;AAzEa,mBACL,OAAO;;;ACTf,IAAM,4BAA4B;AAK3B,IAAM,qBAAN,cAAiC,UAAU;;;;;EAQjD,YAAY,OAA0B;AACrC,UAAM;AAEN,QAAI,OAAO,UAAU,UAAU;AAC9B,WAAK,OAAO,WAAW,KAAK;IAC7B,WAAW,iBAAiB,YAAY;AACvC,WAAK,OAAO;IACb,OAAO;AACN,WAAK,OAAO,WAAW,KAAK,KAAK;IAClC;AAEA,QAAI,KAAK,KAAK,WAAW,2BAA2B;AACnD,YAAM,IAAI;QACT,sCAAsC,yBAAyB,eAAe,KAAK,KAAK,MAAM;MAC/F;IACD;EACD;;;;EAKS,OAAO,WAAwC;AACvD,WAAO,MAAM,OAAO,SAAS;EAC9B;;;;EAKA,aAAsC;AACrC,WAAO,KAAK;EACb;;;;EAKA,OAAe;AACd,WAAO,yBAAyB,WAAW;EAC5C;;;;EAKA,MAAM,OAAO,SAAqB,WAAkD;AACnF,QAAI;AACJ,QAAI,OAAO,cAAc,UAAU;AAClC,YAAM,SAAS,yBAAyB,SAAS;AACjD,UAAI,OAAO,oBAAoB,aAAa;AAC3C,cAAM,IAAI,MAAM,0BAA0B;MAC3C;AAEA,UAAI,CAAC,WAAW,KAAK,WAAW,GAAG,OAAO,SAAS,GAAG;AACrD,cAAM,IAAI,MAAM,qCAAqC;MACtD;AAEA,cAAQ,OAAO;IAChB,OAAO;AACN,cAAQ;IACT;AAEA,WAAO,UAAU;MAChB,UAAU,UAAU,YAAY,KAAK;MACrCC,QAAO,OAAO;MACd,KAAK,WAAW;IACjB;EACD;AACD;AAzEa,mBACL,OAAO;;;;;;;;;;AClBf,IAAA;AAAA,IAAA;AAQO,IAAM,iBAAN,cAA6B,OAAO;EAI1C,YAAY,QAA2B,UAAoB,CAAC,GAAG;;AAC9D,UAAM;AAJP,IAAAC,cAAA,MAAA,OAAA;AACA,IAAAA,cAAA,MAAA,QAAA;AAIC,IAAAC,cAAA,MAAK,SAAU,MAAA;AACf,IAAAA,cAAA,MAAK,UAAW,OAAA;AAEhB,UAAM,aAAa,oBAAI,IAAI;AAC3B,QAAI,iBAAiB;AAErB,UAAM,UAAU,OAAO,cAAc,EAAE,IAAI,CAAC,EAAE,QAAQ,UAAU,OAAO;MACtE;MACA,SAAS,UAAU,aAAa;IACjC,EAAE;AAEF,eAAW,UAAU,SAAS;AAC7B,YAAM,UAAU,OAAO,aAAa;AACpC,UAAI,WAAW,IAAI,OAAO,GAAG;AAC5B,cAAM,IAAI,MAAM,oDAAoD;MACrE;AACA,iBAAW,IAAI,OAAO;AAEtB,YAAM,UAAS,aAAQ,KAAK,CAAC,MAAM,EAAE,YAAY,OAAO,MAAzC,mBAA4C;AAE3D,UAAI,CAAC,QAAQ;AACZ,cAAM,IAAI,MAAM,UAAU,OAAO,yCAAyC;MAC3E;AAEA,wBAAkB;IACnB;AAEA,QAAI,iBAAiB,OAAO,aAAa,GAAG;AAC3C,YAAM,IAAI,MAAM,mDAAmD;IACpE;EACD;EAEA,eAAgC;AAC/B,WAAO;EACR;EAEA,eAAkC;AACjC,WAAOC,cAAA,MAAK,OAAA;EACb;EAEA,KAAK,OAA0B;AAC9B,UAAM,IAAI;MACT;IACD;EACD;;EAGA,SAAS,OAA0B;AAClC,UAAM,IAAI;MACT;IACD;EACD;EAEA,MAAM,gBAAgB,OAAmB;AACxC,UAAM,YAAYA,cAAA,MAAK,OAAA,EAAQ;MAC9B,MAAM,QAAQ;QACbA,cAAA,MAAK,QAAA,EAAS,IAAI,OAAO,YAAY,MAAM,OAAO,gBAAgB,KAAK,GAAG,SAAS;MACpF;IACD;AAEA,WAAO;MACN;MACA,OAAO,SAAS,KAAK;IACtB;EACD;EAEA,MAAM,oBAAoB,OAAmB;AAC5C,UAAM,YAAYA,cAAA,MAAK,OAAA,EAAQ;MAC9B,MAAM,QAAQ;QACbA,cAAA,MAAK,QAAA,EAAS,IAAI,OAAO,YAAY,MAAM,OAAO,oBAAoB,KAAK,GAAG,SAAS;MACxF;IACD;AAEA,WAAO;MACN;MACA,OAAO,SAAS,KAAK;IACtB;EACD;AACD;AAnFC,UAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;;;ACkDM,IAAM,yBAAyB;AAC/B,IAAM,yBAAyB;AAI/B,IAAM,oBAAN,MAAM,2BAA0B,UAAU;;;;EAUhD,YAIC,OACA,UAAgD,CAAC,GAChD;AACD,UAAM;AAEN,QAAI,OAAO,UAAU,UAAU;AAC9B,WAAK,WAAW,WAAW,KAAK;AAEhC,WAAK,oBAAoB,OAAI,kBAAkB,MAAM,KAAK,QAAQ;IACnE,WAAW,iBAAiB,YAAY;AACvC,WAAK,WAAW;AAChB,WAAK,oBAAoB,OAAI,kBAAkB,MAAM,KAAK,QAAQ;IACnE,OAAO;AACN,WAAK,oBAAoB;AACzB,WAAK,WAAW,OAAI,kBAAkB,UAAU,KAAK,EAAE,QAAQ;IAChE;AACA,QAAI,KAAK,kBAAkB,YAAY,GAAG;AACzC,YAAM,IAAI,MAAM,mBAAmB;IACpC;AAEA,UAAM,iBAAiB,oBAAI,IAAY;AAEvC,SAAK,aAAa,KAAK,kBAAkB,OAAO,IAAI,CAAC,EAAE,QAAQ,OAAO,MAAM;AAC3E,YAAM,CAAC,QAAQ,KAAK,IAAI,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,IAAI,MAAM,SAAS,OAAO,EAAE,CAAC;AAIrF,YAAM,eAAe,WAAW,KAAK,KAAK,EAAE,SAAS;AAErD,UAAI,eAAe,IAAI,YAAY,GAAG;AACrC,cAAM,IAAI,MAAM,iDAAiD;MAClE;AACA,qBAAe,IAAI,YAAY;AAE/B,UAAI,SAAS,GAAG;AACf,cAAM,IAAI,MAAM,gBAAgB;MACjC;AAEA,aAAO;QACN,WAAW,sBAAsB,QAAQ,WAAW,KAAK,KAAK,GAAG,OAAO;QACxE;MACD;IACD,CAAC;AAED,UAAM,cAAc,KAAK,WAAW,OAAO,CAAC,KAAK,EAAE,OAAO,MAAM,MAAM,QAAQ,CAAC;AAE/E,QAAI,KAAK,kBAAkB,YAAY,aAAa;AACnD,YAAM,IAAI,MAAM,uBAAuB;IACxC;AAEA,QAAI,KAAK,WAAW,SAAS,wBAAwB;AACpD,YAAM,IAAI,MAAM,0CAA0C,sBAAsB,EAAE;IACnF;AAEA,QAAI,KAAK,WAAW,SAAS,wBAAwB;AACpD,YAAM,IAAI,MAAM,0CAA0C,sBAAsB,EAAE;IACnF;EACD;;;;EAKA,OAAO,eAAe;IACrB;IACA;EACD,GAGG;AACF,WAAO,IAAI,mBAAkB;MAC5B,QAAQ,WAAW,IAAI,CAAC,EAAE,WAAW,OAAO,MAAM;AACjD,cAAM,SAAS,yBAAyB,UAAU,KAAK,CAAkB;AAEzE,eAAO;UACN,QAAQ,EAAE,CAAC,MAAM,GAAG,UAAU,WAAW,EAAE;UAC3C;QACD;MACD,CAAC;MACD;IACD,CAAC;EACF;;;;EAKS,OAAO,WAAuC;AACtD,WAAO,MAAM,OAAO,SAAS;EAC9B;;;;EAKA,aAAsC;AACrC,WAAO,KAAK;EACb;EAEA,gBAAgB;AACf,WAAO,KAAK;EACb;EAEA,eAAe;AACd,WAAO,KAAK,kBAAkB;EAC/B;EAEA,aAAa,SAA2B;AACvC,WAAO,IAAI,eAAe,MAAM,OAAO;EACxC;;;;EAKS,eAAuB;AAE/B,UAAM,YAAY,KAAK,KAAK,KAAK,yBAAyB;AAC1D,UAAM,MAAM,IAAI,WAAW,SAAS;AACpC,QAAI,IAAI,CAAC,yBAAyB,UAAU,CAAC,CAAC;AAE9C,QAAI,IAAI,OAAI,IAAI,EAAE,UAAU,KAAK,kBAAkB,SAAS,EAAE,QAAQ,GAAG,CAAC;AAE1E,QAAI,IAAI;AACR,eAAW,EAAE,WAAW,OAAO,KAAK,KAAK,YAAY;AACpD,YAAM,QAAQ,UAAU,WAAW;AACnC,UAAI,IAAI,OAAO,CAAC;AAChB,WAAK,MAAM;AACX,UAAI,IAAI,CAAC,MAAM,GAAG,GAAG;IACtB;AACA,WAAO,oBAAoB,WAAW,QAAQ,IAAI,MAAM,GAAG,CAAC,GAAG,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC;EAC/E;;;;EAKA,OAAe;AACd,WAAO,yBAAyB,UAAU;EAC3C;;;;EAKA,MAAM,OAAO,SAAqB,mBAA6C;AAE9E,UAAM,SAAS,yBAAyB,iBAAiB;AAEzD,QAAI,OAAO,oBAAoB,YAAY;AAC1C,YAAM,IAAI,MAAM,0BAA0B;IAC3C;AAEA,UAAM,EAAE,SAAS,IAAI;AAErB,QAAI,kBAAkB;AAEtB,QACC,CAAC;MACA,OAAI,kBAAkB,UAAU,KAAK,iBAAiB,EAAE,QAAQ;MAChE,OAAI,kBAAkB,UAAU,SAAS,WAAW,EAAE,QAAQ;IAC/D,GACC;AACD,aAAO;IACR;AAEA,eAAW,EAAE,WAAW,QAAQ,UAAU,KAAK,uBAAuB,QAAQ,GAAG;AAChF,UAAI,CAAE,MAAM,UAAU,OAAO,SAAS,SAAS,GAAI;AAClD,eAAO;MACR;AAEA,yBAAmB;IACpB;AAEA,WAAO,mBAAmB,KAAK,kBAAkB;EAClD;;;;;EAMA,yBAAyB,YAA8B;AA3PxD;AA4PE,QAAI,WAAW,SAAS,wBAAwB;AAC/C,YAAM,IAAI,MAAM,6CAA6C,sBAAsB,EAAE;IACtF;AAEA,QAAI,SAAS;AACb,UAAM,uBAA8C,IAAI,MAAM,WAAW,MAAM;AAE/E,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,YAAM,SAAS,yBAAyB,WAAW,CAAC,CAAC;AACrD,UAAI,OAAO,oBAAoB,YAAY;AAC1C,cAAM,IAAI,MAAM,2CAA2C;MAC5D;AAEA,UAAI;AACJ,UAAI,OAAO,oBAAoB,WAAW;AACzC,oBAAY;WACX,YAAO,YAAP,mBAAgB;WAChB,YAAO,YAAP,mBAAgB;QACjB,EAAE,WAAW;MACd,OAAO;AACN,oBAAY,OAAO;MACpB;AAEA,2BAAqB,CAAC,IAAI;QACzB,CAAC,OAAO,eAAe,GAAG,OAAO;MAClC;AAEA,UAAI;AACJ,eAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAChD,YAAI,WAAW,WAAW,KAAK,WAAW,CAAC,EAAE,UAAU,WAAW,CAAC,GAAG;AACrE,cAAI,SAAU,KAAK,GAAI;AACtB,kBAAM,IAAI,MAAM,uDAAuD;UACxE;AAEA,2BAAiB;AACjB;QACD;MACD;AAEA,UAAI,mBAAmB,QAAW;AACjC,cAAM,IAAI,MAAM,4CAA4C;MAC7D;AAEA,gBAAU,KAAK;IAChB;AAEA,UAAM,WAA2B;MAChC,MAAM;MACN;MACA,aAAa,KAAK;IACnB;AACA,UAAM,QAAQ,OAAI,SAAS,UAAU,UAAU,EAAE,SAAS,KAAK,CAAC,EAAE,QAAQ;AAC1E,UAAM,MAAM,IAAI,WAAW,MAAM,SAAS,CAAC;AAC3C,QAAI,IAAI,CAAC,yBAAyB,UAAU,CAAC,CAAC;AAC9C,QAAI,IAAI,OAAO,CAAC;AAChB,WAAO,SAAS,GAAG;EACpB;AACD;AAKO,SAAS,uBACf,UACA,UAAgD,CAAC,GACd;AACnC,QAAM,MAAwC,IAAI,MAAM,SAAS,KAAK,MAAM;AAC5E,WAAS,IAAI,GAAG,IAAI,SAAS,KAAK,QAAQ,KAAK;AAC9C,UAAM,CAAC,iBAAiB,SAAS,IAAI,OAAO,QAAQ,SAAS,KAAK,CAAC,CAAC,EAAE;MACrE,CAAC,CAAC,IAAI,MAAM,SAAS;IACtB,EAAE,CAAC;AACH,UAAM,UAAU,UAAU,SAAS,MAAM,EAAE,GAAG,CAAC;AAC/C,UAAM,OAAO,SAAS,YAAY,OAAO,OAAO;AAChD,UAAM,UAAU,WAAW,KAAK,OAAO,OAAO,KAAK,MAAM,EAAE,CAAC,CAAC;AAE7D,QAAI,oBAAoB,YAAY;AACnC,YAAM,IAAI,MAAM,2CAA2C;IAC5D;AAEA,UAAM,YAAY,sBAAsB,iBAAiB,SAAS,OAAO;AAEzE,QAAI,CAAC,IAAI;MACR;MACA,WAAW,WAAW,KAAK,SAAS;MACpC;MACA,QAAQ,KAAK;IACd;EACD;AACA,SAAO;AACR;AAEA,SAAS,UAAU,QAA4B;AAC9C,MAAI,SAAS,KAAK,SAAS,MAAM;AAChC,UAAM,IAAI,MAAM,gBAAgB;EACjC;AACA,QAAM,MAAgB,CAAC;AACvB,WAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC5B,SAAK,SAAU,KAAK,OAAQ,GAAG;AAC9B,UAAI,KAAK,CAAC;IACX;EACD;AACA,SAAO,WAAW,KAAK,GAAG;AAC3B;;;ACjUA,eAAsB,+BACrB,SACA,WACA,UAAkE,CAAC,GAC9C;AACrB,QAAM,kBAAkB,eAAe,WAAW,OAAO;AAEzD,MACC,CAAE,MAAM,gBAAgB,UAAU;IACjC;IACA,gBAAgB;EACjB,GACC;AACD,UAAM,IAAI,MAAM,iDAAiD;EAClE;AAEA,OAAI,mCAAS,YAAW,CAAC,gBAAgB,UAAU,cAAc,QAAQ,OAAO,GAAG;AAClF,UAAM,IAAI,MAAM,iDAAiD;EAClE;AAEA,SAAO,gBAAgB;AACxB;AAyBA,SAAS,eAAe,WAAmB,UAAgD,CAAC,GAAG;AAC9F,QAAM,kBAAkB,yBAAyB,SAAS;AAE1D,MAAI,gBAAgB,oBAAoB,YAAY;AACnD,WAAO;MACN,GAAG;MACH,WAAW,IAAI,kBAAkB,gBAAgB,SAAS,WAAW;IACtE;EACD;AAEA,QAAM,YAAY;IACjB,gBAAgB;IAChB,gBAAgB;IAChB;EACD;AACA,SAAO;IACN,GAAG;IACH;EACD;AACD;AAEO,SAAS,sBACf,iBACA,OACA,UAAkE,CAAC,GACvD;AACZ,MAAI;AACJ,UAAQ,iBAAiB;IACxB,KAAK;AACJ,kBAAY,IAAI,iBAAiB,KAAK;AACtC;IACD,KAAK;AACJ,kBAAY,IAAI,mBAAmB,KAAK;AACxC;IACD,KAAK;AACJ,kBAAY,IAAI,mBAAmB,KAAK;AACxC;IACD,KAAK;AACJ,kBAAY,IAAI,kBAAkB,KAAK;AACvC;IACD,KAAK;AACJ,kBAAY,wBAAwB,UAAU,OAAO,OAAO;AAC5D;IACD,KAAK;AACJ,kBAAY,IAAI,iBAAiB,KAAK;AACtC;IACD;AACC,YAAM,IAAI,MAAM,gCAAgC,eAAe,EAAE;EACnE;AAEA,MAAI,QAAQ,WAAW,UAAU,aAAa,MAAM,QAAQ,SAAS;AACpE,UAAM,IAAI,MAAM,oDAAoD;EACrE;AAEA,SAAO;AACR;;;;;;;;;;ACzIA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAAC;AAkBO,IAAM,gBAAgB,OAAI,OAAO,iBAAiB;EACxD,KAAK,OAAI,WAAW;EACpB,QAAQ,OAAI,WAAW;EACvB,oBAAoB,OAAI,WAAW;AACpC,CAAC;AAqBM,IAAM,cAAN,MAAMC,aAAW;EAWf,YAAY;IACnB;IACA;IACA;IACA;IACA;IACA;EACD,GAOG;AAxBH,IAAAC,cAAA,MAAA,QAAA;AACA,IAAAA,cAAA,MAAA,UAAA;AACA,IAAAA,cAAA,MAAA,QAAA;AACA,IAAAA,cAAA,MAAA,eAAA;AACA,IAAAA,cAAA,MAAA,OAAA;AACA,IAAAA,cAAA,MAAA,WAAA;AACA,IAAAA,cAAA,MAAA,yBAAA;AACA,IAAAA,cAAA,MAAA,OAAA;AACA,IAAAA,cAAA,MAAAF,WAAA;AAiBC,QAAI,WAAW,CAAC,oBAAoB,OAAO,GAAG;AAC7C,YAAM,IAAI,UAAU,wBAAwB,OAAO,EAAE;IACtD;AACA,QAAI,CAAC,mBAAmB,SAAS,KAAK,CAAC,kBAAkB,OAAO,GAAG;AAClE,YAAM,IAAI,UAAU,sBAAsB,SAAS,eAAe,OAAO,EAAE;IAC5E;AACA,QAAI,SAAS,MAAM,SAAS,GAAG;AAC9B,YAAM,IAAI,UAAU,eAAe,MAAM,4BAA4B;IACtE;AACA,QAAI,UAAU,OAAO,aAAa,EAAE,aAAa,MAAM,SAAS;AAC/D,YAAM,IAAI,UAAU,mDAAmD;IACxE;AAEA,IAAAG,cAAA,MAAK,UAAW,OAAA;AAChB,IAAAA,cAAA,MAAK,YAAa,SAAA;AAClB,IAAAA,cAAA,MAAK,UAAW,OAAA;AAChB,IAAAA,cAAA,MAAK,iBAAkB,KAAK,IAAI,CAAA;AAChC,IAAAA,cAAA,MAAK,SAAU,MAAA;AACf,IAAAA,cAAA,MAAK,aAAc,eAAe,SAAS,CAAA;AAC3C,IAAAA,cAAA,MAAK,SAAU,MAAA;AACf,IAAAA,cAAA,MAAKH,aAAa,SAAA;EACnB;;;;;;;;;;;EAYA,aAAa,OAAO;IACnB;IACA;IACA;IACA;IACA;IACA;EACD,GAOwB;AACvB,UAAM,aAAa,MAAM,UAAU,KAAK,UAAU,EAAE,UAAU,UAAU,CAAC;AACzE,QAAI,OAAO,WAAW,OAAO,OAAO,MAAM,KAAK;AAC9C,YAAM,IAAI,oBAAoB,WAAW,SAAS,2BAA2B;IAC9E;AAEA,WAAO,IAAIC,aAAW;MACrB;MACA;MACA;MACA;MACA;MACA;IACD,CAAC;EACF;EACA,YAAqB;AAEpB,WAAOG,cAAA,MAAK,eAAA,IAAkBA,cAAA,MAAK,OAAA,IAAU,KAAK,MAAO,MAAS,KAAK,IAAI;EAC5E;EAEA,aAAqB;AACpB,WAAOA,cAAA,MAAK,QAAA;EACb;EAEA,iBAAyB;AACxB,QAAIA,cAAA,MAAK,QAAA,GAAU;AAClB,aAAOA,cAAA,MAAK,QAAA;IACb;AACA,WAAOA,cAAA,MAAK,UAAA;EACb;EAEA,eAAuB;AACtB,WAAOA,cAAA,MAAK,UAAA;EACb;EAEA,qBAAiC;AAChC,UAAM,kBACL,IAAI,KAAKA,cAAA,MAAK,eAAA,CAAe,EAAE,YAAY,EAAE,MAAM,GAAG,EAAE,EAAE,QAAQ,KAAK,GAAG,IAAI;AAC/E,UAAM,UAAU,6BAA6B,KAAK,eAAe,CAAC,QAAQA,cAAA,MAAK,OAAA,CAAO,cAAc,eAAe,iBAAiB,SAASA,cAAA,MAAK,WAAA,EAAY,aAAa,EAAE,WAAW,CAAC,CAAC;AAC1L,WAAO,IAAI,YAAY,EAAE,OAAO,OAAO;EACxC;EAEA,MAAM,4BAA4B,0BAAkC;AACnE,QAAI,CAACA,cAAA,MAAK,yBAAA,GAA2B;AACpC,UAAI;AACH,cAAM,+BAA+B,KAAK,mBAAmB,GAAG,0BAA0B;UACzF,SAASA,cAAA,MAAK,QAAA;UACd,QAAQA,cAAA,MAAKJ,WAAA;QACd,CAAC;AACD,QAAAG,cAAA,MAAK,2BAA4B,wBAAA;MAClC,QAAQ;AACP,cAAM,IAAI,qCAAqC,WAAW;MAC3D;IACD;EACD;EAEA,MAAM,iBAAuC;AAC5C,QAAI,CAACC,cAAA,MAAK,yBAAA,GAA2B;AACpC,UAAIA,cAAA,MAAK,OAAA,GAAS;AACjB,cAAM,EAAE,UAAU,IAAI,MAAMA,cAAA,MAAK,OAAA,EAAQ,oBAAoB,KAAK,mBAAmB,CAAC;AACtF,QAAAD,cAAA,MAAK,2BAA4B,SAAA;MAClC,OAAO;AACN,cAAM,IAAI,qCAAqC,uCAAuC;MACvF;IACD;AACA,WAAO;MACN,MAAMC,cAAA,MAAK,QAAA;MACX,YAAY,SAASA,cAAA,MAAK,WAAA,EAAY,aAAa,EAAE,WAAW,CAAC;MACjE,eAAeA,cAAA,MAAK,eAAA;MACpB,SAASA,cAAA,MAAK,OAAA;MACd,WAAWA,cAAA,MAAK,yBAAA;MAChB,UAAUA,cAAA,MAAK,QAAA;IAChB;EACD;;;;;;;EAQA,MAAM,oBAAoB,SAKvB;AACF,QAAI,KAAK,UAAU,GAAG;AACrB,YAAM,IAAI,uBAAuB;IAClC;AACA,UAAM,SAAS,kBAAkB;AACjC,UAAM,WAAW,YAAY,MAAM;AACnC,UAAM,qBAAqB,kBAAkB,MAAM;AAEnD,UAAM,YAAY,cAAc,UAAU;MACzC,KAAK,QAAQ,MAAM,CAAC;MACpB,QAAQ;MACR;IACD,CAAC,EAAE,QAAQ;AACX,WAAO;MACN;MACA;MACA;MACA,kBAAkB,SAAS,MAAMA,cAAA,MAAK,WAAA,EAAY,KAAK,SAAS,CAAC;IAClE;EACD;;;;EAKA,SAA6B;AAC5B,UAAM,MAAM;MACX,SAASA,cAAA,MAAK,QAAA;MACd,WAAWA,cAAA,MAAK,UAAA;MAChB,SAASA,cAAA,MAAK,QAAA;MACd,gBAAgBA,cAAA,MAAK,eAAA;MACrB,QAAQA,cAAA,MAAK,OAAA;MACb,0BAA0BA,cAAA,MAAK,yBAAA;MAC/B,YAAYA,cAAA,MAAK,WAAA,EAAY,aAAa;;IAC3C;AAEA,WAAO,eAAe,KAAK,UAAU;MACpC,YAAY;MACZ,OAAO,MAAM;AACZ,cAAM,IAAI,MAAM,iCAAiC;MAClD;IACD,CAAC;AACD,WAAO;EACR;;;;;EAMA,OAAO,OACN,MACA,WACA,QACa;AACb,UAAM,WAAW,IAAIH,aAAW;MAC/B,SAAS,KAAK;MACd,WAAW,KAAK;MAChB,SAAS,KAAK;MACd,QAAQ,KAAK;MACb;MACA;IACD,CAAC;AAED,IAAAE,cAAA,UAAS,iBAAkB,KAAK,cAAA;AAChC,IAAAA,cAAA,UAAS,aAAc,eAAe,cAAc,KAAK,UAAU,CAAA;AACnE,IAAAA,cAAA,UAAS,2BAA4B,KAAK,wBAAA;AAE1C,QAAI,SAAS,UAAU,GAAG;AACzB,YAAM,IAAI,uBAAuB;IAClC;AACA,WAAO;EACR;AACD;AArOC,WAAA,oBAAA,QAAA;AACA,aAAA,oBAAA,QAAA;AACA,WAAA,oBAAA,QAAA;AACA,kBAAA,oBAAA,QAAA;AACA,UAAA,oBAAA,QAAA;AACA,cAAA,oBAAA,QAAA;AACA,4BAAA,oBAAA,QAAA;AACA,UAAA,oBAAA,QAAA;AACAH,cAAA,oBAAA,QAAA;AATM,IAAM,aAAN;",
  "names": ["Fp2", "Fp12", "msg", "DST", "Fp", "Fp6", "createHasher", "_0n", "_1n", "_2n", "_3n", "Fp", "num", "Fp2", "G2psi", "G2psi2", "ORDER", "Fp6", "Fp4Square", "Fp12", "_0n", "_1n", "_2n", "_3n", "num", "Point", "_G1Element", "_G2Element", "_GTElement", "_Scalar", "_0n", "_1n", "_2n", "_SealAPIError", "count", "toBytes", "KeyPurpose", "split", "split", "KemType", "DemType", "decrypt", "KeyServerType", "_SealClient", "__privateAdd", "__privateMethod", "_0n", "_1n", "_2n", "_3n", "tag", "createHasher", "sha256", "sha256", "__privateAdd", "__privateSet", "__privateGet", "_suiClient", "_SessionKey", "__privateAdd", "__privateSet", "__privateGet"]
}
