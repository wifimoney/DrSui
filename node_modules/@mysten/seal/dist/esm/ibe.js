import { fromHex } from "@mysten/bcs";
import { G2Element, Scalar } from "./bls12381.js";
import { deriveKey, hashToG1, kdf, KeyPurpose } from "./kdf.js";
import { xor } from "./utils.js";
import { InvalidCiphertextError } from "./error.js";
const DST_POP = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-POP-00");
class IBEServers {
  constructor(objectIds) {
    this.objectIds = objectIds;
  }
}
class BonehFranklinBLS12381Services extends IBEServers {
  constructor(services) {
    super(services.map((service) => service.objectId));
    this.publicKeys = services.map((service) => G2Element.fromBytes(service.pk));
  }
  encryptBatched(id, shares, baseKey, threshold) {
    if (this.publicKeys.length === 0 || this.publicKeys.length !== shares.length) {
      throw new Error("Invalid public keys");
    }
    const [r, nonce, keys] = encapBatched(this.publicKeys, id);
    const encryptedShares = shares.map(
      ({ share, index }, i) => xor(share, kdf(keys[i], nonce, id, this.objectIds[i], index))
    );
    const randomnessKey = deriveKey(
      KeyPurpose.EncryptedRandomness,
      baseKey,
      encryptedShares,
      threshold,
      this.objectIds
    );
    const encryptedRandomness = xor(randomnessKey, r.toBytes());
    return {
      BonehFranklinBLS12381: {
        nonce: nonce.toBytes(),
        encryptedShares,
        encryptedRandomness
      },
      $kind: "BonehFranklinBLS12381"
    };
  }
  /**
   * Returns true if the user secret key is valid for the given public key and id.
   * @param user_secret_key - The user secret key.
   * @param id - The identity.
   * @param public_key - The public key.
   * @returns True if the user secret key is valid for the given public key and id.
   */
  static verifyUserSecretKey(userSecretKey, id, publicKey) {
    const lhs = userSecretKey.pairing(G2Element.generator());
    const rhs = hashToG1(fromHex(id)).pairing(publicKey);
    return lhs.equals(rhs);
  }
  /**
   * Identity-based decryption.
   *
   * @param nonce The encryption nonce.
   * @param sk The user secret key.
   * @param ciphertext The encrypted message.
   * @param info An info parameter also included in the KDF.
   * @returns The decrypted message.
   */
  static decrypt(nonce, sk, ciphertext, id, [objectId, index]) {
    return xor(ciphertext, kdf(decap(nonce, sk), nonce, id, objectId, index));
  }
  /**
   * Decrypt all shares and verify that the randomness was used to create the given nonce.
   *
   * @param randomness - The randomness.
   * @param encryptedShares - The encrypted shares.
   * @param services - The services.
   * @param publicKeys - The public keys.
   * @param nonce - The nonce.
   * @param id - The id.
   * @returns All decrypted shares.
   */
  static decryptAllSharesUsingRandomness(randomness, encryptedShares, services, publicKeys, nonce, id) {
    if (publicKeys.length !== encryptedShares.length || publicKeys.length !== services.length) {
      throw new Error("The number of public keys, encrypted shares and services must be the same");
    }
    let r;
    try {
      r = Scalar.fromBytes(randomness);
    } catch {
      throw new InvalidCiphertextError("Invalid randomness");
    }
    const gid_r = hashToG1(id).multiply(r);
    return services.map(([objectId, index], i) => {
      return {
        index,
        share: xor(
          encryptedShares[i],
          kdf(gid_r.pairing(publicKeys[i]), nonce, id, objectId, index)
        )
      };
    });
  }
}
function encapBatched(publicKeys, id) {
  if (publicKeys.length === 0) {
    throw new Error("No public keys provided");
  }
  const r = Scalar.random();
  const nonce = G2Element.generator().multiply(r);
  const gid_r = hashToG1(id).multiply(r);
  return [r, nonce, publicKeys.map((public_key) => gid_r.pairing(public_key))];
}
function decap(nonce, usk) {
  return usk.pairing(nonce);
}
function verifyNonce(nonce, randomness, useBE = true) {
  try {
    const r = decodeRandomness(randomness, useBE);
    return G2Element.generator().multiply(r).equals(nonce);
  } catch {
    throw new InvalidCiphertextError("Invalid randomness");
  }
}
function decodeRandomness(bytes, useBE) {
  if (useBE) {
    return Scalar.fromBytes(bytes);
  } else {
    return Scalar.fromBytesLE(bytes);
  }
}
function decryptRandomness(encryptedRandomness, randomnessKey) {
  return xor(encryptedRandomness, randomnessKey);
}
function verifyNonceWithLE(nonce, randomness) {
  try {
    if (verifyNonce(nonce, randomness, false)) {
      return true;
    }
  } catch {
  }
  return verifyNonce(nonce, randomness, true);
}
export {
  BonehFranklinBLS12381Services,
  DST_POP,
  IBEServers,
  decryptRandomness,
  verifyNonce,
  verifyNonceWithLE
};
//# sourceMappingURL=ibe.js.map
