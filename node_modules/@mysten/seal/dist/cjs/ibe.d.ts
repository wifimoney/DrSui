import type { IBEEncryptions } from './bcs.js';
import type { G1Element } from './bls12381.js';
import { G2Element } from './bls12381.js';
import type { KeyServer } from './key-server.js';
import type { Share } from './shamir.js';
/**
 * The domain separation tag for the signing proof of possession.
 */
export declare const DST_POP: Uint8Array;
/**
 * The interface for the key servers.
 */
export declare abstract class IBEServers {
    objectIds: string[];
    constructor(objectIds: string[]);
    /**
     * Encrypt a batch of messages for the given identity.
     *
     * @param id The identity.
     * @param msgAndIndices The messages and the corresponding indices of the share being encrypted.
     * @returns The encrypted messages.
     */
    abstract encryptBatched(id: Uint8Array, shares: Share[], baseKey: Uint8Array, threshold: number): typeof IBEEncryptions.$inferType;
}
/**
 * Identity-based encryption based on the Boneh-Franklin IBE scheme (https://eprint.iacr.org/2001/090).
 * Note that this implementation is of the "BasicIdent" protocol which on its own is not CCA secure, so this IBE implementation should not be used on its own.
 *
 * This object represents a set of key servers that can be used to encrypt messages for a given identity.
 */
export declare class BonehFranklinBLS12381Services extends IBEServers {
    readonly publicKeys: G2Element[];
    constructor(services: KeyServer[]);
    encryptBatched(id: Uint8Array, shares: Share[], baseKey: Uint8Array, threshold: number): typeof IBEEncryptions.$inferType;
    /**
     * Returns true if the user secret key is valid for the given public key and id.
     * @param user_secret_key - The user secret key.
     * @param id - The identity.
     * @param public_key - The public key.
     * @returns True if the user secret key is valid for the given public key and id.
     */
    static verifyUserSecretKey(userSecretKey: G1Element, id: string, publicKey: G2Element): boolean;
    /**
     * Identity-based decryption.
     *
     * @param nonce The encryption nonce.
     * @param sk The user secret key.
     * @param ciphertext The encrypted message.
     * @param info An info parameter also included in the KDF.
     * @returns The decrypted message.
     */
    static decrypt(nonce: G2Element, sk: G1Element, ciphertext: Uint8Array, id: Uint8Array, [objectId, index]: [string, number]): Uint8Array;
    /**
     * Decrypt all shares and verify that the randomness was used to create the given nonce.
     *
     * @param randomness - The randomness.
     * @param encryptedShares - The encrypted shares.
     * @param services - The services.
     * @param publicKeys - The public keys.
     * @param nonce - The nonce.
     * @param id - The id.
     * @returns All decrypted shares.
     */
    static decryptAllSharesUsingRandomness(randomness: Uint8Array, encryptedShares: Uint8Array[], services: [string, number][], publicKeys: G2Element[], nonce: G2Element, id: Uint8Array): {
        index: number;
        share: Uint8Array;
    }[];
}
/**
 * Verify that the given randomness was used to crate the nonce.
 * Throws an error if the given randomness is invalid (not a BLS scalar).
 *
 * @param randomness - The randomness.
 * @param nonce - The nonce.
 * @param useBE - Flag to indicate if BE encoding is used for the randomness. Defaults to true.
 * @returns True if the randomness was used to create the nonce, false otherwise.
 */
export declare function verifyNonce(nonce: G2Element, randomness: Uint8Array, useBE?: boolean): boolean;
/**
 * Decrypt the randomness using a key.
 *
 * @param encrypted_randomness - The encrypted randomness.
 * @param derived_key - The derived key.
 * @returns The randomness. Returns both the scalar interpreted in big-endian and little-endian encoding.
 */
export declare function decryptRandomness(encryptedRandomness: Uint8Array, randomnessKey: Uint8Array): Uint8Array;
/**
 * Verify that the given randomness was used to crate the nonce.
 * Check using both big-endian and little-endian encoding of the randomness.
 *
 * Throws an error if the nonce check doesn't pass using LE encoding _and_ the randomness is invalid as a BE encoded scalar.
 *
 * @param randomness - The randomness.
 * @param nonce - The nonce.
 * @returns True if the randomness was used to create the nonce using either LE or BE encoding, false otherwise.
 */
export declare function verifyNonceWithLE(nonce: G2Element, randomness: Uint8Array): boolean;
