"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var dem_exports = {};
__export(dem_exports, {
  AesGcm256: () => AesGcm256,
  Hmac256Ctr: () => Hmac256Ctr,
  iv: () => iv
});
module.exports = __toCommonJS(dem_exports);
var import_bcs = require("@mysten/bcs");
var import_utils = require("@noble/curves/abstract/utils");
var import_hmac = require("@noble/hashes/hmac");
var import_sha3 = require("@noble/hashes/sha3");
var import_error = require("./error.js");
var import_utils2 = require("./utils.js");
const iv = Uint8Array.from([
  138,
  55,
  153,
  253,
  198,
  46,
  121,
  219,
  160,
  128,
  89,
  7,
  214,
  156,
  148,
  220
]);
async function generateAesKey() {
  const key = await crypto.subtle.generateKey(
    {
      name: "AES-GCM",
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
  return await crypto.subtle.exportKey("raw", key).then((keyData) => new Uint8Array(keyData));
}
class AesGcm256 {
  constructor(msg, aad) {
    this.plaintext = msg;
    this.aad = aad;
  }
  generateKey() {
    return generateAesKey();
  }
  async encrypt(key) {
    if (key.length !== 32) {
      throw new Error("Key must be 32 bytes");
    }
    const aesCryptoKey = await crypto.subtle.importKey(
      "raw",
      key,
      "AES-GCM",
      false,
      ["encrypt"]
    );
    const blob = new Uint8Array(
      await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv,
          additionalData: this.aad
        },
        aesCryptoKey,
        this.plaintext
      )
    );
    return {
      Aes256Gcm: {
        blob,
        aad: this.aad ?? []
      }
    };
  }
  static async decrypt(key, ciphertext) {
    if (!("Aes256Gcm" in ciphertext)) {
      throw new import_error.InvalidCiphertextError(`Invalid ciphertext ${JSON.stringify(ciphertext)}`);
    }
    if (key.length !== 32) {
      throw new Error("Key must be 32 bytes");
    }
    try {
      const aesCryptoKey = await crypto.subtle.importKey(
        "raw",
        key,
        "AES-GCM",
        false,
        ["decrypt"]
      );
      return new Uint8Array(
        await crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv,
            additionalData: new Uint8Array(ciphertext.Aes256Gcm.aad ?? [])
          },
          aesCryptoKey,
          new Uint8Array(ciphertext.Aes256Gcm.blob)
        )
      );
    } catch {
      throw new import_error.DecryptionError(`Decryption failed`);
    }
  }
}
class Hmac256Ctr {
  constructor(msg, aad) {
    this.plaintext = msg;
    this.aad = aad;
  }
  generateKey() {
    return generateAesKey();
  }
  async encrypt(key) {
    const blob = Hmac256Ctr.encryptInCtrMode(key, this.plaintext);
    const mac = Hmac256Ctr.computeMac(key, this.aad, blob);
    return {
      Hmac256Ctr: {
        blob,
        mac,
        aad: this.aad ?? []
      }
    };
  }
  static async decrypt(key, ciphertext) {
    if (!("Hmac256Ctr" in ciphertext)) {
      throw new import_error.InvalidCiphertextError(`Invalid ciphertext ${JSON.stringify(ciphertext)}`);
    }
    if (key.length !== 32) {
      throw new Error("Key must be 32 bytes");
    }
    const aad = new Uint8Array(ciphertext.Hmac256Ctr.aad ?? []);
    const blob = new Uint8Array(ciphertext.Hmac256Ctr.blob);
    const mac = Hmac256Ctr.computeMac(key, aad, blob);
    if (!(0, import_utils.equalBytes)(mac, new Uint8Array(ciphertext.Hmac256Ctr.mac))) {
      throw new import_error.DecryptionError(`Invalid MAC ${mac}`);
    }
    return Hmac256Ctr.encryptInCtrMode(key, blob);
  }
  static computeMac(key, aad, ciphertext) {
    const macInput = (0, import_utils2.flatten)([MacKeyTag, toBytes(aad.length), aad, ciphertext]);
    const mac = (0, import_hmac.hmac)(import_sha3.sha3_256, key, macInput);
    return mac;
  }
  static encryptInCtrMode(key, msg) {
    const blockSize = 32;
    const result = new Uint8Array(msg.length);
    for (let i = 0; i * blockSize < msg.length; i++) {
      const block = msg.subarray(i * blockSize, (i + 1) * blockSize);
      const mask = (0, import_hmac.hmac)(import_sha3.sha3_256, key, (0, import_utils2.flatten)([EncryptionKeyTag, toBytes(i)]));
      const encryptedBlock = (0, import_utils2.xorUnchecked)(block, mask);
      result.set(encryptedBlock, i * blockSize);
    }
    return result;
  }
}
function toBytes(n) {
  return import_bcs.bcs.u64().serialize(n).toBytes();
}
const EncryptionKeyTag = new TextEncoder().encode("HMAC-CTR-ENC");
const MacKeyTag = new TextEncoder().encode("HMAC-CTR-MAC");
//# sourceMappingURL=dem.js.map
