{
  "version": 3,
  "sources": ["../../../../src/files/readers/quilt.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '@mysten/sui/experimental';\nimport type { BlobReader } from './blob.js';\nimport { QuiltPatchBlobHeader, QuiltPatchId } from '../../utils/bcs.js';\nimport {\n\tHAS_TAGS_FLAG,\n\tparseQuiltPatchId,\n\tQUILT_PATCH_BLOB_HEADER_SIZE,\n} from '../../utils/quilts.js';\nimport { bcs } from '@mysten/bcs';\nimport { QuiltPatchTags } from '../../utils/bcs.js';\nimport { QuiltIndexV1 } from '../../utils/bcs.js';\nimport { urlSafeBase64 } from '../../utils/index.js';\nimport { QuiltFileReader } from './quilt-file.js';\n\nexport interface QuiltReaderOptions {\n\tblob: BlobReader;\n}\n\nexport class QuiltReader {\n\t#blob: BlobReader;\n\t#cache = new ClientCache();\n\n\tconstructor({ blob }: QuiltReaderOptions) {\n\t\tthis.#blob = blob;\n\t}\n\n\tasync #readBytesFromSlivers(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (!length) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\n\t\t// start loading the first sliver, but don't wait for it (may improve columnSize lookup)\n\t\tthis.#blob.getSecondarySliver({ sliverIndex: sliver }).catch(() => {});\n\n\t\tcolumnSize = columnSize ?? (await this.#blob.getColumnSize());\n\t\tconst columnOffset = Math.floor(offset / columnSize);\n\t\tlet remainingOffset = offset % columnSize;\n\t\tconst bytes = new Uint8Array(length);\n\n\t\tlet bytesRead = 0;\n\n\t\tconst nSlivers = Math.ceil(length / columnSize);\n\t\tconst slivers = new Array(nSlivers)\n\t\t\t.fill(0)\n\t\t\t.map((_, i) => this.#blob.getSecondarySliver({ sliverIndex: sliver + columnOffset + i }));\n\n\t\t// ignore errors from slivers that are not consumed below\n\t\tslivers.forEach((p) => p.catch(() => {}));\n\n\t\tfor (const sliverPromise of slivers) {\n\t\t\tconst sliver = await sliverPromise;\n\t\t\tlet chunk = remainingOffset > 0 ? sliver.subarray(remainingOffset) : sliver;\n\t\t\tremainingOffset -= chunk.length;\n\t\t\tif (chunk.length > length - bytesRead) {\n\t\t\t\tchunk = chunk.subarray(0, length - bytesRead);\n\t\t\t}\n\n\t\t\tbytes.set(chunk, bytesRead);\n\t\t\tbytesRead += chunk.length;\n\n\t\t\tif (bytesRead >= length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\tasync #readBytesFromBlob(startColumn: number, length: number, offset = 0) {\n\t\tconst result = new Uint8Array(length);\n\n\t\tif (!length) {\n\t\t\treturn result;\n\t\t}\n\t\tconst blob = await this.#blob.getBytes();\n\n\t\tconst [rowSize, symbolSize] = await Promise.all([\n\t\t\tthis.#blob.getRowSize(),\n\t\t\tthis.#blob.getSymbolSize(),\n\t\t]);\n\n\t\tconst nRows = blob.length / rowSize;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet bytesRead = 0;\n\n\t\twhile (bytesRead < length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst endIndex = Math.min(\n\t\t\t\tbaseIndex + symbolSize,\n\t\t\t\tstartIndex + length - bytesRead,\n\t\t\t\tblob.length,\n\t\t\t);\n\n\t\t\tif (startIndex >= blob.length) {\n\t\t\t\tthrow new Error('Index out of bounds');\n\t\t\t}\n\n\t\t\tconst size = endIndex - startIndex;\n\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[bytesRead + i] = blob[startIndex + i];\n\t\t\t}\n\n\t\t\tbytesRead += size;\n\n\t\t\tremainingOffset = 0;\n\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync #readBytes(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (this.#blob.hasStartedLoadingFullBlob) {\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\n\t\ttry {\n\t\t\tconst bytes = await this.#readBytesFromSlivers(sliver, length, offset, columnSize);\n\n\t\t\treturn bytes;\n\t\t} catch {\n\t\t\t// fallback to reading the full blob\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\t}\n\n\tasync getBlobHeader(sliverIndex: number) {\n\t\treturn this.#cache.read(['getBlobHeader', sliverIndex.toString()], async () => {\n\t\t\tconst blobHeader = QuiltPatchBlobHeader.parse(\n\t\t\t\tawait this.#readBytes(sliverIndex, QUILT_PATCH_BLOB_HEADER_SIZE),\n\t\t\t);\n\n\t\t\tlet offset = QUILT_PATCH_BLOB_HEADER_SIZE;\n\t\t\tlet blobSize = blobHeader.length;\n\n\t\t\tconst identifierLength = new DataView(\n\t\t\t\t(await this.#readBytes(sliverIndex, 2, offset)).buffer,\n\t\t\t).getUint16(0, true);\n\t\t\tblobSize -= 2 + identifierLength;\n\t\t\toffset += 2;\n\n\t\t\tconst identifier = bcs\n\t\t\t\t.string()\n\t\t\t\t.parse(await this.#readBytes(sliverIndex, identifierLength, offset));\n\n\t\t\toffset += identifierLength;\n\n\t\t\tlet tags: Record<string, string> | null = null;\n\t\t\tif (blobHeader.mask & HAS_TAGS_FLAG) {\n\t\t\t\tconst tagsSize = new DataView(\n\t\t\t\t\t(await this.#readBytes(sliverIndex, 2, offset)).buffer,\n\t\t\t\t).getUint16(0, true);\n\t\t\t\toffset += 2;\n\n\t\t\t\ttags = QuiltPatchTags.parse(await this.#readBytes(sliverIndex, tagsSize, offset));\n\t\t\t\tblobSize -= tagsSize + 2;\n\t\t\t\toffset += tagsSize;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tidentifier,\n\t\t\t\ttags,\n\t\t\t\tblobSize,\n\t\t\t\tcontentOffset: offset,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync readBlob(sliverIndex: number) {\n\t\tconst { identifier, tags, blobSize, contentOffset } = await this.getBlobHeader(sliverIndex);\n\n\t\tconst blobContents = await this.#readBytes(sliverIndex, blobSize, contentOffset);\n\n\t\treturn {\n\t\t\tidentifier,\n\t\t\ttags,\n\t\t\tblobContents,\n\t\t};\n\t}\n\n\treaderForPatchId(id: string) {\n\t\tconst { quiltId, patchId } = parseQuiltPatchId(id);\n\n\t\tif (quiltId !== this.#blob.blobId) {\n\t\t\tthrow new Error(\n\t\t\t\t`The requested patch ${patchId} is not part of the quilt ${this.#blob.blobId}`,\n\t\t\t);\n\t\t}\n\n\t\treturn new QuiltFileReader({ quilt: this, sliverIndex: patchId.startIndex });\n\t}\n\n\tasync readIndex() {\n\t\tconst header = new DataView((await this.#readBytes(0, 5)).buffer);\n\n\t\tconst version = header.getUint8(0);\n\n\t\tif (version !== 1) {\n\t\t\tthrow new Error(`Unsupported quilt version ${version}`);\n\t\t}\n\n\t\tconst indexSize = header.getUint32(1, true);\n\t\tconst indexBytes = await this.#readBytes(0, indexSize, 5);\n\t\tconst columnSize = await this.#blob.getColumnSize();\n\t\tconst indexSlivers = Math.ceil(indexSize / columnSize);\n\t\tconst index = QuiltIndexV1.parse(indexBytes);\n\n\t\treturn index.patches.map((patch, i) => {\n\t\t\tconst startIndex = i === 0 ? indexSlivers : index.patches[i - 1].endIndex;\n\t\t\tconst reader = new QuiltFileReader({\n\t\t\t\tquilt: this,\n\t\t\t\tsliverIndex: startIndex,\n\t\t\t\tidentifier: patch.identifier,\n\t\t\t\ttags: patch.tags,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tidentifier: patch.identifier,\n\t\t\t\tpatchId: urlSafeBase64(\n\t\t\t\t\tQuiltPatchId.serialize({\n\t\t\t\t\t\tquiltId: this.#blob.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}).toBytes(),\n\t\t\t\t),\n\t\t\t\ttags: patch.tags,\n\t\t\t\treader,\n\t\t\t};\n\t\t});\n\t}\n}\n"],
  "mappings": ";;;;;;;;AAAA;AAGA,SAAS,mBAAmB;AAE5B,SAAS,sBAAsB,oBAAoB;AACnD;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP,SAAS,WAAW;AACpB,SAAS,sBAAsB;AAC/B,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAC9B,SAAS,uBAAuB;AAMzB,MAAM,YAAY;AAAA,EAIxB,YAAY,EAAE,KAAK,GAAuB;AAJpC;AACN;AACA,+BAAS,IAAI,YAAY;AAGxB,uBAAK,OAAQ;AAAA,EACd;AAAA,EAgHA,MAAM,cAAc,aAAqB;AACxC,WAAO,mBAAK,QAAO,KAAK,CAAC,iBAAiB,YAAY,SAAS,CAAC,GAAG,YAAY;AAC9E,YAAM,aAAa,qBAAqB;AAAA,QACvC,MAAM,sBAAK,sCAAL,WAAgB,aAAa;AAAA,MACpC;AAEA,UAAI,SAAS;AACb,UAAI,WAAW,WAAW;AAE1B,YAAM,mBAAmB,IAAI;AAAA,SAC3B,MAAM,sBAAK,sCAAL,WAAgB,aAAa,GAAG,SAAS;AAAA,MACjD,EAAE,UAAU,GAAG,IAAI;AACnB,kBAAY,IAAI;AAChB,gBAAU;AAEV,YAAM,aAAa,IACjB,OAAO,EACP,MAAM,MAAM,sBAAK,sCAAL,WAAgB,aAAa,kBAAkB,OAAO;AAEpE,gBAAU;AAEV,UAAI,OAAsC;AAC1C,UAAI,WAAW,OAAO,eAAe;AACpC,cAAM,WAAW,IAAI;AAAA,WACnB,MAAM,sBAAK,sCAAL,WAAgB,aAAa,GAAG,SAAS;AAAA,QACjD,EAAE,UAAU,GAAG,IAAI;AACnB,kBAAU;AAEV,eAAO,eAAe,MAAM,MAAM,sBAAK,sCAAL,WAAgB,aAAa,UAAU,OAAO;AAChF,oBAAY,WAAW;AACvB,kBAAU;AAAA,MACX;AAEA,aAAO;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe;AAAA,MAChB;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,MAAM,SAAS,aAAqB;AACnC,UAAM,EAAE,YAAY,MAAM,UAAU,cAAc,IAAI,MAAM,KAAK,cAAc,WAAW;AAE1F,UAAM,eAAe,MAAM,sBAAK,sCAAL,WAAgB,aAAa,UAAU;AAElE,WAAO;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA,EAEA,iBAAiB,IAAY;AAC5B,UAAM,EAAE,SAAS,QAAQ,IAAI,kBAAkB,EAAE;AAEjD,QAAI,YAAY,mBAAK,OAAM,QAAQ;AAClC,YAAM,IAAI;AAAA,QACT,uBAAuB,OAAO,6BAA6B,mBAAK,OAAM,MAAM;AAAA,MAC7E;AAAA,IACD;AAEA,WAAO,IAAI,gBAAgB,EAAE,OAAO,MAAM,aAAa,QAAQ,WAAW,CAAC;AAAA,EAC5E;AAAA,EAEA,MAAM,YAAY;AACjB,UAAM,SAAS,IAAI,UAAU,MAAM,sBAAK,sCAAL,WAAgB,GAAG,IAAI,MAAM;AAEhE,UAAM,UAAU,OAAO,SAAS,CAAC;AAEjC,QAAI,YAAY,GAAG;AAClB,YAAM,IAAI,MAAM,6BAA6B,OAAO,EAAE;AAAA,IACvD;AAEA,UAAM,YAAY,OAAO,UAAU,GAAG,IAAI;AAC1C,UAAM,aAAa,MAAM,sBAAK,sCAAL,WAAgB,GAAG,WAAW;AACvD,UAAM,aAAa,MAAM,mBAAK,OAAM,cAAc;AAClD,UAAM,eAAe,KAAK,KAAK,YAAY,UAAU;AACrD,UAAM,QAAQ,aAAa,MAAM,UAAU;AAE3C,WAAO,MAAM,QAAQ,IAAI,CAAC,OAAO,MAAM;AACtC,YAAM,aAAa,MAAM,IAAI,eAAe,MAAM,QAAQ,IAAI,CAAC,EAAE;AACjE,YAAM,SAAS,IAAI,gBAAgB;AAAA,QAClC,OAAO;AAAA,QACP,aAAa;AAAA,QACb,YAAY,MAAM;AAAA,QAClB,MAAM,MAAM;AAAA,MACb,CAAC;AAED,aAAO;AAAA,QACN,YAAY,MAAM;AAAA,QAClB,SAAS;AAAA,UACR,aAAa,UAAU;AAAA,YACtB,SAAS,mBAAK,OAAM;AAAA,YACpB,SAAS;AAAA,cACR,SAAS;AAAA,cACT;AAAA,cACA,UAAU,MAAM;AAAA,YACjB;AAAA,UACD,CAAC,EAAE,QAAQ;AAAA,QACZ;AAAA,QACA,MAAM,MAAM;AAAA,QACZ;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AACD;AAhOC;AACA;AAFM;AAQA,0BAAqB,eAAC,QAAgB,QAAgB,SAAS,GAAG,YAAqB;AAC5F,MAAI,CAAC,QAAQ;AACZ,WAAO,IAAI,WAAW,CAAC;AAAA,EACxB;AAGA,qBAAK,OAAM,mBAAmB,EAAE,aAAa,OAAO,CAAC,EAAE,MAAM,MAAM;AAAA,EAAC,CAAC;AAErE,eAAa,cAAe,MAAM,mBAAK,OAAM,cAAc;AAC3D,QAAM,eAAe,KAAK,MAAM,SAAS,UAAU;AACnD,MAAI,kBAAkB,SAAS;AAC/B,QAAM,QAAQ,IAAI,WAAW,MAAM;AAEnC,MAAI,YAAY;AAEhB,QAAM,WAAW,KAAK,KAAK,SAAS,UAAU;AAC9C,QAAM,UAAU,IAAI,MAAM,QAAQ,EAChC,KAAK,CAAC,EACN,IAAI,CAAC,GAAG,MAAM,mBAAK,OAAM,mBAAmB,EAAE,aAAa,SAAS,eAAe,EAAE,CAAC,CAAC;AAGzF,UAAQ,QAAQ,CAAC,MAAM,EAAE,MAAM,MAAM;AAAA,EAAC,CAAC,CAAC;AAExC,aAAW,iBAAiB,SAAS;AACpC,UAAMA,UAAS,MAAM;AACrB,QAAI,QAAQ,kBAAkB,IAAIA,QAAO,SAAS,eAAe,IAAIA;AACrE,uBAAmB,MAAM;AACzB,QAAI,MAAM,SAAS,SAAS,WAAW;AACtC,cAAQ,MAAM,SAAS,GAAG,SAAS,SAAS;AAAA,IAC7C;AAEA,UAAM,IAAI,OAAO,SAAS;AAC1B,iBAAa,MAAM;AAEnB,QAAI,aAAa,QAAQ;AACxB;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AAEM,uBAAkB,eAAC,aAAqB,QAAgB,SAAS,GAAG;AACzE,QAAM,SAAS,IAAI,WAAW,MAAM;AAEpC,MAAI,CAAC,QAAQ;AACZ,WAAO;AAAA,EACR;AACA,QAAM,OAAO,MAAM,mBAAK,OAAM,SAAS;AAEvC,QAAM,CAAC,SAAS,UAAU,IAAI,MAAM,QAAQ,IAAI;AAAA,IAC/C,mBAAK,OAAM,WAAW;AAAA,IACtB,mBAAK,OAAM,cAAc;AAAA,EAC1B,CAAC;AAED,QAAM,QAAQ,KAAK,SAAS;AAC5B,QAAM,gBAAgB,KAAK,MAAM,SAAS,UAAU;AACpD,MAAI,kBAAkB,SAAS;AAC/B,MAAI,aAAa,cAAc,KAAK,MAAM,gBAAgB,KAAK;AAC/D,MAAI,aAAa,gBAAgB;AAEjC,MAAI,YAAY;AAEhB,SAAO,YAAY,QAAQ;AAC1B,UAAM,YAAY,aAAa,UAAU,aAAa;AACtD,UAAM,aAAa,YAAY;AAC/B,UAAM,WAAW,KAAK;AAAA,MACrB,YAAY;AAAA,MACZ,aAAa,SAAS;AAAA,MACtB,KAAK;AAAA,IACN;AAEA,QAAI,cAAc,KAAK,QAAQ;AAC9B,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACtC;AAEA,UAAM,OAAO,WAAW;AAExB,aAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC9B,aAAO,YAAY,CAAC,IAAI,KAAK,aAAa,CAAC;AAAA,IAC5C;AAEA,iBAAa;AAEb,sBAAkB;AAElB,kBAAc,aAAa,KAAK;AAChC,QAAI,eAAe,GAAG;AACrB,oBAAc;AAAA,IACf;AAAA,EACD;AAEA,SAAO;AACR;AAEM,eAAU,eAAC,QAAgB,QAAgB,SAAS,GAAG,YAAqB;AACjF,MAAI,mBAAK,OAAM,2BAA2B;AACzC,WAAO,sBAAK,8CAAL,WAAwB,QAAQ,QAAQ;AAAA,EAChD;AAEA,MAAI;AACH,UAAM,QAAQ,MAAM,sBAAK,iDAAL,WAA2B,QAAQ,QAAQ,QAAQ;AAEvE,WAAO;AAAA,EACR,QAAQ;AAEP,WAAO,sBAAK,8CAAL,WAAwB,QAAQ,QAAQ;AAAA,EAChD;AACD;",
  "names": ["sliver"]
}
