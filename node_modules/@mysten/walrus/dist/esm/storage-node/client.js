var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _fetch, _timeout, _onError, _StorageNodeClient_instances, request_fn;
import { BlobMetadata, BlobMetadataWithId, SliverData } from "../utils/bcs.js";
import {
  ConnectionTimeoutError,
  StorageNodeAPIError,
  StorageNodeError,
  UserAbortError
} from "./error.js";
import { mergeHeaders } from "./utils.js";
class StorageNodeClient {
  constructor({ fetch: overriddenFetch, timeout, onError } = {}) {
    __privateAdd(this, _StorageNodeClient_instances);
    __privateAdd(this, _fetch);
    __privateAdd(this, _timeout);
    __privateAdd(this, _onError);
    __privateSet(this, _fetch, overriddenFetch ?? globalThis.fetch);
    __privateSet(this, _timeout, timeout ?? 3e4);
    __privateSet(this, _onError, onError);
  }
  /**
   * Gets the metadata associated with a Walrus blob.
   */
  async getBlobMetadata({ blobId }, options) {
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/metadata`, {
      ...options,
      headers: mergeHeaders({ Accept: "application/octet-stream" }, options.headers)
    });
    const bcsBytes = await response.arrayBuffer();
    return BlobMetadataWithId.parse(new Uint8Array(bcsBytes));
  }
  /**
   * Gets the status associated with a Walrus blob.
   */
  async getBlobStatus({ blobId }, options) {
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/status`, options);
    const json = await response.json();
    const blobStatus = json.success.data;
    if (blobStatus === "nonexistent") {
      return { type: "nonexistent" };
    }
    if ("invalid" in blobStatus) {
      return {
        type: "invalid",
        ...blobStatus.invalid
      };
    }
    if ("permanent" in blobStatus) {
      return {
        type: "permanent",
        ...blobStatus.permanent
      };
    }
    if ("deletable" in blobStatus) {
      return {
        type: "deletable",
        ...blobStatus.deletable
      };
    }
    throw new StorageNodeError(`Unknown blob status received: ${blobStatus}`);
  }
  /**
   * Stores the metadata associated with a registered Walrus blob at this storage
   * node. This is a pre-requisite for storing the encoded slivers of the blob. The
   * ID of the blob must first be registered on Sui, after which storing the metadata
   * becomes possible.
   *
   * This endpoint may return an error if the node has not yet received the
   * registration event from the chain.
   */
  async storeBlobMetadata({ blobId, metadata }, options) {
    const isBcsInput = typeof metadata === "object" && "V1" in metadata;
    const body = isBcsInput ? BlobMetadata.serialize(metadata).toBytes() : metadata;
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/metadata`, {
      ...options,
      method: "PUT",
      body,
      headers: mergeHeaders({ "Content-Type": "application/octet-stream" }, options.headers)
    });
    const json = await response.json();
    return json;
  }
  /**
   * Gets the primary or secondary sliver identified by the specified blob ID and
   * index. The index should represent a sliver that is assigned to be stored at one
   * of the shards managed by this storage node during this epoch.
   */
  async getSliver({ blobId, sliverPairIndex, sliverType }, options) {
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`, {
      ...options,
      headers: mergeHeaders({ Accept: "application/octet-stream" }, options.headers)
    });
    const bcsBytes = await response.arrayBuffer();
    return SliverData.parse(new Uint8Array(bcsBytes));
  }
  /**
   * Stores a primary or secondary blob sliver at the storage node.
   */
  async storeSliver({ blobId, sliverPairIndex, sliverType, sliver }, options) {
    const isBcsInput = typeof sliver === "object" && "symbols" in sliver;
    const body = isBcsInput ? SliverData.serialize(sliver).toBytes() : sliver;
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`, {
      ...options,
      method: "PUT",
      body,
      headers: mergeHeaders({ "Content-Type": "application/octet-stream" }, options.headers)
    });
    const json = await response.json();
    return json;
  }
  /**
   * Gets a signed storage confirmation from this storage node, indicating that all shards
   * assigned to this storage node for the current epoch have stored their respective slivers.
   */
  async getDeletableBlobConfirmation({ blobId, objectId }, options) {
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/confirmation/deletable/${objectId}`, options);
    const json = await response.json();
    return json;
  }
  /**
   * Gets a signed storage confirmation from this storage node, indicating that all shards
   * assigned to this storage node for the current epoch have stored their respective slivers.
   */
  async getPermanentBlobConfirmation({ blobId }, options) {
    const response = await __privateMethod(this, _StorageNodeClient_instances, request_fn).call(this, `/v1/blobs/${blobId}/confirmation/permanent`, options);
    const json = await response.json();
    return json;
  }
}
_fetch = new WeakMap();
_timeout = new WeakMap();
_onError = new WeakMap();
_StorageNodeClient_instances = new WeakSet();
request_fn = async function(path, options) {
  var _a, _b, _c;
  const { nodeUrl, signal, timeout, ...init } = options;
  if (signal?.aborted) {
    throw new UserAbortError();
  }
  const timeoutSignal = AbortSignal.timeout(timeout ?? __privateGet(this, _timeout));
  let response;
  try {
    const fetch = __privateGet(this, _fetch);
    response = await fetch(`${nodeUrl}${path}`, {
      ...init,
      signal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal
    });
  } catch (error) {
    if (signal?.aborted) {
      throw new UserAbortError();
    }
    if (error instanceof Error && error.name === "AbortError") {
      const error2 = new ConnectionTimeoutError();
      (_a = __privateGet(this, _onError)) == null ? void 0 : _a.call(this, error2);
      throw error2;
    }
    (_b = __privateGet(this, _onError)) == null ? void 0 : _b.call(this, error);
    throw error;
  }
  if (!response.ok) {
    const errorText = await response.text().catch((reason) => reason);
    const errorJSON = safeParseJSON(errorText);
    const errorMessage = errorJSON ? void 0 : errorText;
    const error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);
    (_c = __privateGet(this, _onError)) == null ? void 0 : _c.call(this, error);
    throw error;
  }
  return response;
};
function safeParseJSON(value) {
  try {
    return JSON.parse(value);
  } catch {
    return void 0;
  }
}
export {
  StorageNodeClient
};
//# sourceMappingURL=client.js.map
